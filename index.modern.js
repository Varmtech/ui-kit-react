import React__default, { createElement, Children, useState, useEffect, useRef, useLayoutEffect, useCallback, createRef } from 'react';
import { useDispatch, useSelector, shallowEqual, Provider } from 'react-redux';
import createSagaMiddleware, { eventChannel } from 'redux-saga';
import { createStore, combineReducers, applyMiddleware, compose } from 'redux';
import styled, { createGlobalStyle, keyframes } from 'styled-components';
import FileSaver from 'file-saver';
import { put, call, take, takeLatest, takeEvery, select, all } from 'redux-saga/effects';
import Cropper from 'react-easy-crop';
import Carousel from 'react-elastic-carousel';
import { v4 } from 'uuid';

/** A function that accepts a potential "extra argument" value to be injected later,
 * and returns an instance of the thunk middleware that uses that value
 */
function createThunkMiddleware(extraArgument) {
  // Standard Redux middleware definition pattern:
  // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware
  var middleware = function middleware(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        // The thunk middleware looks for any functions that were passed to `store.dispatch`.
        // If this "action" is really a function, call it and return the result.
        if (typeof action === 'function') {
          // Inject the store's `dispatch` and `getState` methods, as well as any "extra arg"
          return action(dispatch, getState, extraArgument);
        } // Otherwise, pass the action down the middleware chain as usual


        return next(action);
      };
    };
  };

  return middleware;
}

var thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version
// with whatever "extra arg" they want to inject into their thunks

thunk.withExtraArgument = createThunkMiddleware;

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = function (obj, key, value) { return key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value }) : obj[key] = value; };
var __spreadValues = function (a, b) {
    for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
        for (var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++) {
            var prop = _c[_i];
            if (__propIsEnum.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
        }
    return a;
};
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
    if (arguments.length === 0)
        return void 0;
    if (typeof arguments[0] === "object")
        return compose;
    return compose.apply(null, arguments);
};
// src/isPlainObject.ts
function isPlainObject(value) {
    if (typeof value !== "object" || value === null)
        return false;
    var proto = Object.getPrototypeOf(value);
    if (proto === null)
        return true;
    var baseProto = proto;
    while (Object.getPrototypeOf(baseProto) !== null) {
        baseProto = Object.getPrototypeOf(baseProto);
    }
    return proto === baseProto;
}
function getTimeMeasureUtils(maxDelay, fnName) {
    var elapsed = 0;
    return {
        measureTime: function (fn) {
            var started = Date.now();
            try {
                return fn();
            }
            finally {
                var finished = Date.now();
                elapsed += finished - started;
            }
        },
        warnIfExceeded: function () {
            if (elapsed > maxDelay) {
                console.warn(fnName + " took " + elapsed + "ms, which is more than the warning threshold of " + maxDelay + "ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.");
            }
        }
    };
}
var MiddlewareArray = /** @class */ (function (_super) {
    __extends(MiddlewareArray, _super);
    function MiddlewareArray() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.apply(this, args) || this;
        Object.setPrototypeOf(_this, MiddlewareArray.prototype);
        return _this;
    }
    Object.defineProperty(MiddlewareArray, Symbol.species, {
        get: function () {
            return MiddlewareArray;
        },
        enumerable: false,
        configurable: true
    });
    MiddlewareArray.prototype.concat = function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        return _super.prototype.concat.apply(this, arr);
    };
    MiddlewareArray.prototype.prepend = function () {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        if (arr.length === 1 && Array.isArray(arr[0])) {
            return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr[0].concat(this))))();
        }
        return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr.concat(this))))();
    };
    return MiddlewareArray;
}(Array));
// src/immutableStateInvariantMiddleware.ts
var isProduction = process.env.NODE_ENV === "production";
var prefix = "Invariant failed";
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    throw new Error(prefix + ": " + (message || ""));
}
function stringify(obj, serializer, indent, decycler) {
    return JSON.stringify(obj, getSerialize(serializer, decycler), indent);
}
function getSerialize(serializer, decycler) {
    var stack = [], keys = [];
    if (!decycler)
        decycler = function (_, value) {
            if (stack[0] === value)
                return "[Circular ~]";
            return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
        };
    return function (key, value) {
        if (stack.length > 0) {
            var thisPos = stack.indexOf(this);
            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
            if (~stack.indexOf(value))
                value = decycler.call(this, key, value);
        }
        else
            stack.push(value);
        return serializer == null ? value : serializer.call(this, key, value);
    };
}
function isImmutableDefault(value) {
    return typeof value !== "object" || value == null || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
    var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
    return {
        detectMutations: function () {
            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
        }
    };
}
function trackProperties(isImmutable, ignorePaths, obj, path) {
    if (ignorePaths === void 0) { ignorePaths = []; }
    if (path === void 0) { path = ""; }
    var tracked = { value: obj };
    if (!isImmutable(obj)) {
        tracked.children = {};
        for (var key in obj) {
            var childPath = path ? path + "." + key : key;
            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
                continue;
            }
            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
        }
    }
    return tracked;
}
function detectMutations(isImmutable, ignorePaths, trackedProperty, obj, sameParentRef, path) {
    if (ignorePaths === void 0) { ignorePaths = []; }
    if (sameParentRef === void 0) { sameParentRef = false; }
    if (path === void 0) { path = ""; }
    var prevObj = trackedProperty ? trackedProperty.value : void 0;
    var sameRef = prevObj === obj;
    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
        return { wasMutated: true, path: path };
    }
    if (isImmutable(prevObj) || isImmutable(obj)) {
        return { wasMutated: false };
    }
    var keysToDetect = {};
    for (var key in trackedProperty.children) {
        keysToDetect[key] = true;
    }
    for (var key in obj) {
        keysToDetect[key] = true;
    }
    for (var key in keysToDetect) {
        var childPath = path ? path + "." + key : key;
        if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
            continue;
        }
        var result = detectMutations(isImmutable, ignorePaths, trackedProperty.children[key], obj[key], sameRef, childPath);
        if (result.wasMutated) {
            return result;
        }
    }
    return { wasMutated: false };
}
function createImmutableStateInvariantMiddleware(options) {
    if (options === void 0) { options = {}; }
    if (process.env.NODE_ENV === "production") {
        return function () { return function (next) { return function (action) { return next(action); }; }; };
    }
    var _c = options.isImmutable, isImmutable = _c === void 0 ? isImmutableDefault : _c, ignoredPaths = options.ignoredPaths, _d = options.warnAfter, warnAfter = _d === void 0 ? 32 : _d, ignore = options.ignore;
    ignoredPaths = ignoredPaths || ignore;
    var track = trackForMutations.bind(null, isImmutable, ignoredPaths);
    return function (_c) {
        var getState = _c.getState;
        var state = getState();
        var tracker = track(state);
        var result;
        return function (next) { return function (action) {
            var measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
            measureUtils.measureTime(function () {
                state = getState();
                result = tracker.detectMutations();
                tracker = track(state);
                invariant(!result.wasMutated, "A state mutation was detected between dispatches, in the path '" + (result.path || "") + "'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
            });
            var dispatchedAction = next(action);
            measureUtils.measureTime(function () {
                state = getState();
                result = tracker.detectMutations();
                tracker = track(state);
                result.wasMutated && invariant(!result.wasMutated, "A state mutation was detected inside a dispatch, in the path: " + (result.path || "") + ". Take a look at the reducer(s) handling the action " + stringify(action) + ". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
            });
            measureUtils.warnIfExceeded();
            return dispatchedAction;
        }; };
    };
}
// src/serializableStateInvariantMiddleware.ts
function isPlain(val) {
    var type = typeof val;
    return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject(val);
}
function findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths) {
    if (path === void 0) { path = ""; }
    if (isSerializable === void 0) { isSerializable = isPlain; }
    if (ignoredPaths === void 0) { ignoredPaths = []; }
    var foundNestedSerializable;
    if (!isSerializable(value)) {
        return {
            keyPath: path || "<root>",
            value: value
        };
    }
    if (typeof value !== "object" || value === null) {
        return false;
    }
    var entries = getEntries != null ? getEntries(value) : Object.entries(value);
    var hasIgnoredPaths = ignoredPaths.length > 0;
    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var _c = entries_1[_i], key = _c[0], nestedValue = _c[1];
        var nestedPath = path ? path + "." + key : key;
        if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath) >= 0) {
            continue;
        }
        if (!isSerializable(nestedValue)) {
            return {
                keyPath: nestedPath,
                value: nestedValue
            };
        }
        if (typeof nestedValue === "object") {
            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths);
            if (foundNestedSerializable) {
                return foundNestedSerializable;
            }
        }
    }
    return false;
}
function createSerializableStateInvariantMiddleware(options) {
    if (options === void 0) { options = {}; }
    if (process.env.NODE_ENV === "production") {
        return function () { return function (next) { return function (action) { return next(action); }; }; };
    }
    var _c = options.isSerializable, isSerializable = _c === void 0 ? isPlain : _c, getEntries = options.getEntries, _d = options.ignoredActions, ignoredActions = _d === void 0 ? [] : _d, _e = options.ignoredActionPaths, ignoredActionPaths = _e === void 0 ? ["meta.arg", "meta.baseQueryMeta"] : _e, _f = options.ignoredPaths, ignoredPaths = _f === void 0 ? [] : _f, _g = options.warnAfter, warnAfter = _g === void 0 ? 32 : _g, _h = options.ignoreState, ignoreState = _h === void 0 ? false : _h, _j = options.ignoreActions, ignoreActions = _j === void 0 ? false : _j;
    return function (storeAPI) { return function (next) { return function (action) {
        var result = next(action);
        var measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
        if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
            measureUtils.measureTime(function () {
                var foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths);
                if (foundActionNonSerializableValue) {
                    var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;
                    console.error("A non-serializable value was detected in an action, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
                }
            });
        }
        if (!ignoreState) {
            measureUtils.measureTime(function () {
                var state = storeAPI.getState();
                var foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths);
                if (foundStateNonSerializableValue) {
                    var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;
                    console.error("A non-serializable value was detected in the state, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the reducer(s) handling this action type: " + action.type + ".\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)");
                }
            });
            measureUtils.warnIfExceeded();
        }
        return result;
    }; }; };
}
// src/getDefaultMiddleware.ts
function isBoolean(x) {
    return typeof x === "boolean";
}
function curryGetDefaultMiddleware() {
    return function curriedGetDefaultMiddleware(options) {
        return getDefaultMiddleware(options);
    };
}
function getDefaultMiddleware(options) {
    if (options === void 0) { options = {}; }
    var _c = options.thunk, thunk$1 = _c === void 0 ? true : _c, _d = options.immutableCheck, immutableCheck = _d === void 0 ? true : _d, _e = options.serializableCheck, serializableCheck = _e === void 0 ? true : _e;
    var middlewareArray = new MiddlewareArray();
    if (thunk$1) {
        if (isBoolean(thunk$1)) {
            middlewareArray.push(thunk);
        }
        else {
            middlewareArray.push(thunk.withExtraArgument(thunk$1.extraArgument));
        }
    }
    if (process.env.NODE_ENV !== "production") {
        if (immutableCheck) {
            var immutableOptions = {};
            if (!isBoolean(immutableCheck)) {
                immutableOptions = immutableCheck;
            }
            middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
        }
        if (serializableCheck) {
            var serializableOptions = {};
            if (!isBoolean(serializableCheck)) {
                serializableOptions = serializableCheck;
            }
            middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
        }
    }
    return middlewareArray;
}
// src/configureStore.ts
var IS_PRODUCTION = process.env.NODE_ENV === "production";
function configureStore(options) {
    var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
    var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;
    var rootReducer;
    if (typeof reducer === "function") {
        rootReducer = reducer;
    }
    else if (isPlainObject(reducer)) {
        rootReducer = combineReducers(reducer);
    }
    else {
        throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
    }
    var finalMiddleware = middleware;
    if (typeof finalMiddleware === "function") {
        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {
            throw new Error("when using a middleware builder function, an array of middleware must be returned");
        }
    }
    if (!IS_PRODUCTION && finalMiddleware.some(function (item) { return typeof item !== "function"; })) {
        throw new Error("each middleware provided to configureStore must be a function");
    }
    var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
    var finalCompose = compose;
    if (devTools) {
        finalCompose = composeWithDevTools(__spreadValues({
            trace: !IS_PRODUCTION
        }, typeof devTools === "object" && devTools));
    }
    var storeEnhancers = [middlewareEnhancer];
    if (Array.isArray(enhancers)) {
        storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);
    }
    else if (typeof enhancers === "function") {
        storeEnhancers = enhancers(storeEnhancers);
    }
    var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
    return createStore(rootReducer, preloadedState, composedEnhancer);
}
//# sourceMappingURL=redux-toolkit.esm.js.map

function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  strings.raw = raw;
  return strings;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var CREATE_CHANNEL = 'CREATE_CHANNEL';
var GET_CHANNELS = 'GET_CHANNELS';
var GET_CHANNELS_FOR_FORWARD = 'GET_CHANNELS_FOR_FORWARD';
var LOAD_MORE_CHANNEL = 'LOAD_MORE_CHANNEL';
var LOAD_MORE_CHANNELS_FOR_FORWARD = 'LOAD_MORE_CHANNELS_FOR_FORWARD';
var ADD_CHANNEL = 'ADD_CHANNEL';
var ADD_CHANNELS = 'ADD_CHANNELS';
var ADD_CHANNELS_FOR_FORWARD = 'ADD_CHANNELS_FOR_FORWARD';
var SET_CHANNELS = 'SET_CHANNELS';
var SET_CHANNELS_FOR_FORWARD = 'SET_CHANNELS_FOR_FORWARD';
var DELETE_CHANNEL = 'DELETE_CHANNEL';
var BLOCK_CHANNEL = 'BLOCK_CHANNEL';
var SET_CHANNELS_LOADING_STATE = 'SET_CHANNELS_LOADING_STATE';
var CHANNELS_HAS_NEXT = 'CHANNELS_HAS_NEXT';
var SWITCH_CHANNEL = 'SWITCH_CHANNEL';
var SET_ACTIVE_CHANNEL = 'SET_ACTIVE_CHANNEL';
var UPDATE_CHANNEL = 'UPDATE_CHANNEL';
var UPDATE_CHANNEL_DATA = 'UPDATE_CHANNEL_DATA';
var REMOVE_CHANNEL = 'REMOVE_CHANNEL';
var REMOVE_CHANNEL_CACHES = 'REMOVE_CHANNEL_CACHES';
var UPDATE_CHANNEL_LAST_MESSAGE = 'UPDATE_CHANNEL_LAST_MESSAGE';
var UPDATE_CHANNEL_LAST_MESSAGE_STATUS = 'UPDATE_CHANNEL_LAST_MESSAGE_STATUS';
var MARK_MESSAGES_AS_READ = 'MARK_MESSAGES_AS_READ';
var MARK_MESSAGES_AS_DELIVERED = 'MARK_MESSAGES_AS_DELIVERED';
var SEND_TYPING = 'SEND_TYPING';
var SWITCH_TYPING_INDICATOR = 'SWITCH_TYPING_INDICATOR';
var JOIN_TO_CHANNEL = 'JOIN_TO_CHANNEL';
var SET_IS_DRAGGING = 'SET_IS_DRAGGING';
var SET_DRAGGED_ATTACHMENTS = 'SET_DRAGGED_ATTACHMENTS';
var WATCH_FOR_EVENTS = 'WATCH_FOR_EVENTS';
var SET_CHANNEL_TO_REMOVE = 'SET_CHANNEL_TO_REMOVE';
var SET_CHANNEL_TO_ADD = 'SET_CHANNEL_TO_ADD';
var SET_ADDED_TO_CHANNEL = 'SET_ADDED_TO_CHANNEL';
var SET_CHANNEL_TO_HIDE = 'SET_CHANNEL_TO_HIDE';
var SET_CHANNEL_TO_UNHIDE = 'SET_CHANNEL_TO_UNHIDE';
var TURN_OFF_NOTIFICATION = 'TURN_OFF_NOTIFICATION';
var TURN_ON_NOTIFICATION = 'TURN_ON_NOTIFICATION';
var MARK_CHANNEL_AS_READ = 'MARK_CHANNEL_AS_READ';
var MARK_CHANNEL_AS_UNREAD = 'MARK_CHANNEL_AS_UNREAD';
var CHANNEL_INFO_OPEN_CLOSE = 'CHANNEL_INFO_OPEN_CLOSE';
var LEAVE_CHANNEL = 'LEAVE_CHANNEL';
var TOGGLE_EDIT_CHANNEL = 'TOGGLE_EDIT_CHANNEL';
var CHECK_USER_STATUS = 'CHECK_USER_STATUS';
var UPDATE_USER_STATUS_ON_CHANNEL = 'UPDATE_USER_STATUS_ON_CHANNEL';
var SET_CHANNEL_LIST_WIDTH = 'SET_CHANNEL_LIST_WIDTH';
var CLEAR_HISTORY = 'CLEAR_HISTORY';
var DELETE_ALL_MESSAGES = 'DELETE_ALL_MESSAGES';
var DESTROY_SESSION = 'DESTROY_SESSION';
var CHANNEL_EVENT_TYPES = {
  CREATE: 'CREATE',
  JOIN: 'JOIN',
  LEAVE: 'LEAVE',
  BLOCK: 'BLOCK',
  UNBLOCK: 'UNBLOCK',
  ADD_MEMBERS: 'ADD_MEMBERS',
  KICK_MEMBERS: 'KICK_MEMBERS',
  BLOCK_MEMBERS: 'BLOCK_MEMBERS',
  UPDATE_CHANNEL: 'UPDATE_CHANNEL',
  MESSAGE: 'MESSAGE',
  DELETE: 'DELETE',
  DELETE_MESSAGE: 'DELETE_MESSAGE',
  REACTION_ADDED: 'REACTION_ADDED',
  REACTION_DELETED: 'REACTION_DELETED',
  EDIT_MESSAGE: 'EDIT_MESSAGE',
  START_TYPING: 'START_TYPING',
  STOP_TYPING: 'STOP_TYPING',
  MESSAGE_MARKERS_RECEIVED: 'MESSAGE_MARKERS_RECEIVED',
  UNREAD_MESSAGES_INFO: 'UNREAD_MESSAGES_INFO',
  HIDE: 'HIDE',
  UNHIDE: 'UNHIDE',
  MUTE: 'MUTE',
  UNMUTE: 'UNMUTE',
  CHANNEL_MARKED_AS_UNREAD: 'CHANNEL_MARKED_AS_UNREAD',
  CHANNEL_MARKED_AS_READ: 'CHANNEL_MARKED_AS_READ',
  CLEAR_HISTORY: 'CLEAR_HISTORY',
  CHANGE_ROLE: 'CHANGE_ROLE',
  CHANGE_OWNER: 'CHANGE_OWNER',
  MEMBER_BLOCKED: 'MEMBER_BLOCKED',
  MEMBER_UNBLOCKED: 'MEMBER_UNBLOCKED'
};

var MESSAGE_DELIVERY_STATUS = {
  PENDING: 'pending',
  SENT: 'sent',
  DELIVERED: 'received',
  READ: 'displayed'
};
var MESSAGE_STATUS = {
  NONE: 'None',
  EDIT: 'Edited',
  DELETE: 'Deleted',
  FAILED: 'failed'
};
var UPLOAD_STATE = {
  UPLOADING: 'uploading',
  PAUSED: 'paused',
  SUCCESS: 'success',
  FAIL: 'fail'
};
var LOADING_STATE = {
  LOADING: 1,
  LOADED: 2
};
var CHANNEL_TYPE = {
  PRIVATE: 'Private',
  PUBLIC: 'Public',
  DIRECT: 'Direct'
};
var PRESENCE_STATUS = {
  OFFLINE: 'Offline',
  ONLINE: 'Online'
};
var attachmentTypes = {
  image: 'image',
  video: 'video',
  audio: 'audio',
  file: 'file',
  link: 'link',
  voice: 'voice'
};
var channelDetailsTabs = {
  member: 'Members',
  media: 'Media',
  file: 'Files',
  link: 'Links',
  voice: 'Voice'
};

var initialState = {
  channelsLoadingState: null,
  channelsForForwardLoadingState: null,
  usersLoadingState: null,
  channelsHasNext: true,
  channelsForForwardHasNext: true,
  channels: [],
  channelsForForward: [],
  activeChannel: {},
  roles: [],
  users: [],
  errorNotification: '',
  notifications: [],
  typingIndicator: {},
  searchValue: '',
  addedChannel: null,
  addedToChannel: null,
  deletedChannel: null,
  hiddenChannel: null,
  visibleChannel: null,
  channelInfoIsOpen: false,
  channelEditMode: false,
  channelListWidth: 0,
  isDragging: false,
  draggedAttachments: []
};
var ChannelReducer = (function (state, _temp) {
  if (state === void 0) {
    state = initialState;
  }

  var _ref = _temp === void 0 ? {
    type: ''
  } : _temp,
      type = _ref.type,
      payload = _ref.payload;

  var newState = _extends({}, state);

  switch (type) {
    case GET_CHANNELS:
      {
        var search = payload.params.search;

        if (search === '' || search) {
          newState.searchValue = search;
        }

        return newState;
      }

    case SET_CHANNELS:
      {
        newState.channels = [].concat(payload.channels);
        return newState;
      }

    case SET_CHANNELS_FOR_FORWARD:
      {
        newState.channelsForForward = [].concat(payload.channels);
        return newState;
      }

    case ADD_CHANNEL:
      {
        if (!newState.channels.find(function (chan) {
          return chan.id === payload.channel.id;
        })) {
          newState.channels = [payload.channel].concat(newState.channels);
        }

        return newState;
      }

    case ADD_CHANNELS:
      {
        newState.channels = [].concat(newState.channels, payload.channels);
        return newState;
      }

    case ADD_CHANNELS_FOR_FORWARD:
      {
        newState.channelsForForward = [].concat(newState.channelsForForward, payload.channels);
        return newState;
      }

    case REMOVE_CHANNEL:
      {
        var channelId = payload.channelId;
        var channelsCpy = newState.channels;
        newState.channels = channelsCpy.filter(function (chan) {
          return chan.id !== channelId;
        });
        return newState;
      }

    case SET_CHANNEL_TO_ADD:
      {
        var channel = payload.channel;
        newState.addedChannel = channel;
        return newState;
      }

    case SET_ADDED_TO_CHANNEL:
      {
        var _channel = payload.channel;
        newState.addedToChannel = _channel;
        return newState;
      }

    case SET_CHANNEL_TO_REMOVE:
      {
        var _channel2 = payload.channel;
        newState.deletedChannel = _channel2;
        return newState;
      }

    case SET_CHANNEL_TO_HIDE:
      {
        var _channel3 = payload.channel;
        newState.hiddenChannel = _channel3;
        return newState;
      }

    case SET_CHANNEL_TO_UNHIDE:
      {
        var _channel4 = payload.channel;
        newState.visibleChannel = _channel4;
        return newState;
      }

    case SET_CHANNELS_LOADING_STATE:
      {
        var _state = payload.state,
            forForward = payload.forForward;

        if (forForward) {
          newState.channelsForForwardLoadingState = _state;
        } else {
          newState.channelsLoadingState = _state;
        }

        return newState;
      }

    case CHANNELS_HAS_NEXT:
      {
        var hasNext = payload.hasNext,
            _forForward = payload.forForward;

        if (_forForward) {
          newState.channelsForForwardHasNext = hasNext;
        } else {
          newState.channelsHasNext = hasNext;
        }

        return newState;
      }

    case SET_ACTIVE_CHANNEL:
      {
        newState.activeChannel = payload.channel || {};
        return newState;
      }

    case UPDATE_CHANNEL_DATA:
      {
        var updateData = payload.config;
        var updatedChannels = newState.channels.map(function (channel) {
          if (channel.id === payload.channelId) {
            return _extends({}, channel, updateData);
          }

          return channel;
        });

        if (newState.activeChannel.id === payload.channelId) {
          var activeChannelCopy = _extends({}, newState.activeChannel);

          newState.activeChannel = _extends({}, activeChannelCopy, updateData);
        }

        newState.channels = updatedChannels;
        return newState;
      }

    case UPDATE_USER_STATUS_ON_CHANNEL:
      {
        var usersMap = payload.usersMap;

        var _updatedChannels = newState.channels.map(function (channel) {
          if (channel.type === CHANNEL_TYPE.DIRECT && usersMap[channel.peer.id]) {
            return _extends({}, channel, {
              peer: usersMap[channel.peer.id]
            });
          }

          return channel;
        });

        if (newState.activeChannel.type === CHANNEL_TYPE.DIRECT && usersMap[newState.activeChannel.peer.id]) {
          newState.activeChannel = _extends({}, newState.activeChannel, {
            peer: usersMap[newState.activeChannel.peer.id]
          });
        }

        newState.channels = [].concat(_updatedChannels);
        return newState;
      }

    case UPDATE_CHANNEL_LAST_MESSAGE:
      {
        var _channel5 = payload.channel,
            message = payload.message;
        var updateChannel = newState.channels.find(function (chan) {
          return chan.id === _channel5.id;
        });

        if (message.state === 'Deleted' || message.state === 'Edited') {
          var _updateChannel;

          if (((_updateChannel = updateChannel) === null || _updateChannel === void 0 ? void 0 : _updateChannel.lastMessage.id) === message.id) {
            newState.channels = newState.channels.map(function (chan) {
              if (chan.id === _channel5.id) {
                return _extends({}, chan, {
                  lastMessage: message
                });
              }

              return chan;
            });
          }
        } else {
          var _updatedChannels2 = newState.channels.filter(function (chan) {
            return chan.id !== _channel5.id;
          });

          if (updateChannel) {
            updateChannel = _extends({}, updateChannel, {
              lastMessage: message
            });
            newState.channels = [updateChannel].concat(_updatedChannels2);
          }
        }

        return newState;
      }

    case UPDATE_CHANNEL_LAST_MESSAGE_STATUS:
      {
        var _channel6 = payload.channel,
            _message = payload.message;
        newState.channels = newState.channels.map(function (chan) {
          if (chan.id === _channel6.id) {
            return _extends({}, _channel6, {
              lastMessage: _extends({}, _channel6.lastMessage, {
                deliveryStatus: _message.deliveryStatus,
                selfMarkers: _message.selfMarkers,
                state: _message.state
              })
            });
          }

          return chan;
        });
        return newState;
      }

    case CHANNEL_INFO_OPEN_CLOSE:
      {
        newState.channelInfoIsOpen = payload.open;
        return newState;
      }

    case TOGGLE_EDIT_CHANNEL:
      {
        newState.channelEditMode = payload.state;
        return newState;
      }

    case SWITCH_TYPING_INDICATOR:
      {
        var typingState = payload.typingState,
            _channelId = payload.channelId,
            from = payload.from;

        if (typingState) {
          var _extends2;

          newState.typingIndicator = _extends({}, newState.typingIndicator, (_extends2 = {}, _extends2[_channelId] = {
            from: from,
            typingState: typingState
          }, _extends2));
        } else {
          if (newState.typingIndicator[_channelId]) {
            var copyData = _extends({}, newState.typingIndicator);

            delete copyData[_channelId];
            newState.typingIndicator = copyData;
          }
        }

        return newState;
      }

    case SET_IS_DRAGGING:
      {
        var isDragging = payload.isDragging;
        newState.isDragging = isDragging;
        return newState;
      }

    case SET_DRAGGED_ATTACHMENTS:
      {
        var attachments = payload.attachments,
            _type = payload.type;

        if (attachments.length && attachments.length > 0) {
          newState.draggedAttachments = attachments.map(function (attachment) {
            return {
              data: attachment.data,
              name: attachment.name,
              type: attachment.type,
              attachmentType: _type
            };
          });
        } else {
          newState.draggedAttachments = [];
        }

        return newState;
      }

    case SET_CHANNEL_LIST_WIDTH:
      {
        var width = payload.width;
        newState.channelListWidth = width;
        return newState;
      }

    case DESTROY_SESSION:
      {
        newState = initialState;
        return newState;
      }

    default:
      return state;
  }
});

var ADD_MESSAGES = 'ADD_MESSAGES';
var SET_MESSAGES = 'SET_MESSAGES';
var ADD_MESSAGE = 'ADD_MESSAGE';
var UPDATE_MESSAGE = 'UPDATE_MESSAGE';
var UPDATE_MESSAGES_STATUS = 'UPDATE_MESSAGES_STATUS';
var GET_MESSAGES = 'GET_MESSAGES';
var SET_SCROLL_TO_MESSAGE = 'SET_SCROLL_TO_MESSAGE';
var SET_MESSAGES_LOADING_STATE = 'SET_MESSAGES_LOADING_STATE';
var LOAD_MORE_MESSAGES = 'LOAD_MORE_MESSAGES';
var SET_MESSAGES_HAS_NEXT = 'SET_MESSAGES_HAS_NEXT';
var SET_HAS_PREV_MESSAGES = 'SET_HAS_PREV_MESSAGES';
var CLEAR_MESSAGES = 'CLEAR_MESSAGES';
var SEND_MESSAGE = 'SEND_MESSAGE';
var SEND_TEXT_MESSAGE = 'SEND_TEXT_MESSAGE';
var FORWARD_MESSAGE = 'FORWARD_MESSAGE';
var EDIT_MESSAGE = 'EDIT_MESSAGE';
var SET_MESSAGE_TO_EDIT = 'SET_MESSAGE_TO_EDIT';
var SET_MESSAGE_FOR_REPLY = 'SET_MESSAGE_FOR_REPLY';
var DELETE_MESSAGE = 'DELETE_MESSAGE';
var DELETE_MESSAGE_FROM_LIST = 'DELETE_MESSAGE_FROM_LIST';
var RESEND_MESSAGE = 'RESEND_MESSAGE';
var UPLOAD_ATTACHMENT_COMPILATION = 'UPLOAD_ATTACHMENT_COMPILATION';
var GET_MESSAGES_ATTACHMENTS = 'GET_MESSAGES_ATTACHMENTS';
var SET_ATTACHMENTS = 'SET_ATTACHMENTS';
var SET_ATTACHMENTS_FOR_POPUP = 'SET_ATTACHMENTS_FOR_POPUP';
var EMPTY_CHANNEL_ATTACHMENTS = 'EMPTY_CHANNEL_ATTACHMENTS';
var LOAD_MORE_MESSAGES_ATTACHMENTS = 'LOAD_MORE_MESSAGES_ATTACHMENTS';
var ADD_ATTACHMENTS = 'ADD_ATTACHMENTS';
var ADD_ATTACHMENTS_FOR_POPUP = 'ADD_ATTACHMENTS_FOR_POPUP';
var SET_ATTACHMENTS_COMPLETE = 'SET_ATTACHMENTS_COMPLETE';
var SET_ATTACHMENTS_COMPLETE_FOR_POPUP = 'SET_ATTACHMENTS_COMPLETE_FOR_POPUP';
var PAUSE_ATTACHMENT_UPLOADING = 'PAUSE_ATTACHMENT_UPLOADING';
var RESUME_ATTACHMENT_UPLOADING = 'RESUME_ATTACHMENT_UPLOADING';
var SET_SEND_MESSAGE_INPUT_HEIGHT = 'SET_SEND_MESSAGE_INPUT_HEIGHT';
var ADD_REACTION_TO_MESSAGE = 'ADD_REACTION_TO_MESSAGE';
var DELETE_REACTION_FROM_MESSAGE = 'DELETE_REACTION_FROM_MESSAGE';
var ADD_REACTION = 'ADD_REACTION';
var DELETE_REACTION = 'DELETE_REACTION';
var SET_SCROLL_TO_NEW_MESSAGE = 'SET_SCROLL_TO_NEW_MESSAGE';
var SET_SHOW_SCROLL_TO_NEW_MESSAGE_BUTTON = 'SET_SHOW_SCROLL_TO_NEW_MESSAGE_BUTTON';
var queryDirection = {
  PREV: 'prev',
  NEXT: 'next',
  NEAR: 'near'
};

var _path;

function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1.apply(this, arguments);
}

function SvgTicksRead(props) {
  return /*#__PURE__*/createElement("svg", _extends$1({
    width: 16,
    height: 16,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path || (_path = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10.983 3.748a.842.842 0 010 1.19l-6.737 6.737a.842.842 0 01-1.19 0L.245 8.867a.842.842 0 111.192-1.191L3.65 9.889l6.141-6.141a.842.842 0 011.191 0zM15.753 3.748a.842.842 0 010 1.19l-6.736 6.737a.842.842 0 01-1.191-1.19l6.736-6.737a.842.842 0 011.191 0z",
    fill: "currentColor"
  })));
}

var _path$1;

function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$2.apply(this, arguments);
}

function SvgTicksDelivered(props) {
  return /*#__PURE__*/createElement("svg", _extends$2({
    width: 16,
    height: 16,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$1 || (_path$1 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10.983 3.748a.842.842 0 010 1.19l-6.737 6.737a.842.842 0 01-1.19 0L.245 8.867a.842.842 0 111.192-1.191L3.65 9.889l6.141-6.141a.842.842 0 011.191 0zM15.753 3.748a.842.842 0 010 1.19l-6.736 6.737a.842.842 0 01-1.191-1.19l6.736-6.737a.842.842 0 011.191 0z",
    fill: "CurrentColor"
  })));
}

var _path$2;

function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$3.apply(this, arguments);
}

function SvgTicksSent(props) {
  return /*#__PURE__*/createElement("svg", _extends$3({
    width: 16,
    height: 16,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$2 || (_path$2 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M13.65 4.234a.772.772 0 010 1.132l-6.737 6.4a.874.874 0 01-1.19 0l-2.81-2.669a.772.772 0 010-1.13.874.874 0 011.191 0l2.214 2.102 6.14-5.835a.874.874 0 011.192 0z",
    fill: "CurrentColor"
  })));
}

var _path$3;

function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$4.apply(this, arguments);
}

function SvgPendingIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$4({
    width: 16,
    height: 16,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$3 || (_path$3 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M8 3.734a4.267 4.267 0 100 8.533 4.267 4.267 0 000-8.533zM2.667 8a5.333 5.333 0 1110.666 0A5.333 5.333 0 012.667 8zM8 4.667c.295 0 .533.239.533.533v2.267H10.8a.533.533 0 010 1.067H8A.533.533 0 017.467 8V5.2c0-.294.239-.533.533-.533z",
    fill: "CurrentColor"
  })));
}

var colors = {
  white: '#ffffff',
  black1: '#383B51',
  blue1: '#172268',
  blue2: '#438CED',
  blue3: '#63afff',
  blue4: '#1F223C',
  blue5: '#172268',
  blue6: '#18273A',
  blue7: '#383B51',
  blue8: '#9AABFB',
  blue9: '#2d44bf',
  blue10: '#060A26',
  gray0: '#F3F5F8',
  gray1: '#EDEDED',
  gray2: '#ecedf0',
  gray3: '#B2B6BE',
  gray4: '#818C99',
  gray5: '#F0F2F5',
  gray6: '#17191C',
  gray7: '#898B99',
  gray8: '#3A3C3E',
  gray9: '#757D8B',
  pink1: '#ff3e74',
  purple1: '#9f35e7',
  cobalt1: '#2F81FF',
  primary: '#2F81FF',
  red1: '#FA4C56',
  red2: '#d7596c',
  red3: '#F94C56',
  yellow1: '#FCD36E',
  purple: '#7A6EF6',
  defaultAvatarBackground: '#D0D8E3',
  deleteUserIconBackground: '#D0D8E3'
};
var size = {
  mobileS: '320px',
  mobileM: '375px',
  mobileL: '425px',
  tablet: '768px',
  laptop: '1024px',
  laptopL: '1440px',
  max: '2560px'
};
var device = {
  mobileS: "(min-width: " + size.mobileS + ")",
  mobileM: "(min-width: " + size.mobileM + ")",
  mobileL: "(min-width: " + size.mobileL + ")",
  tablet: "screen and (max-width: " + size.tablet + ")",
  laptop: "screen and (max-width: " + size.laptop + ")",
  laptopL: "screen and (min-width: " + size.laptopL + ")",
  max: "screen and (max-width: " + size.max + ")"
};
var customColors = {};
var setCustomColors = function setCustomColors(colorsKeyValues) {
  var colorsKeys = Object.keys(colorsKeyValues);
  colorsKeys.map(function (key) {
    customColors[key] = colorsKeyValues[key];
  });
};

var _avatarColors = ['#FF3E74', '#4F6AFF', '#FBB019', '#00CC99', '#9F35E7', '#63AFFF'];
var setAvatarColor = function setAvatarColor(colors) {
  _avatarColors = colors;
};
var getAvatarColors = function getAvatarColors() {
  return _avatarColors;
};

var _path$4;

function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$5.apply(this, arguments);
}

function SvgClose(props) {
  return /*#__PURE__*/createElement("svg", _extends$5({
    width: 12,
    height: 12,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$4 || (_path$4 = /*#__PURE__*/createElement("path", {
    d: "M11 1L1 11M1 1l10 10",
    stroke: "CurrentColor",
    strokeWidth: 1.6,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })));
}

var _path$5;

function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$6.apply(this, arguments);
}

function SvgSearch(props) {
  return /*#__PURE__*/createElement("svg", _extends$6({
    width: 14,
    height: 14,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$5 || (_path$5 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M13.743 12.574L9.91 8.74a5.425 5.425 0 001.05-3.232A5.531 5.531 0 005.46 0 5.436 5.436 0 000 5.468a5.532 5.532 0 005.5 5.508 5.409 5.409 0 003.242-1.061l.004-.003 3.83 3.831a.827.827 0 101.167-1.169zM5.496 9.878a4.426 4.426 0 01-4.4-4.406 4.35 4.35 0 014.368-4.374 4.425 4.425 0 014.4 4.406 4.35 4.35 0 01-4.368 4.374z",
    fill: "#9294A1"
  })));
}

var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33, _templateObject34, _templateObject35, _templateObject36, _templateObject37, _templateObject38, _templateObject39, _templateObject40, _templateObject41, _templateObject42, _templateObject43, _templateObject44;
function md5(inputString) {
  var hc = '0123456789abcdef';

  function rh(n) {
    var j;
    var s = '';

    for (j = 0; j <= 3; j++) {
      s += hc.charAt(n >> j * 8 + 4 & 0x0f) + hc.charAt(n >> j * 8 & 0x0f);
    }

    return s;
  }

  function ad(x, y) {
    var l = (x & 0xffff) + (y & 0xffff);
    var m = (x >> 16) + (y >> 16) + (l >> 16);
    return m << 16 | l & 0xffff;
  }

  function rl(n, c) {
    return n << c | n >>> 32 - c;
  }

  function cm(q, a, b, x, s, t) {
    return ad(rl(ad(ad(a, q), ad(x, t)), s), b);
  }

  function ff(a, b, c, d, x, s, t) {
    return cm(b & c | ~b & d, a, b, x, s, t);
  }

  function gg(a, b, c, d, x, s, t) {
    return cm(b & d | c & ~d, a, b, x, s, t);
  }

  function hh(a, b, c, d, x, s, t) {
    return cm(b ^ c ^ d, a, b, x, s, t);
  }

  function ii(a, b, c, d, x, s, t) {
    return cm(c ^ (b | ~d), a, b, x, s, t);
  }

  function sb(x) {
    var i;
    var nblk = (x.length + 8 >> 6) + 1;
    var blks = new Array(nblk * 16);

    for (i = 0; i < nblk * 16; i++) {
      blks[i] = 0;
    }

    for (i = 0; i < x.length; i++) {
      blks[i >> 2] |= x.charCodeAt(i) << i % 4 * 8;
    }

    blks[i >> 2] |= 0x80 << i % 4 * 8;
    blks[nblk * 16 - 2] = x.length * 8;
    return blks;
  }

  var i;
  var x = sb(inputString);
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  var olda;
  var oldb;
  var oldc;
  var oldd;

  for (i = 0; i < x.length; i += 16) {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;
    a = ff(a, b, c, d, x[i + 0], 7, -680876936);
    d = ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = ff(c, d, a, b, x[i + 10], 17, -42063);
    b = ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = gg(b, c, d, a, x[i + 0], 20, -373897302);
    a = gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = hh(a, b, c, d, x[i + 5], 4, -378558);
    d = hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = hh(d, a, b, c, x[i + 0], 11, -358537222);
    c = hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = ii(a, b, c, d, x[i + 0], 6, -198630844);
    d = ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = ad(a, olda);
    b = ad(b, oldb);
    c = ad(c, oldc);
    d = ad(d, oldd);
  }

  return rh(a) + rh(b) + rh(c) + rh(d);
}
var GlobalStyles = createGlobalStyle(_templateObject || (_templateObject = _taggedTemplateLiteralLoose(["\n\n  .rc-mentions {\n    position: relative;\n\n    // ================= Input Area =================\n    > textarea {\n\n      resize: none;\n      //padding: 16px 45px 16px 108px;\n      padding: 16px 45px 16px 80px;\n      width: 100%;\n      display: block;\n      border: none;\n      font: inherit;\n      box-sizing: border-box;\n      border-radius: 6px;\n      font-size: 15px;\n      line-height: 17px;\n\n      &::placeholder {\n        font-size: 15px;\n        color: ", ";\n        opacity: 1;\n      }\n\n      & {\n        border: none;\n        outline: none !important;\n      }\n    }\n\n    & .rc-mentions-measure {\n      position: absolute;\n      left: 0;\n      right: 0;\n      top: 0;\n      bottom: 0;\n      pointer-events: none;\n      // color: rgba(255, 0, 0, 0.3);\n      color: transparent;\n      z-index: -1;\n\n      font-size: inherit;\n      font-size-adjust: inherit;\n      font-style: inherit;\n      font-variant: inherit;\n      font-stretch: inherit;\n      font-weight: inherit;\n      font-family: inherit;\n\n      padding: 0;\n      margin: 0;\n      line-height: inherit;\n      vertical-align: top;\n      overflow: inherit;\n      word-break: inherit;\n      white-space: inherit;\n      word-wrap: break-word;\n      overflow-x: initial;\n      overflow-y: auto;\n      text-align: inherit;\n      letter-spacing: inherit;\n      white-space: inherit;\n      tab-size: inherit;\n      direction: inherit;\n    }\n\n    // ================== Dropdown ==================\n    & .rc-mentions-dropdown {\n      position: absolute;\n\n      & .rc-mentions-menu {\n        list-style: none;\n        margin: 0;\n        padding: 0;\n\n        & .rc-mentions-item {\n          cursor: pointer;\n        }\n      }\n    }\n  }\n\n  // Customize style\n  .rc-mentions-dropdown {\n    width: 300px;\n    height: 237px;\n    overflow-y: auto;\n    background: #FFFFFF;\n    border: 1px solid ", ";\n    box-sizing: border-box;\n    box-shadow: 0px 0px 12px rgba(0, 0, 0, 0.08);\n    border-radius: 6px;\n    & ul {\n      padding: 16px 0;\n      margin: 0;\n      list-style: none;\n    }\n  }\n\n  .mention_menu_item-active {\n    background: #e6f7ff;\n  }\n  /*.mention_menu_item {\n    display: flex;\n    align-items: center;\n    font-size: 15px;\n    padding: 6px 16px;\n    transition: all 0.2s;\n    cursor: pointer;\n\n    &:hover {\n      background-color: ", ";\n    }\n\n    & .dropdown-wrapper {\n      margin-left: auto;\n    }\n\n    & .dropdown-body {\n      bottom: -100px;\n      right: 0;\n    }\n  }*/\n  .rc-mentions-dropdown-menu-item-active {\n    background-color: ", ";\n  }\n\n  .rc-mentions-disabled {\n    opacity: 0.5;\n  }\n\n  .button {\n    display: inline-block;\n    box-sizing: border-box;\n    text-decoration: none;\n    outline: none;\n    cursor: pointer;\n    text-align: center;\n    font-style: normal;\n    border-radius: 4px;\n    font-weight: 500;\n    font-size: 0.875rem;\n    line-height: 1.25rem;\n    padding: 0.375rem 0.75rem;\n    background-color: white;\n    border: 1px solid ", ";\n    margin: 0;\n    user-select: none;\n    //border: none;\n    //transition: all 0.2s;\n    //box-shadow: 0 0 4px rgba(0,0,0,0.1);\n\n    //&:hover, &:focus {\n    //    box-shadow: 0 0 10px -2px rgba(0,0,0,0.25);\n    //}\n\n\n    &.blue {\n      color: ", ";\n      border: 1px solid ", ";\n\n      &.filled {\n        color: white;\n        background-color: ", ";\n      }\n\n      &:hover, &:focus {\n        &:not(.loading).filled {\n          background-color: ", ";\n        }\n      }\n\n      &:disabled {\n        background-color: #D7D8E3;\n        border: 1px solid #D7D8E3;\n        pointer-events: none;\n      }\n    }\n\n    &.blue-dark {\n      color: ", ";\n      border: 1px solid ", ";\n\n      &.filled {\n        color: white;\n        background-color: ", ";\n      }\n\n      &:hover, &:focus {\n        &:not(.loading).filled {\n          background-color: ", ";\n        }\n      }\n    }\n\n    &.green {\n      color: ", ";\n      border: 1px solid ", ";\n\n      &.filled {\n        color: white;\n        background-color: ", ";\n      }\n\n      &:hover, &:focus {\n        &:not(.loading).filled {\n          background-color: ", ";\n        }\n      }\n    }\n\n    &.red {\n      color: ", ";\n      border: 1px solid ", ";\n\n      &.filled {\n        color: white;\n        background-color: ", ";\n      }\n\n      &:hover, &:focus {\n        &:not(.loading).filled {\n          background-color: ", ";\n        }\n      }\n    }\n\n    &.gray {\n      color: black;\n      border: 1px solid ", ";\n\n      &.filled {\n        color: white;\n        background-color: ", ";\n      }\n\n      &:hover, &:focus {\n        &:not(.loading).filled {\n          background-color: ", ";\n        }\n      }\n    }\n\n    @media ", " {\n      font-size: 0.812rem;\n      line-height: 1.25rem;\n      padding: 0.375rem 0.625rem;\n    }\n  }\n\n  @keyframes makeVisible {\n    0% {\n      opacity: 0;\n      visibility: visible;\n    }\n    100% {\n      opacity: 1;\n      visibility: visible;\n    }\n  }\n"])), colors.gray7, colors.gray1, colors.gray0, colors.gray0, colors.gray2, colors.blue1, colors.cobalt1, colors.cobalt1, colors.blue2, colors.blue5, colors.blue5, colors.blue5, colors.blue4, colors.primary, colors.primary, colors.primary, colors.primary, colors.red1, colors.red1, colors.red1, colors.red2, colors.gray2, colors.gray2, colors.gray2, device.tablet);
function generateAvatarColor(itemName) {
  var avatarColors = getAvatarColors();

  if (itemName && itemName !== '') {
    var hash = md5(itemName).toString().padStart(32, '0').slice(-6);
    var hashInt = parseInt(hash, 16);
    var colorIndex = hashInt % avatarColors.length;
    return avatarColors[colorIndex];
  }

  return null;
}
var DropdownOptionsUl = styled.ul(_templateObject2 || (_templateObject2 = _taggedTemplateLiteralLoose(["\n  list-style: none;\n  margin: 0;\n  padding: 0;\n"])));
var DropdownOptionLi = styled.li(_templateObject3 || (_templateObject3 = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  font-size: 14px;\n  line-height: 20px;\n  color: ", ";\n  margin: ", ";\n  padding: 6px 6px 6px 16px;\n\n  &:hover {\n    background: ", ";\n  }\n\n  & > svg {\n    width: ", ";\n    min-width: ", ";\n    height: ", ";\n    color: ", ";\n    margin-right: 10px;\n  }\n"])), function (props) {
  return props.textColor || colors.blue6;
}, function (props) {
  return props.margin;
}, function (props) {
  return props.hoverBackground || colors.gray0;
}, function (props) {
  return props.iconWidth;
}, function (props) {
  return props.iconWidth;
}, function (props) {
  return props.iconWidth;
}, function (props) {
  return props.iconColor;
});
var CustomSelect = styled.div(_templateObject4 || (_templateObject4 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  height: 40px;\n  min-height: 40px;\n  width: 100%;\n  min-width: ", ";\n  max-width: ", ";\n  background: #ffffff;\n  border: ", ";\n  box-sizing: border-box;\n  border-radius: 4px;\n  font-style: normal;\n  font-weight: normal;\n  font-size: 14px;\n  line-height: 16px;\n  color: ", ";\n  margin-top: ", ";\n\n  ::placeholder {\n    color: ", ";\n  }\n\n  &:disabled {\n    background-color: ", ";\n  }\n\n  .dropdown-wrapper {\n    width: 100%;\n  }\n\n  .dropdown-body {\n    width: 100%;\n  }\n\n  .dropdown-trigger {\n    & .default-selection {\n      color: ", ";\n    }\n\n    //width: calc(100% - 20px);\n\n    &::after {\n      border-color: black;\n    }\n  }\n"])), function (props) {
  return props.minWidth;
}, function (props) {
  return props.maxWidth;
}, function (props) {
  return props.isError ? "1px solid " + colors.red1 : "1px solid " + colors.gray2;
}, colors.blue7, function (props) {
  return props.marginTop;
}, colors.gray7, colors.gray2, colors.gray7);
var CustomSelectTrigger = styled.span(_templateObject5 || (_templateObject5 = _taggedTemplateLiteralLoose(["\n  display: block;\n  width: calc(100% - 22px);\n  padding: 8px 10px 8px 15px;\n  text-align: left;\n  font-style: normal;\n  font-weight: normal;\n  font-size: 14px;\n  line-height: 16px;\n  color: ", ";\n  text-transform: capitalize;\n"])), colors.blue7);
var Label = styled.label(_templateObject6 || (_templateObject6 = _taggedTemplateLiteralLoose(["\n  display: inline-block;\n  font-style: normal;\n  font-weight: 500;\n  font-size: 13px;\n  line-height: 20px;\n  margin-top: 20px;\n  margin-bottom: 4px;\n  color: ", ";\n"])), colors.gray6);
var UploadFile = styled.input(_templateObject7 || (_templateObject7 = _taggedTemplateLiteralLoose(["\n  display: none;\n"])));
var UploadFileLabel = styled.label(_templateObject8 || (_templateObject8 = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n  width: 100%;\n  display: block;\n"])));
var InputErrorMessage = styled.p(_templateObject9 || (_templateObject9 = _taggedTemplateLiteralLoose(["\n  font-size: 12px;\n  color: ", ";\n  margin: 4px 0 0;\n"])), colors.red1);
var CustomInput = styled.input(_templateObject10 || (_templateObject10 = _taggedTemplateLiteralLoose(["\n  height: 40px;\n  width: 100%;\n  background: #ffffff;\n  border: ", ";\n  box-sizing: border-box;\n  border-radius: 8px;\n  padding: 11px 14px;\n  font-family: Inter, sans-serif;\n  font-style: normal;\n  font-weight: normal;\n  font-size: 15px;\n  line-height: 20px;\n  opacity: 1;\n  outline: none;\n\n  &:focus {\n    border: 1px solid ", ";\n    outline: 2px solid ", ";\n  }\n  &:disabled {\n    background-color: ", ";\n    opacity: 1;\n    color: #383b51;\n  }\n  &::placeholder {\n    opacity: 1;\n    color: ", ";\n  }\n"])), function (props) {
  return props.error ? "1px solid " + colors.red1 : '1px solid #ededed';
}, function (props) {
  return props.error ? "1px solid " + colors.red1 : colors.primary;
}, function (props) {
  return props.error ? "1px solid " + colors.red2 : '#ebf7f1';
}, colors.gray0, colors.gray7);
var FilterField = styled.div(_templateObject11 || (_templateObject11 = _taggedTemplateLiteralLoose(["\n  border: 1px solid #d7d8e3;\n  border-radius: 4px;\n  background-color: transparent;\n  margin-left: 12px;\n\n  .dropdown-trigger::after {\n    border-color: black;\n  }\n"])));
var FilterFieldSpan = styled.span(_templateObject12 || (_templateObject12 = _taggedTemplateLiteralLoose(["\n  display: block;\n  width: 100px;\n  padding: 8px 0 8px 8px;\n  text-align: left;\n  font-size: 0.875rem;\n  line-height: 1rem;\n"])));
var CustomRadioWrapper = styled.div(_templateObject13 || (_templateObject13 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  margin-top: 16px;\n  label {\n    font-size: 14px;\n    line-height: 16px;\n    color: ", ";\n  }\n"])), colors.blue7);
var CustomRadio = styled.input(_templateObject14 || (_templateObject14 = _taggedTemplateLiteralLoose(["\n  height: 16px;\n  width: 16px;\n  margin: 0 10px 0 0;\n  cursor: pointer;\n"])));
var Row = styled.div(_templateObject15 || (_templateObject15 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  flex-direction: row;\n  margin: ", ";\n  margin-top: ", ";\n  margin-bottom: ", ";\n  margin-right: ", ";\n  margin-left: ", ";\n  align-items: ", ";\n  justify-content: ", ";\n  width: ", ";\n  height: ", ";\n  min-height: ", ";\n  padding: ", ";\n  padding-left: ", ";\n  padding-right: ", ";\n  flex-wrap: ", ";\n"])), function (props) {
  return props.margin;
}, function (props) {
  return props.marginTop;
}, function (props) {
  return props.marginBottom;
}, function (props) {
  return props.marginRight;
}, function (props) {
  return props.marginLeft;
}, function (props) {
  return props.align;
}, function (props) {
  return props.justify;
}, function (props) {
  return props.width;
}, function (props) {
  return props.height;
}, function (props) {
  return props.minHeight;
}, function (props) {
  return props.padding;
}, function (props) {
  return props.paddingLeft;
}, function (props) {
  return props.paddingRight;
}, function (props) {
  return props.flexWrap;
});
var Button = styled.button(_templateObject16 || (_templateObject16 = _taggedTemplateLiteralLoose(["\n  display: inline-block;\n  box-sizing: border-box;\n  text-decoration: none;\n  outline: none;\n  cursor: ", ";\n  text-align: center;\n  font-style: normal;\n  border-radius: ", ";\n  font-weight: 500;\n  font-size: 15px;\n  line-height: 20px;\n  padding: 8px 16px;\n  background-color: ", ";\n  color: ", ";\n  border: 1px solid ", ";\n  margin: ", ";\n  user-select: none;\n  transition: opacity 0.1s;\n  opacity: ", ";\n  &:hover,\n  &:focus {\n    opacity: ", ";\n  }\n"])), function (props) {
  return !props.disabled && 'pointer';
}, function (props) {
  return props.borderRadius || '4px';
}, function (props) {
  return props.backgroundColor || colors.white;
}, function (props) {
  return props.color || (props.backgroundColor ? colors.white : colors.gray6);
}, function (props) {
  return props.backgroundColor || colors.gray2;
}, function (props) {
  return props.margin || '0';
}, function (props) {
  return props.disabled ? 0.5 : 1;
}, function (props) {
  return props.disabled ? 0.5 : 0.8;
});
var PopupName = styled.h3(_templateObject17 || (_templateObject17 = _taggedTemplateLiteralLoose(["\n  font-style: normal;\n  font-weight: 500;\n  font-size: 20px;\n  line-height: 23px;\n  color: ", ";\n  margin: 0;\n  margin-top: ", ";\n  margin-bottom: ", ";\n  word-break: break-word;\n\n  ", "\n"])), colors.gray6, function (props) {
  return props.marginTop;
}, function (props) {
  return props.marginBottom;
}, function (props) {
  if (props.isDelete) {
    return "\n            max-width: calc(100% - 20px);\n            white-space: nowrap;\n            text-overflow: ellipsis;\n            overflow: hidden;\n        ";
  }

  return '';
});
var PopupContainer = styled.div(_templateObject18 || (_templateObject18 = _taggedTemplateLiteralLoose(["\n  direction: initial;\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 200;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background: rgba(0, 0, 0, 0.4);\n"])));
var ButtonBlock = styled.div(_templateObject19 || (_templateObject19 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  margin-top: ", ";\n  padding-right: ", ";\n  justify-content: ", ";\n  height: ", ";\n  min-height: ", ";\n  background-color: ", ";\n\n  a {\n    width: 88px;\n    height: 40px;\n    margin: 0 4px;\n    font-size: 15px;\n    font-weight: 500;\n  }\n"])), function (props) {
  return props.marginTop || '10px';
}, function (props) {
  return props.paddingRight || '0px';
}, function (props) {
  return props.justify || 'flex-end';
}, function (props) {
  return props.height;
}, function (props) {
  return props.height;
}, function (props) {
  return props.backgroundColor;
});
var Popup = styled.div(_templateObject20 || (_templateObject20 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  min-height: 150px;\n  min-width: ", ";\n  max-width: ", ";\n  max-height: ", ";\n  width: ", ";\n  height: ", ";\n  display: ", ";\n  flex-direction: column;\n  padding: ", ";\n  background: #ffffff;\n  box-shadow: 4px 4px 30px rgba(0, 0, 0, 0.06);\n  border-radius: 8px;\n  box-sizing: border-box;\n\n  ", ";\n"])), function (props) {
  return props.minWidth || '400px';
}, function (props) {
  return props.maxWidth || '600px';
}, function (props) {
  return props.maxHeight || '650px';
}, function (props) {
  return props.width || 'unset';
}, function (props) {
  return props.height || 'unset';
}, function (props) {
  return props.display || 'flex';
}, function (props) {
  return props.padding ? props.padding : '22px 24px';
}, function (props) {
  return props.isLoading && "\n        user-select: none;\n\n        & > * {\n           pointer-events: none;\n           user-select: none;\n        }\n\n         " + ButtonBlock + " {\n          a, button {\n            pointer-events: none;\n            user-select: none;\n            opacity: 0.7;\n          }\n        }\n    ";
});
var PopupBody = styled.div(_templateObject21 || (_templateObject21 = _taggedTemplateLiteralLoose(["\n  padding: ", ";\n  margin-bottom: 8px;\n\n  height: ", ";\n"])), function (props) {
  return props.padding + "px";
}, function (props) {
  return props.withFooter ? "calc(100% - (54px + " + props.padding + "px))" : 'calc(100% - 54px)';
});
var PopupDescription = styled.span(_templateObject22 || (_templateObject22 = _taggedTemplateLiteralLoose(["\n  font-style: normal;\n  font-weight: normal;\n  font-size: 15px;\n  line-height: 22px;\n  color: ", ";\n  cursor: default;\n  white-space: pre-line;\n  margin-top: ", ";\n  margin-bottom: ", ";\n  word-break: break-word;\n\n  .highlight {\n    text-decoration: underline;\n    font-weight: 500;\n    color: ", ";\n  }\n"])), colors.gray8, function (props) {
  return props.marginTop || '10px';
}, function (props) {
  return props.marginBottom || '10px';
}, colors.blue1);
var BoltText = styled.span(_templateObject23 || (_templateObject23 = _taggedTemplateLiteralLoose(["\n  font-weight: 500;\n"])));
var PopupFooter = styled(ButtonBlock)(_templateObject24 || (_templateObject24 = _taggedTemplateLiteralLoose(["\n  margin-top: ", ";\n  padding: 8px 16px;\n  border-radius: 0 0 8px 8px;\n"])), function (props) {
  return props.marginTop || '0';
});
var SectionHeader = styled.h4(_templateObject25 || (_templateObject25 = _taggedTemplateLiteralLoose(["\n  font-weight: 500;\n  font-size: 15px;\n  line-height: 20px;\n  color: ", ";\n  margin: ", ";\n"])), colors.gray6, function (props) {
  return props.margin || 0;
});
var ItemNote = styled.div(_templateObject26 || (_templateObject26 = _taggedTemplateLiteralLoose(["\n  display: none;\n  position: absolute;\n  z-index: 301;\n  padding: 10px 12px;\n  background-color: ", ";\n  border-radius: 4px;\n  font-size: 0.75rem;\n  white-space: nowrap;\n  font-weight: 600;\n  color: white;\n  pointer-events: none;\n  user-select: none;\n\n  &::before {\n    content: '';\n    position: absolute;\n    z-index: -1;\n    background-color: ", ";\n    border-radius: 1px;\n    width: 14px;\n    height: 14px;\n\n    ", " ", "\n  }\n\n  ", " ", " ", " ", "\n"])), colors.blue6, colors.blue6, function (props) {
  return props.direction === 'right' && "\n            left: -5px;\n            top: 50%;\n            transform: translateY(-50%) rotate(45deg);\n        ";
}, function (props) {
  return props.direction === 'top' && "\n            bottom: -5px;\n            left: 50%;\n            transform: translateX(-50%) rotate(45deg);\n        ";
}, function (props) {
  return props.visible && "\n       display: block;\n    ";
}, function (props) {
  return props.direction === 'right' && "\n        top: 50%;\n        left: calc(100% + 15px);\n        transform: translateY(-50%);\n    ";
}, function (props) {
  return props.direction === 'top' && "\n        bottom: calc(100% + 15px);\n        left: 50%;\n        transform: translateX(-50%);\n    ";
}, function (props) {
  return props.disabled && "\n        color: " + colors.gray4 + ";\n    ";
});
var CustomSwitcher = styled.div(_templateObject27 || (_templateObject27 = _taggedTemplateLiteralLoose(["\n  display: inline-block;\n  position: relative;\n"])));
var SwitcherLabel = styled.label(_templateObject28 || (_templateObject28 = _taggedTemplateLiteralLoose(["\n  width: 48px;\n  height: 28px;\n  background: rgb(226, 226, 226);\n  display: inline-block;\n  border-radius: 50px;\n  position: relative;\n  transition: all 0.3s ease;\n  transform-origin: 20% center;\n  border: 3px solid #fff;\n  cursor: pointer;\n\n  &:before {\n    content: '';\n    position: absolute;\n    display: block;\n    transition: all 0.2s ease;\n    width: 24px;\n    height: 24px;\n    top: 2px;\n    left: 2px;\n    border-radius: 20px;\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.251475), 0 2px 6px rgba(0, 0, 0, 0.404256);\n    background: #fff;\n  }\n"])));
var UploadAvatarButton = styled.button(_templateObject29 || (_templateObject29 = _taggedTemplateLiteralLoose(["\n  display: block;\n  height: 32px;\n  margin-top: 8px;\n  border: none;\n  color: #fff;\n  font-weight: 500;\n  font-size: 14px;\n  background: ", ";\n  border-radius: 4px;\n  outline: none !important;\n  cursor: pointer;\n  padding: 7px 12px;\n  line-height: 10px;\n"])), colors.blue5);
var UploadAvatarHandler = styled.div(_templateObject30 || (_templateObject30 = _taggedTemplateLiteralLoose(["\n  margin-left: 18px;\n  font-size: 13px;\n  color: ", ";\n"])), colors.blue7);
var MentionedUser = styled.span(_templateObject31 || (_templateObject31 = _taggedTemplateLiteralLoose(["\n  color: #2f81ff;\n"])));
var MessageOwner = styled.h3(_templateObject32 || (_templateObject32 = _taggedTemplateLiteralLoose(["\n  margin: 0 12px 2px 0;\n  white-space: nowrap;\n  padding: ", ";\n  color: ", ";\n  margin-left: ", ";\n  font-weight: 500;\n  font-size: ", ";\n"])), function (props) {
  return props.withPadding && (props.messageBody ? '8px 0 0 12px' : props.isForwarded ? '8px 0 2px 12px' : '8px 0 4px 12px');
}, function (props) {
  return props.color || colors.primary;
}, function (props) {
  return props.rtlDirection && 'auto';
}, function (props) {
  return props.fontSize || '15px';
});
var MessageText = styled.pre(_templateObject33 || (_templateObject33 = _taggedTemplateLiteralLoose(["\n  display: flow-root;\n  position: relative;\n  font-family: ", ";\n  margin: 0;\n  padding: ", ";\n  padding-bottom: ", ";\n  font-size: ", ";\n  font-weight: 400;\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  //white-space: normal;\n  line-height: ", ";\n  letter-spacing: -0.2px;\n  color: ", ";\n  user-select: text;\n\n  ", "\n\n  &::after {\n    content: '';\n    position: absolute;\n    left: 0;\n    bottom: 0;\n    height: 1px;\n  }\n\n  & > a {\n    color: ", ";\n  }\n"])), function (props) {
  return props.fontFamily || 'Inter, sans-serif';
}, function (props) {
  return props.withAttachment && (props.showMessageSenderName ? '0 12px 10px' : props.isForwarded ? '4px 12px 10px' : '8px 12px 10px');
}, function (props) {
  return props.withAttachment && !props.withMediaAttachment && '2px';
}, function (props) {
  return props.fontSize || '15px';
}, function (props) {
  return props.lineHeight || '20px';
}, colors.gray6, function (props) {
  return props.isRepliedMessage && "\n      display: -webkit-box;\n      -webkit-line-clamp: 1;\n      -webkit-box-orient: vertical;\n      overflow: hidden;\n      text-overflow: ellipsis;\n  ";
}, colors.blue2);
var ReplyMessageText = styled.span(_templateObject34 || (_templateObject34 = _taggedTemplateLiteralLoose(["\n  display: -webkit-box;\n  position: relative;\n  margin: 0;\n  padding: ", ";\n  font-size: ", ";\n  font-weight: 400;\n  line-height: ", ";\n  letter-spacing: -0.2px;\n  color: ", ";\n  user-select: text;\n  -webkit-line-clamp: 1;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n  text-overflow: ellipsis;\n"])), function (props) {
  return props.withAttachment && props.showMessageSenderName ? '0 12px 10px' : props.withAttachment ? '8px 12px 10px' : '';
}, function (props) {
  return props.fontSize || '15px';
}, function (props) {
  return props.lineHeight || '20px';
}, colors.gray6);
var CloseIcon = styled(SvgClose)(_templateObject35 || (_templateObject35 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  top: 13px;\n  right: 13px;\n  cursor: pointer;\n  padding: 15px;\n"])));
var ClearTypedText = styled(CloseIcon)(_templateObject36 || (_templateObject36 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  top: 8px;\n  right: 10px;\n  cursor: pointer;\n  padding: 4px;\n"])));
var StyledSearchSvg = styled(SvgSearch)(_templateObject37 || (_templateObject37 = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n  position: absolute;\n  top: 12px;\n  left: 14px;\n"])));
var SubTitle = styled.span(_templateObject38 || (_templateObject38 = _taggedTemplateLiteralLoose(["\n  font-size: 13px;\n  line-height: 16px;\n  letter-spacing: -0.078px;\n  color: ", ";\n"])), colors.gray9);
var AttachmentIconCont = styled.span(_templateObject39 || (_templateObject39 = _taggedTemplateLiteralLoose(["\n  display: inline-flex;\n"])));
var UploadingIcon = styled.span(_templateObject40 || (_templateObject40 = _taggedTemplateLiteralLoose(["\n  display: inline-block;\n  border: ", " solid rgba(255, 255, 255, 0.8);\n  border-top: ", " solid rgba(0, 0, 0, 0);\n  border-radius: 50%;\n  width: ", ";\n  height: ", ";\n\n  animation: preloader 1.5s linear infinite;\n\n  @keyframes preloader {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n"])), function (props) {
  return props.fileAttachment ? '2px' : '3px';
}, function (props) {
  return props.fileAttachment ? '2px' : '3px';
}, function (props) {
  return props.fileAttachment ? '26px' : props.isRepliedMessage ? '28px' : '40px';
}, function (props) {
  return props.fileAttachment ? '26px' : props.isRepliedMessage ? '28px' : '40px';
});
var TextInOneLine = styled.span(_templateObject41 || (_templateObject41 = _taggedTemplateLiteralLoose(["\n  display: -webkit-box;\n  -webkit-line-clamp: 1;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n  text-overflow: ellipsis;\n"])));
var UploadPercent = styled.span(_templateObject42 || (_templateObject42 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  color: #fff;\n  width: ", ";\n  height: ", ";\n  background-color: rgba(0,0,0,0.4);\n  border-radius: ", ";\n}\n  ", "\n"])), function (props) {
  return props.fileAttachment || props.isRepliedMessage ? '40px' : '56px';
}, function (props) {
  return props.fileAttachment || props.isRepliedMessage ? '40px' : '56px';
}, function (props) {
  return props.borderRadius ? props.borderRadius : props.fileAttachment ? '8px' : props.isRepliedMessage ? '4px' : ' 50%';
}, function (props) {
  return (props.fileAttachment || props.isRepliedMessage) && "& > svg {\n    width: 15px;\n    height: 15px;\n  }";
});
var UploadProgress = styled.div(_templateObject43 || (_templateObject43 = _taggedTemplateLiteralLoose(["\n  position: ", ";\n  top: ", ";\n  left: ", ";\n  width: ", ";\n  height: ", ";\n  min-width: ", ";\n  min-height: ", ";\n  display: flex;\n  //display: none;\n  align-items: center;\n  justify-content: center;\n  //border-radius: ", ";\n  background-image: url(", ");\n  background-size: cover;\n  border-radius: ", ";\n  z-index: 5;\n  cursor: pointer;\n  border: ", ";\n  box-sizing: border-box;\n  ", "\n  ", "\n  ", "\n"])), function (props) {
  return !props.positionStatic && 'absolute';
}, function (props) {
  return props.fileAttachment ? '8px' : '0';
}, function (props) {
  return props.fileAttachment ? '12px' : '0';
}, function (props) {
  return props.fileAttachment || props.isRepliedMessage ? '40px' : props.width ? props.width + "px" : '100%';
}, function (props) {
  return props.fileAttachment || props.isRepliedMessage ? '40px' : props.height ? props.height + "px" : '100%';
}, function (props) {
  return !props.fileAttachment && !props.isRepliedMessage ? props.imageMinWidth || '130px' : null;
}, function (props) {
  return !props.fileAttachment && !props.isRepliedMessage && '90px';
}, function (props) {
  return props.fileAttachment ? '8px' : props.isRepliedMessage ? '4px' : ' 50%';
}, function (props) {
  return 'data:image/jpeg;base64,' + props.backgroundImage;
}, function (props) {
  return props.fileAttachment ? '8px' : props.borderRadius ? props.borderRadius : props.isRepliedMessage ? '4px' : '8px';
}, function (props) {
  return props.isRepliedMessage ? '0.5px solid rgba(0, 0, 0, 0.1)' : props.withBorder && "2px solid " + props.backgroundColor;
}, function (props) {
  return props.isFailedAttachment && 'background-color: rgba(237, 77, 96, 0.1);';
}, function (props) {
  return props.whiteBackground && "\n    background-color: rgba(255,255,255,0.3);\n    border: 1px solid  " + colors.gray1 + ";\n\n    " + UploadingIcon + " {\n        border: 4px solid rgba(238,238,238,0.8);\n        border-top: 4px solid " + colors.cobalt1 + ";\n    }\n  ";
}, function (props) {
  return props.isDetailsView && "\n    width: 100%;\n    height: 100%;\n    min-width: inherit;\n  ";
});
var AttachmentPreviewTitle = styled.span(_templateObject44 || (_templateObject44 = _taggedTemplateLiteralLoose(["\n  display: block;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  max-width: calc(100% - 20px);\n  font-style: normal;\n  font-weight: normal;\n  font-size: 15px;\n  line-height: 20px;\n  height: 20px;\n  color: ", ";\n"])), function (props) {
  return props.color || colors.blue10;
});

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var moment = createCommonjsModule(function (module, exports) {
(function (global, factory) {
     module.exports = factory() ;
}(commonjsGlobal, (function () {
    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return (
            input instanceof Array ||
            Object.prototype.toString.call(input) === '[object Array]'
        );
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return (
            input != null &&
            Object.prototype.toString.call(input) === '[object Object]'
        );
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return (
            typeof input === 'number' ||
            Object.prototype.toString.call(input) === '[object Number]'
        );
    }

    function isDate(input) {
        return (
            input instanceof Date ||
            Object.prototype.toString.call(input) === '[object Date]'
        );
    }

    function map(arr, fn) {
        var res = [],
            i,
            arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;

            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
                    return i != null;
                }),
                isNowValid =
                    !isNaN(m._d.getTime()) &&
                    flags.overflow < 0 &&
                    !flags.empty &&
                    !flags.invalidEra &&
                    !flags.invalidMonth &&
                    !flags.invalidWeekday &&
                    !flags.weekdayMismatch &&
                    !flags.nullInput &&
                    !flags.invalidFormat &&
                    !flags.userInvalidated &&
                    (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;

    function copyConfig(to, from) {
        var i,
            prop,
            val,
            momentPropertiesLen = momentProperties.length;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return (
            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
        );
    }

    function warn(msg) {
        if (
            hooks.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' &&
            console.warn
        ) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key,
                    argLen = arguments.length;
                for (i = 0; i < argLen; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(
                    msg +
                        '\nArguments: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                );
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }

    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
        );
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
            ) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L',
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (
            (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }

    var formattingTokens =
            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                    func.apply(this, arguments),
                    token
                );
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '',
                i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i])
                    ? array[i].call(mom, format)
                    : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] =
            formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (
                    tok === 'MMMM' ||
                    tok === 'MM' ||
                    tok === 'DD' ||
                    tok === 'dddd'
                ) {
                    return tok.slice(1);
                }
                return tok;
            })
            .join('');

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years',
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string'
            ? aliases[units] || aliases[units.toLowerCase()]
            : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get(mom, unit) {
        return mom.isValid()
            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
            : NaN;
    }

    function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (
                unit === 'FullYear' &&
                isLeapYear(mom.year()) &&
                mom.month() === 1 &&
                mom.date() === 29
            ) {
                value = toInt(value);
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                    value,
                    mom.month(),
                    daysInMonth(value, mom.month())
                );
            } else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i,
                prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    var match1 = /\d/, //       0 - 9
        match2 = /\d\d/, //      00 - 99
        match3 = /\d{3}/, //     000 - 999
        match4 = /\d{4}/, //    0000 - 9999
        match6 = /[+-]?\d{6}/, // -999999 - 999999
        match1to2 = /\d\d?/, //       0 - 99
        match3to4 = /\d\d\d\d?/, //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
        match1to3 = /\d{1,3}/, //       0 - 999
        match1to4 = /\d{1,4}/, //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
        matchUnsigned = /\d+/, //       0 - inf
        matchSigned = /[+-]?\d+/, //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord =
            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        regexes;

    regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(
            s
                .replace('\\', '')
                .replace(
                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                    function (matched, p1, p2, p3, p4) {
                        return p1 || p2 || p3 || p4;
                    }
                )
        );
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i,
            func = callback,
            tokenLen;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        tokenLen = token.length;
        for (i = 0; i < tokenLen; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(year)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths =
            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
        defaultLocaleMonthsShort =
            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;

    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months)
                ? this._months
                : this._months['standalone'];
        }
        return isArray(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? 'format'
                      : 'standalone'
              ][m.month()];
    }

    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
              ][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(mom, '').replace('.', '') + '$',
                    'i'
                );
                this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                    'i'
                );
            }
            if (!strict && !this._monthsParse[i]) {
                regex =
                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'MMMM' &&
                this._longMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'MMM' &&
                this._shortMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }

    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._monthsShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] =
            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate(y) {
        var date, args;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear,
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(
        ['w', 'ww', 'W', 'WW'],
        function (input, week, config, token) {
            week[token.substr(0, 1)] = toInt(input);
        }
    );

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6, // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays =
            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;

    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                      ? 'format'
                      : 'standalone'
              ];
        return m === true
            ? shiftWeekdays(weekdays, this._week.dow)
            : m
            ? weekdays[m.day()]
            : weekdays;
    }

    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
            ? this._weekdaysShort[m.day()]
            : this._weekdaysShort;
    }

    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
            ? this._weekdaysMin[m.day()]
            : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mom, '') +
                    '|^' +
                    this.weekdaysShort(mom, '') +
                    '|^' +
                    this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'dddd' &&
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'ddd' &&
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'dd' &&
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }

    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._weekdaysShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
        this._weekdaysMinStrictRegex = new RegExp(
            '^(' + minPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return (
            '' +
            hFormat.apply(this) +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return (
            '' +
            this.hours() +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
            );
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet('Hours', true);

    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse,
    };

    // internal storage for locale config files
    var locales = {},
        localeFamilies = {},
        globalLocale;

    function commonPrefix(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (
                    next &&
                    next.length >= j &&
                    commonPrefix(split, next) >= j - 1
                ) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function isLocaleNameSane(name) {
        // Prevent names that look like filesystem paths, i.e contain '/' or '\'
        return name.match('^[^/\\\\]*$') != null;
    }

    function loadLocale(name) {
        var oldLocale = null,
            aliasedRequire;
        // TODO: Find a better way to register and load all the locales in Node
        if (
            locales[name] === undefined &&
            'object' !== 'undefined' &&
            module &&
            module.exports &&
            isLocaleNameSane(name)
        ) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = commonjsRequire;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                // mark as not found to avoid repeating expensive file require call causing high CPU
                // when trying to find en-US, en_US, en-us for every format call
                locales[name] = null; // null means not found
            }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn(
                        'Locale ' + key + ' not found. Did you forget to load it?'
                    );
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                );
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config,
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null && locales[name].parentLocale != null) {
                // Update existing child locale in-place to avoid memory-leaks
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                // MERGE
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    // updateLocale is called for creating a new locale
                    // Set abbr so it will have a name (getters return
                    // undefined otherwise).
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow,
            a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                    ? MONTH
                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                    ? DATE
                    : a[HOUR] < 0 ||
                      a[HOUR] > 24 ||
                      (a[HOUR] === 24 &&
                          (a[MINUTE] !== 0 ||
                              a[SECOND] !== 0 ||
                              a[MILLISECOND] !== 0))
                    ? HOUR
                    : a[MINUTE] < 0 || a[MINUTE] > 59
                    ? MINUTE
                    : a[SECOND] < 0 || a[SECOND] > 59
                    ? SECOND
                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                    ? MILLISECOND
                    : -1;

            if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
            ) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['YYYY-DDD', /\d{4}-\d{3}/],
            ['YYYY-MM', /\d{4}-\d\d/, false],
            ['YYYYYYMMDD', /[+-]\d{10}/],
            ['YYYYMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['YYYYDDD', /\d{7}/],
            ['YYYYMM', /\d{6}/, false],
            ['YYYY', /\d{4}/, false],
        ],
        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 =
            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };

    // date from iso format
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat,
            isoDatesLen = isoDates.length,
            isoTimesLen = isoTimes.length;

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimesLen; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    function extractFromRFC2822Strings(
        yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr
    ) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s
            .replace(/\([^()]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                    parsedInput[0],
                    parsedInput[1],
                    parsedInput[2]
                ).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        if (config._strict) {
            config._isValid = false;
        } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
        }
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
        );
        expectedWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (
            config._w &&
            typeof config._w.d !== 'undefined' &&
            config._w.d !== expectedWeekday
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era,
            tokenLen;

        tokens =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens.length;
        for (i = 0; i < tokenLen; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (
            config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
        );

        // handle era
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false,
            configfLen = config._f.length;

        if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
                validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
                if (
                    scoreToBeat == null ||
                    currentScore < scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function (obj) {
                return obj && parseInt(obj, 10);
            }
        );

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({ nullInput: true });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if (
            (isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)
        ) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        ),
        prototypeMax = deprecate(
            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };

    var ordering = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond',
    ];

    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i,
            orderLen = ordering.length;
        for (key in m) {
            if (
                hasOwnProp(m, key) &&
                !(
                    indexOf.call(ordering, key) !== -1 &&
                    (m[key] == null || !isNaN(m[key]))
                )
            ) {
                return false;
            }
        }

        for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds =
            +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
            );
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;

        if (matches === null) {
            return null;
        }

        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff =
                (isMoment(input) || isDate(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(
                        this,
                        createDuration(input - offset, 'm'),
                        1,
                        false
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {},
            other;

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex =
            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if (
            typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)
        ) {
            diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
            );

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months =
            other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                    name,
                    'moment().' +
                        name +
                        '(period, number) is deprecated. Please use moment().' +
                        name +
                        '(number, period). ' +
                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                );
                tmp = val;
                val = period;
                period = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');

    function isString(input) {
        return typeof input === 'string' || input instanceof String;
    }

    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate(input) ||
            isString(input) ||
            isNumber(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === undefined
        );
    }

    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms',
            ],
            i,
            property,
            propertyLen = properties.length;

        for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber(item) && isString(input);
                }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }

    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'sameDay',
                'nextDay',
                'lastDay',
                'nextWeek',
                'lastWeek',
                'sameElse',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6
            ? 'sameElse'
            : diff < -1
            ? 'lastWeek'
            : diff < 0
            ? 'lastDay'
            : diff < 1
            ? 'sameDay'
            : diff < 2
            ? 'nextDay'
            : diff < 7
            ? 'nextWeek'
            : 'sameElse';
    }

    function calendar$1(time, formats) {
        // Support for single parameter, formats only overload to the calendar function
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = undefined;
                formats = undefined;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output =
                formats &&
                (isFunction(formats[format])
                    ? formats[format].call(this, now)
                    : formats[format]);

        return this.format(
            output || this.localeData().calendar(format, this, createLocal(now))
        );
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (
            (inclusivity[0] === '('
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')'
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
        );
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
            );
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break; // 1000
            case 'minute':
                output = (this - that) / 6e4;
                break; // 1000 * 60
            case 'hour':
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
                output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
        }
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
                m,
                utc
                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(
            m,
            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
        );
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3),
                    1
                );
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday()
                );
                break;
            case 'isoWeek':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1)
                );
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time =
                    startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3) + 3,
                        1
                    ) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                break;
            case 'isoWeek':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond(),
        ];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }

    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);

    addParseToken(
        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
        function (input, array, config, token) {
            var era = config._locale.erasParse(input, token, config._strict);
            if (era) {
                getParsingFlags(config).era = era;
            } else {
                getParsingFlags(config).invalidEra = input;
            }
        }
    );

    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);

    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }

        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });

    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
                case 'string':
                    // truncate time
                    date = hooks(eras[i].since).startOf('day');
                    eras[i].since = date.valueOf();
                    break;
            }

            switch (typeof eras[i].until) {
                case 'undefined':
                    eras[i].until = +Infinity;
                    break;
                case 'string':
                    // truncate time
                    date = hooks(eras[i].until).startOf('day').valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }

    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();

        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();

            if (strict) {
                switch (format) {
                    case 'N':
                    case 'NN':
                    case 'NNN':
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNN':
                        if (name === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNNN':
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }

    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }

    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }

        return '';
    }

    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }

        return '';
    }

    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }

        return '';
    }

    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (
                (eras[i].since <= val && val <= eras[i].until) ||
                (eras[i].until <= val && val <= eras[i].since)
            ) {
                return (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }

        return this.year();
    }

    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }

    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }

    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }

    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }

    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }

    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }

    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }

    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();

        for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));

            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }

        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp(
            '^(' + narrowPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(
        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
        function (input, week, config, token) {
            week[token.substr(0, 2)] = toInt(input);
        }
    );

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((input - 1) * 3 + (this.month() % 3));
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear =
            Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
            ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });

    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }

    getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
        'dates accessor is deprecated. Use date instead.',
        getSetDayOfMonth
    );
    proto.months = deprecate(
        'months accessor is deprecated. Use month instead',
        getSetMonth
    );
    proto.years = deprecate(
        'years accessor is deprecated. Use year instead',
        getSetYear
    );
    proto.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone
    );
    proto.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        isDaylightSavingTimeShifted
    );

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;

    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i,
            out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: +Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
    });

    // Side effect imports

    hooks.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        getSetGlobalLocale
    );
    hooks.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        getLocale
    );

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (
            !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
            )
        ) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return (days * 4800) / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return (months * 146097) / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':
                    return months;
                case 'quarter':
                    return months / 3;
                case 'year':
                    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y');

    function clone$1() {
        return createDuration(this);
    }

    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round,
        thresholds = {
            ss: 44, // a few seconds to seconds
            s: 45, // seconds to minute
            m: 45, // minutes to hour
            h: 22, // hours to day
            d: 26, // days to month/week
            w: null, // weeks to month
            M: 11, // months to year
        };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a =
                (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]);

        if (thresholds.w != null) {
            a =
                a ||
                (weeks <= 1 && ['w']) ||
                (weeks < thresholds.w && ['ww', weeks]);
        }
        a = a ||
            (months <= 1 && ['M']) ||
            (months < thresholds.M && ['MM', months]) ||
            (years <= 1 && ['y']) || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var withSuffix = false,
            th = thresholds,
            locale,
            output;

        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }

        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return (
            totalSign +
            'P' +
            (years ? ymSign + years + 'Y' : '') +
            (months ? ymSign + months + 'M' : '') +
            (days ? daysSign + days + 'D' : '') +
            (hours || minutes || seconds ? 'T' : '') +
            (hours ? hmsSign + hours + 'H' : '') +
            (minutes ? hmsSign + minutes + 'M' : '') +
            (seconds ? hmsSign + s + 'S' : '')
        );
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1
    );
    proto$2.lang = lang;

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    //! moment.js

    hooks.version = '2.29.4';

    setHookCallback(createLocal);

    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD', // <input type="date" />
        TIME: 'HH:mm', // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW', // <input type="week" />
        MONTH: 'YYYY-MM', // <input type="month" />
    };

    return hooks;

})));
});

var CustomUploader;
var sendAttachmentsAsSeparateMessages = false;
var pendingUploaders = {};
var setCustomUploader = function setCustomUploader(uploader) {
  CustomUploader = uploader;
};
var setSendAttachmentsAsSeparateMessages = function setSendAttachmentsAsSeparateMessages(asSeparate) {
  sendAttachmentsAsSeparateMessages = asSeparate;
};
var getSendAttachmentsAsSeparateMessages = function getSendAttachmentsAsSeparateMessages() {
  return sendAttachmentsAsSeparateMessages;
};
var getCustomUploader = function getCustomUploader() {
  return CustomUploader;
};
var getCustomDownloader = function getCustomDownloader() {
  return CustomUploader && CustomUploader.download;
};
var customUpload = function customUpload(attachment, progress, getUpdatedFilePath) {
  return new Promise(function (resolve, reject) {
    if (CustomUploader) {
      var uploadTask = {
        updateLocalFileLocation: getUpdatedFilePath,
        progress: progress,
        failure: function failure(e) {
          return reject(e);
        },
        success: function success(uri) {
          return resolve(uri);
        },
        cancel: function cancel() {},
        stop: function stop() {},
        resume: function resume() {}
      };
      pendingUploaders[attachment.attachmentId] = uploadTask;
      CustomUploader.upload(attachment, uploadTask);
    } else {
      reject(new Error('No Custom uploader'));
    }
  });
};
var pauseUpload = function pauseUpload(attachmentId) {
  if (pendingUploaders[attachmentId]) {
    return pendingUploaders[attachmentId].stop();
  } else {
    console.log('Unknown uploading task');
    return false;
  }
};
var resumeUpload = function resumeUpload(attachmentId) {
  if (pendingUploaders[attachmentId]) {
    return pendingUploaders[attachmentId].resume();
  } else {
    console.log('Unknown uploading task');
    return false;
  }
};
var cancelUpload = function cancelUpload(attachmentId) {
  return pendingUploaders[attachmentId].cancel();
};

var SceytChatClient = {};
var setClient = function setClient(client) {
  SceytChatClient = client;
};
var getClient = function getClient() {
  return SceytChatClient;
};

var _templateObject$1, _templateObject2$1, _templateObject3$1, _templateObject4$1;
var ReadIconWrapper = styled(SvgTicksRead)(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteralLoose(["\n  color: ", ";\n"])), function (props) {
  return props.color || colors.primary;
});
var DeliveredIconWrapper = styled(SvgTicksDelivered)(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteralLoose(["\n  color: ", ";\n"])), function (props) {
  return props.color || colors.gray4;
});
var SentIconWrapper = styled(SvgTicksSent)(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteralLoose(["\n  color: ", ";\n"])), function (props) {
  return props.color || colors.gray4;
});
var PendingIconWrapper = styled(SvgPendingIcon)(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteralLoose(["\n  color: ", ";\n"])), function (props) {
  return props.color || colors.gray4;
});
var messageStatusIcon = function messageStatusIcon(messageStatus, iconColor, readIconColor) {
  switch (messageStatus) {
    case MESSAGE_DELIVERY_STATUS.READ:
      return React__default.createElement(ReadIconWrapper, {
        color: readIconColor
      });

    case MESSAGE_DELIVERY_STATUS.DELIVERED:
      return React__default.createElement(DeliveredIconWrapper, {
        color: iconColor
      });

    case MESSAGE_DELIVERY_STATUS.SENT:
      return React__default.createElement(SentIconWrapper, {
        color: iconColor
      });

    default:
      return React__default.createElement(PendingIconWrapper, {
        color: iconColor
      });
  }
};
var isAlphanumeric = function isAlphanumeric(str) {
  return /[a-z]/i.test(str);
};
var getFileExtension = function getFileExtension(filename) {
  var ext = filename.split('.').pop();
  if (ext === filename) return '';
  return ext;
};
var urlRegex = /(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})/gi;
var MessageTextFormat = function MessageTextFormat(_ref5) {
  var text = _ref5.text,
      message = _ref5.message,
      contactsMap = _ref5.contactsMap,
      getFromContacts = _ref5.getFromContacts;
  var messageText = [text];

  if (message.mentionedUsers && message.mentionedUsers.length > 0) {
    var mentionsPositions = Object.entries(message.metadata).sort(function (_ref6, _ref7) {
      var a = _ref6[1];
      var b = _ref7[1];
      return b.loc - a.loc;
    }).reduce(function (r, _ref8) {
      var _extends3;

      var k = _ref8[0],
          v = _ref8[1];
      return _extends({}, r, (_extends3 = {}, _extends3[k] = v, _extends3));
    }, {});

    var _loop2 = function _loop2(mentionMemberId) {
      var textPart = messageText.shift();
      var mentionDisplay = message.mentionedUsers.find(function (men) {
        return men.id === mentionMemberId;
      });

      if (mentionDisplay) {
        var user = getClient().chatClient.user;
        messageText.unshift("" + (textPart === null || textPart === void 0 ? void 0 : textPart.substring(0, mentionsPositions[mentionMemberId].loc)), React__default.createElement(MentionedUser, {
          key: "" + mentionMemberId
        }, "@" + makeUserName(user.id === mentionDisplay.id ? mentionDisplay : contactsMap[mentionDisplay.id], mentionDisplay, getFromContacts).trim()), "" + (textPart === null || textPart === void 0 ? void 0 : textPart.substring(mentionsPositions[mentionMemberId].loc + mentionsPositions[mentionMemberId].len)));
      }
    };

    for (var mentionMemberId in mentionsPositions) {
      _loop2(mentionMemberId);
    }
  }

  messageText.forEach(function (textPart, index) {
    if (urlRegex.test(textPart)) {
      var textArray = textPart.split(urlRegex);
      var urlArray = textArray.map(function (part) {
        if (urlRegex.test(part)) {
          return React__default.createElement("a", {
            draggable: false,
            key: part,
            href: part,
            target: '_blank',
            rel: 'noreferrer'
          }, part + " ");
        }

        return part + " ";
      });
      messageText.splice.apply(messageText, [index, 1].concat(urlArray));
    }
  });
  return messageText.length > 1 ? messageText : text;
};
var bytesToSize = function bytesToSize(bytes, decimals) {
  if (decimals === void 0) {
    decimals = 2;
  }

  if (bytes === 0) return '0 Bytes';
  var k = 1024;
  var dm = decimals < 0 ? 0 : decimals;
  var sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  var i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i];
};
var makeUserName = function makeUserName(contact, user, fromContact) {
  if (user && isAlphanumeric(user.id)) {
    return user.id.charAt(0).toUpperCase() + user.id.slice(1);
  }

  return fromContact ? contact ? contact.firstName ? contact.firstName + " " + contact.lastName : contact.id : user ? user.id || 'Deleted user' : '' : user ? user.firstName ? user.firstName + " " + user.lastName : user.id || 'Deleted user' : '';
};
var systemMessageUserName = function systemMessageUserName(contact, userId) {
  return contact ? contact.firstName ? contact.firstName.split(' ')[0] : contact.id : userId || 'Deleted user';
};
var downloadFile = function downloadFile(attachment) {
  try {
    var customDownloader = getCustomDownloader();
    var response;

    var _temp2 = function () {
      if (customDownloader) {
        customDownloader(attachment.url).then(function (url) {
          try {
            return Promise.resolve(fetch(url)).then(function (_fetch2) {
              response = _fetch2;
              return Promise.resolve(response.blob()).then(function (data) {
                FileSaver.saveAs(data, attachment.name);
              });
            });
          } catch (e) {
            return Promise.reject(e);
          }
        });
      } else {
        return Promise.resolve(fetch(attachment.url)).then(function (_fetch) {
          response = _fetch;
          return Promise.resolve(response.blob()).then(function (data) {
            FileSaver.saveAs(data, attachment.name);
          });
        });
      }
    }();

    return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
  } catch (e) {
    return Promise.reject(e);
  }
};
var calculateRenderedImageWidth = function calculateRenderedImageWidth(width, height) {
  var maxWidth = 420;
  var maxHeight = 400;
  var minWidth = 130;
  var aspectRatio = width / height;

  if (aspectRatio >= maxWidth / maxHeight) {
    return [Math.max(minWidth, Math.min(maxWidth, width)), Math.min(maxHeight, maxWidth / aspectRatio) + 2];
  } else {
    if (maxHeight <= height) {
      return [Math.min(maxWidth, maxHeight * aspectRatio), Math.min(maxHeight, height)];
    } else {
      return [Math.min(maxWidth, height * aspectRatio), Math.min(maxHeight, height)];
    }
  }
};
var lastMessageDateFormat = function lastMessageDateFormat(date) {
  var currentTime = moment();
  var startOfDay = currentTime.startOf('day');
  var isToday = moment(date).diff(startOfDay) >= 0;

  if (isToday) {
    return moment(date).format('HH:mm');
  }

  var isInLastWeek = moment().diff(moment(date), 'weeks') < 1;

  if (isInLastWeek) {
    return moment(date).format('dddd');
  }

  return moment(date).format('DD.MM.YY');
};
var userLastActiveDateFormat = function userLastActiveDateFormat(date) {
  var formattingDate = moment(date).format();
  var currentTime = moment();
  var minutesDiff = currentTime.diff(formattingDate, 'minutes');

  if (minutesDiff <= 59) {
    return "Last seen " + (minutesDiff === 0 ? 1 : minutesDiff) + " " + (minutesDiff > 1 ? ' minutes ago' : ' minute ago');
  }

  var startOfDay = moment().startOf('day');
  var isToday = moment(date).diff(startOfDay) >= 0;

  if (isToday) {
    return "Last seen " + moment(date).format('HH:mm');
  }

  var yesterday = moment().subtract(1, 'day').startOf('day');
  var isInYesterday = moment(date).diff(yesterday) >= 0;

  if (isInYesterday) {
    return "Last seen Yesterday at " + moment(date).format('HH:mm');
  }

  var isInLastWeek = moment().diff(moment(date), 'weeks') < 1;

  if (isInLastWeek) {
    return "Last seen " + moment(date).format('dddd') + " at " + moment(date).format('HH:mm');
  }

  return "Last seen " + moment(date).format('DD.MM.YY');
};
var formatAudioVideoTime = function formatAudioVideoTime(duration, currentTime) {
  var minutes = Math.floor((duration - currentTime) / 60);
  var seconds = Math.floor((duration - currentTime) % 60);
  return minutes + ":" + (seconds < 10 ? "0" + seconds : seconds);
};
var formatLargeText = function formatLargeText(text, maxLength) {
  if (text.length > maxLength) {
    var firstHalf = text.slice(0, maxLength / 2 - 1);
    var secondHalf = text.slice(-(maxLength / 2));

    if (firstHalf.length + secondHalf.length > maxLength) {
      return formatLargeText(firstHalf + secondHalf, maxLength);
    } else {
      return firstHalf + '...' + secondHalf;
    }
  } else {
    return text;
  }
};
var getCaretPosition = function getCaretPosition(editableDiv) {
  var caretPos = 0;
  var sel;
  var range;

  if (window.getSelection) {
    sel = window.getSelection();

    if (sel.rangeCount) {
      range = sel.getRangeAt(0);

      if (range.commonAncestorContainer.parentNode === editableDiv) {
        caretPos = range.endOffset;
      }
    }
  } else {
    if (document.selection && document.selection.createRange) {
      range = document.selection.createRange();

      if (range.parentElement() === editableDiv) {
        var tempEl = document.createElement('span');
        editableDiv.childNodes.forEach(function (node) {
          editableDiv.insertBefore(tempEl, node);
          caretPos += node.textContent.length;
        });
      }
    }
  }

  return caretPos;
};
var setCursorPosition = function setCursorPosition(element, position) {
  var range = document.createRange();
  var sel = window.getSelection();
  var node = element.childNodes[0];
  var offset = 0;

  for (var i = 0; i < element.childNodes.length; i++) {
    if (offset + element.childNodes[i].textContent.length >= position) {
      node = element.childNodes[i];
      offset = position - offset;
      break;
    }

    offset += element.childNodes[i].textContent.length;
  }

  range.setStart(node, offset);
  range.collapse(true);

  if (sel) {
    sel.removeAllRanges();
    sel.addRange(range);
  }
};
var placeCaretAtEnd = function placeCaretAtEnd(el) {
  el.focus();

  if (typeof window.getSelection !== 'undefined' && typeof document.createRange !== 'undefined') {
    var range = document.createRange();
    range.selectNodeContents(el);
    range.collapse(false);
    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  } else {
    if (typeof document.body.createTextRange !== 'undefined') {
      var textRange = document.body.createTextRange();
      textRange.moveToElementText(el);
      textRange.collapse(false);
      textRange.select();
    }
  }
};
var detectOS = function detectOS() {
  var userAgent = window.navigator.userAgent;
  var platform = window.navigator.platform;
  var macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];
  var windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'];
  var iosPlatforms = ['iPhone', 'iPad', 'iPod'];
  var os = null;

  if (macosPlatforms.includes(platform)) {
    os = 'Mac OS';
  } else if (iosPlatforms.includes(platform)) {
    os = 'iOS';
  } else if (windowsPlatforms.includes(platform)) {
    os = 'Windows';
  } else if (/Android/.test(userAgent)) {
    os = 'Android';
  } else if (!os && /Linux/.test(platform)) {
    os = 'Linux';
  }

  return os;
};
var detectBrowser = function detectBrowser() {
  var userAgent = window.navigator.userAgent;
  var browser;

  if (userAgent.includes('Opera') || userAgent.includes('OPR')) {
    browser = 'Opera';
  } else if (userAgent.includes('Edge')) {
    browser = 'Edge';
  } else if (userAgent.includes('Chrome')) {
    browser = 'Chrome';
  } else if (userAgent.includes('Safari')) {
    browser = 'Safari';
  } else if (userAgent.includes('Firefox')) {
    browser = 'Firefox';
  } else if (userAgent.includes('MSIE') || userAgent.includes('Trident/')) {
    browser = 'Internet Explorer';
  }

  return browser;
};

var MESSAGES_MAX_LENGTH = 60;
var LOAD_MAX_MESSAGE_COUNT = 20;
var MESSAGE_LOAD_DIRECTION = {
  PREV: 'prev',
  NEXT: 'next'
};
var pendingAttachments = {};
var messagesMap = {};
var pendingMessagesMap = {};
var activeChannelAllMessages = [];
var prevCached = false;
var nextCached = false;
var setAllMessages = function setAllMessages(messages) {
  activeChannelAllMessages = messages;
};
var addAllMessages = function addAllMessages(messages, direction) {
  if (direction === MESSAGE_LOAD_DIRECTION.PREV) {
    activeChannelAllMessages = [].concat(messages, activeChannelAllMessages);
  } else {
    activeChannelAllMessages = [].concat(activeChannelAllMessages, messages);
  }
};
var updateMessageOnAllMessages = function updateMessageOnAllMessages(messageId, updatedParams) {
  activeChannelAllMessages = activeChannelAllMessages.map(function (message) {
    if (message.tid === messageId || message.id === messageId) {
      return _extends({}, message, updatedParams);
    }

    return message;
  });
};
var removeMessageFromAllMessages = function removeMessageFromAllMessages(messageId) {
  activeChannelAllMessages = [].concat(activeChannelAllMessages).filter(function (msg) {
    return !(msg.id === messageId || msg.tid === messageId);
  });
};
var updateMarkersOnAllMessages = function updateMarkersOnAllMessages(markersMap, name) {
  activeChannelAllMessages = activeChannelAllMessages.map(function (message) {
    if (markersMap[message.id] && (message.deliveryStatus === MESSAGE_DELIVERY_STATUS.SENT || name === MESSAGE_DELIVERY_STATUS.READ)) {
      return _extends({}, message, {
        deliveryStatus: name
      });
    }

    return message;
  });
};
var getAllMessages = function getAllMessages() {
  return [].concat(activeChannelAllMessages);
};
var removeAllMessages = function removeAllMessages() {
  activeChannelAllMessages = [];
};
var setHasPrevCached = function setHasPrevCached(state) {
  prevCached = state;
};
var getHasPrevCached = function getHasPrevCached() {
  return prevCached;
};
var setHasNextCached = function setHasNextCached(state) {
  return nextCached = state;
};
var getHasNextCached = function getHasNextCached() {
  return nextCached;
};
var getFromAllMessagesByMessageId = function getFromAllMessagesByMessageId(messageId, direction, getWithLastMessage) {
  var messagesForAdd = [];

  if (getWithLastMessage) {
    messagesForAdd = [].concat(activeChannelAllMessages).slice(-MESSAGES_MAX_LENGTH);
    setHasPrevCached(activeChannelAllMessages.length > MESSAGES_MAX_LENGTH);
    setHasNextCached(false);
  } else {
    var fromMessageIndex = activeChannelAllMessages.findIndex(function (mes) {
      return mes.id === messageId;
    });

    if (fromMessageIndex !== 0) {
      if (direction === MESSAGE_LOAD_DIRECTION.PREV) {
        var sliceFromIndex = fromMessageIndex <= LOAD_MAX_MESSAGE_COUNT ? 0 : fromMessageIndex - (LOAD_MAX_MESSAGE_COUNT + 1);
        messagesForAdd = activeChannelAllMessages.slice(sliceFromIndex, fromMessageIndex);
        setHasPrevCached(!(messagesForAdd.length < LOAD_MAX_MESSAGE_COUNT || sliceFromIndex === 0));
        setHasNextCached(true);
      } else {
        var toMessage = fromMessageIndex + LOAD_MAX_MESSAGE_COUNT + 1;
        messagesForAdd = activeChannelAllMessages.slice(fromMessageIndex + 1, toMessage);

        if (toMessage > activeChannelAllMessages.length - 1) {
          setHasNextCached(false);
        } else {
          setHasNextCached(!(messagesForAdd.length < LOAD_MAX_MESSAGE_COUNT));
        }

        setHasPrevCached(true);
      }
    } else {
      setHasPrevCached(false);
    }
  }

  return messagesForAdd;
};
function setMessagesToMap(channelId, messages) {
  messagesMap[channelId] = messages;
}
function addMessageToMap(channelId, message) {
  if (messagesMap[channelId] && messagesMap[channelId].length >= MESSAGES_MAX_LENGTH) {
    messagesMap[channelId].shift();
  }

  if (messagesMap[channelId]) {
    messagesMap[channelId].push(message);
  } else {
    messagesMap[channelId] = [message];
  }

  if (message.deliveryStatus === MESSAGE_DELIVERY_STATUS.PENDING) {
    if (pendingMessagesMap[channelId]) {
      pendingMessagesMap[channelId].push(message);
    } else {
      pendingMessagesMap[channelId] = [message];
    }
  }
}
function updateMessageOnMap(channelId, updatedMessage) {
  if (updatedMessage.params.deliveryStatus !== MESSAGE_DELIVERY_STATUS.PENDING && updatedMessage.params.state !== MESSAGE_STATUS.FAILED && pendingMessagesMap[channelId]) {
    var filteredMessages = pendingMessagesMap[channelId].filter(function (msg) {
      return msg.tid !== updatedMessage.messageId;
    });

    if (filteredMessages && filteredMessages.length && filteredMessages.length > 0) {
      pendingMessagesMap[channelId] = filteredMessages;
    } else {
      delete pendingMessagesMap[channelId];
    }
  }

  if (messagesMap[channelId]) {
    messagesMap[channelId] = messagesMap[channelId].map(function (mes) {
      if (mes.tid === updatedMessage.messageId || mes.id === updatedMessage.messageId) {
        return _extends({}, mes, updatedMessage.params);
      }

      return mes;
    });
  }
}
function addReactionToMessageOnMap(channelId, message, reaction, isSelf) {
  if (messagesMap[channelId]) {
    messagesMap[channelId] = messagesMap[channelId].map(function (msg) {
      if (msg.id === message.id) {
        var slfReactions = [].concat(msg.selfReactions);

        if (isSelf) {
          if (slfReactions) {
            slfReactions.push(reaction);
          } else {
            slfReactions = [reaction];
          }
        }

        return _extends({}, msg, {
          selfReactions: slfReactions,
          lastReactions: message.lastReactions,
          reactionScores: message.reactionScores
        });
      }

      return msg;
    });
  }
}
function updateMessageStatusOnMap(channelId, newMarkers) {
  if (messagesMap[channelId] && newMarkers && newMarkers.markersMap) {
    messagesMap[channelId] = messagesMap[channelId].map(function (mes) {
      var name = newMarkers.name;
      var markersMap = newMarkers.markersMap;

      if (markersMap[mes.id] && (mes.deliveryStatus === MESSAGE_DELIVERY_STATUS.SENT || name === MESSAGE_DELIVERY_STATUS.READ)) {
        return _extends({}, mes, {
          deliveryStatus: name
        });
      }

      return mes;
    });
  }
}
function getMessagesFromMap(channelId) {
  return messagesMap[channelId];
}
function removeMessagesFromMap(channelId) {
  delete messagesMap[channelId];
}
function removeMessageFromMap(channelId, messageId) {
  messagesMap[channelId] = [].concat(messagesMap[channelId]).filter(function (msg) {
    return !(msg.id === messageId || msg.tid === messageId);
  });
}
function clearMessagesMap() {
  messagesMap = {};
}
function checkChannelExistsOnMessagesMap(channelId) {
  return !!messagesMap[channelId];
}
var pendingVideoAttachmentsThumbs = {};
var setVideoThumb = function setVideoThumb(attachmentId, thumb) {
  pendingVideoAttachmentsThumbs[attachmentId] = thumb;
};
var getVideoThumb = function getVideoThumb(attachmentId) {
  return pendingVideoAttachmentsThumbs[attachmentId];
};
var deleteVideoThumb = function deleteVideoThumb(attachmentId) {
  delete pendingVideoAttachmentsThumbs[attachmentId];
};
var setPendingAttachment = function setPendingAttachment(attachmentId, file) {
  pendingAttachments[attachmentId] = file;
};
var getPendingAttachment = function getPendingAttachment(attachmentId) {
  return pendingAttachments[attachmentId];
};
var deletePendingAttachment = function deletePendingAttachment(attachmentId) {
  return delete pendingAttachments[attachmentId];
};
var getPendingMessagesMap = function getPendingMessagesMap() {
  return pendingMessagesMap;
};

var initialState$1 = {
  messagesLoadingState: null,
  messagesHasNext: false,
  messagesHasPrev: true,
  threadMessagesHasNext: false,
  threadMessagesHasPrev: true,
  activeChannelMessages: [],
  attachmentsForPopup: [],
  activeTabAttachments: [],
  attachmentHasNext: true,
  attachmentForPopupHasNext: true,
  messageToEdit: null,
  activeChannelNewMessage: null,
  pendingMessages: {},
  activeChannelNewMarkers: {
    name: '',
    markersMap: {}
  },
  activeChannelMessageUpdated: null,
  scrollToNewMessage: {
    scrollToBottom: false,
    updateMessageList: false
  },
  showScrollToNewMessageButton: false,
  sendMessageInputHeight: 0,
  messageForReply: null,
  attachmentsUploadingState: {},
  scrollToMessage: null
};
var MessageReducer = (function (state, _temp) {
  if (state === void 0) {
    state = initialState$1;
  }

  var _ref = _temp === void 0 ? {
    type: ''
  } : _temp,
      type = _ref.type,
      payload = _ref.payload;

  var newState = _extends({}, state);

  switch (type) {
    case ADD_MESSAGE:
      {
        var messagesCopy = [].concat(newState.activeChannelMessages);

        if (newState.activeChannelMessages.length >= MESSAGES_MAX_LENGTH) {
          messagesCopy.shift();
          newState.activeChannelMessages = [].concat(messagesCopy, [payload.message]);
        } else {
          newState.activeChannelMessages = [].concat(messagesCopy, [payload.message]);
        }

        return newState;
      }

    case DELETE_MESSAGE_FROM_LIST:
      {
        newState.activeChannelMessages = [].concat(newState.activeChannelMessages).filter(function (msg) {
          return !(msg.id === payload.messageId || msg.tid === payload.messageId);
        });
        return newState;
      }

    case SET_SCROLL_TO_MESSAGE:
      {
        newState.scrollToMessage = payload.messageId;
        return newState;
      }

    case SET_SCROLL_TO_NEW_MESSAGE:
      {
        newState.scrollToNewMessage = {
          scrollToBottom: payload.scrollToBottom,
          updateMessageList: payload.updateMessageList
        };
        return newState;
      }

    case SET_SHOW_SCROLL_TO_NEW_MESSAGE_BUTTON:
      {
        newState.showScrollToNewMessageButton = payload.state;
        return newState;
      }

    case SET_MESSAGES:
      {
        var messages = payload.messages;
        newState.activeChannelMessages = messages;
        return newState;
      }

    case ADD_MESSAGES:
      {
        var _messages = payload.messages,
            direction = payload.direction;

        var _messagesCopy = [].concat(newState.activeChannelMessages);

        var newMessagesLength = _messages.length;
        var currentMessagesLength = newState.activeChannelMessages.length;

        if (direction === MESSAGE_LOAD_DIRECTION.PREV) {
          if (currentMessagesLength >= MESSAGES_MAX_LENGTH) {
            setHasNextCached(true);

            _messagesCopy.splice(-newMessagesLength);

            newState.activeChannelMessages = [].concat(_messages, _messagesCopy);
          } else if (newMessagesLength + currentMessagesLength > MESSAGES_MAX_LENGTH) {
            var sliceElementCount = newMessagesLength + currentMessagesLength - MESSAGES_MAX_LENGTH;
            setHasNextCached(true);

            _messagesCopy.splice(-sliceElementCount);

            newState.activeChannelMessages = [].concat(_messages, _messagesCopy);
          } else {
            newState.activeChannelMessages = [].concat(_messages, newState.activeChannelMessages);
          }
        } else if (direction === 'next') {
          if (currentMessagesLength >= MESSAGES_MAX_LENGTH) {
            setHasPrevCached(true);

            _messagesCopy.splice(0, _messages.length);

            newState.activeChannelMessages = [].concat(_messagesCopy, _messages);
          } else if (newMessagesLength + currentMessagesLength > MESSAGES_MAX_LENGTH) {
            var _sliceElementCount = newMessagesLength + currentMessagesLength - MESSAGES_MAX_LENGTH;

            setHasPrevCached(true);

            _messagesCopy.splice(0, _sliceElementCount);

            newState.activeChannelMessages = [].concat(_messagesCopy, _messages);
          } else {
            newState.activeChannelMessages = [].concat(newState.activeChannelMessages, _messages);
          }
        }

        return newState;
      }

    case UPDATE_MESSAGES_STATUS:
      {
        var name = payload.name,
            markersMap = payload.markersMap;
        var markerName = name;

        var _messagesCopy2 = [].concat(newState.activeChannelMessages);

        var isChanged = false;
        newState.activeChannelNewMarkers = {
          name: name,
          markersMap: markersMap
        };

        _messagesCopy2.forEach(function (message, index) {
          if (markersMap[message.id] && (message.deliveryStatus === MESSAGE_DELIVERY_STATUS.SENT || markerName === MESSAGE_DELIVERY_STATUS.READ) && message.state !== 'Deleted') {
            var messageCopy = _extends({}, message);

            messageCopy.deliveryStatus = markerName;
            _messagesCopy2[index] = messageCopy;

            if (!isChanged) {
              isChanged = true;
            }
          }
        });

        if (isChanged) {
          newState.activeChannelMessages = _messagesCopy2;
        }

        return newState;
      }

    case UPDATE_MESSAGE:
      {
        var messageId = payload.messageId,
            params = payload.params;

        var _messagesCopy3 = [].concat(newState.activeChannelMessages);

        newState.activeChannelMessages = _messagesCopy3.map(function (message) {
          if (message.tid === messageId || message.id === messageId) {
            return _extends({}, message, params);
          }

          return message;
        });
        return newState;
      }

    case ADD_REACTION_TO_MESSAGE:
      {
        var message = payload.message,
            reaction = payload.reaction,
            isSelf = payload.isSelf;

        var _messagesCopy4 = [].concat(newState.activeChannelMessages);

        newState.activeChannelMessages = _messagesCopy4.map(function (msg) {
          if (msg.id === message.id) {
            var slfReactions = [].concat(msg.selfReactions);

            if (isSelf) {
              if (slfReactions) {
                slfReactions.push(reaction);
              } else {
                slfReactions = [reaction];
              }
            }

            return _extends({}, msg, {
              selfReactions: slfReactions,
              lastReactions: message.lastReactions,
              reactionScores: message.reactionScores
            });
          }

          return msg;
        });
        return newState;
      }

    case DELETE_REACTION_FROM_MESSAGE:
      {
        var _reaction = payload.reaction,
            _message = payload.message,
            _isSelf = payload.isSelf;

        var _messagesCopy5 = [].concat(newState.activeChannelMessages);

        newState.activeChannelMessages = _messagesCopy5.map(function (msg) {
          if (msg.id === _message.id) {
            var selfReactions = msg.selfReactions;

            if (_isSelf) {
              selfReactions = msg.selfReactions.filter(function (selfReaction) {
                return selfReaction.key !== _reaction.key;
              });
            }

            return _extends({}, msg, {
              lastReactions: _message.lastReactions,
              reactionScores: _message.reactionScores,
              selfReactions: selfReactions
            });
          }

          return msg;
        });
        return newState;
      }

    case SET_HAS_PREV_MESSAGES:
      {
        newState.messagesHasPrev = payload.hasPrev;
        return newState;
      }

    case SET_MESSAGES_HAS_NEXT:
      {
        newState.messagesHasNext = payload.hasNext;
        return newState;
      }

    case CLEAR_MESSAGES:
      {
        newState.activeChannelMessages = [];
        return newState;
      }

    case EMPTY_CHANNEL_ATTACHMENTS:
      {
        newState.activeTabAttachments = [];
        return newState;
      }

    case SET_ATTACHMENTS:
      {
        var attachments = payload.attachments;
        newState.activeTabAttachments = attachments;
        return newState;
      }

    case SET_ATTACHMENTS_FOR_POPUP:
      {
        var _attachments = payload.attachments;
        newState.attachmentsForPopup = _attachments;
        return newState;
      }

    case ADD_ATTACHMENTS:
      {
        var _attachments2 = payload.attachments;
        var attachmentsCopy = [].concat(newState.activeTabAttachments);
        newState.activeTabAttachments = [].concat(attachmentsCopy, _attachments2);
        return newState;
      }

    case ADD_ATTACHMENTS_FOR_POPUP:
      {
        var _attachments3 = payload.attachments,
            _direction = payload.direction;

        var _attachmentsCopy = [].concat(newState.attachmentsForPopup);

        if (_direction === queryDirection.PREV) {
          newState.attachmentsForPopup = [].concat(_attachmentsCopy, _attachments3);
        } else {
          newState.attachmentsForPopup = [].concat(_attachments3, _attachmentsCopy);
        }

        return newState;
      }

    case SET_ATTACHMENTS_COMPLETE:
      {
        var hasPrev = payload.hasPrev;
        newState.attachmentHasNext = hasPrev;
        return newState;
      }

    case SET_ATTACHMENTS_COMPLETE_FOR_POPUP:
      {
        var _hasPrev = payload.hasPrev;
        newState.attachmentForPopupHasNext = _hasPrev;
        return newState;
      }

    case SET_MESSAGE_TO_EDIT:
      {
        newState.messageToEdit = payload.message;
        return newState;
      }

    case SET_MESSAGES_LOADING_STATE:
      {
        newState.messagesLoadingState = payload.state;
        return newState;
      }

    case SET_SEND_MESSAGE_INPUT_HEIGHT:
      {
        newState.sendMessageInputHeight = payload.height;
        return newState;
      }

    case SET_MESSAGE_FOR_REPLY:
      {
        var _message2 = payload.message;
        newState.messageForReply = _message2;
        return newState;
      }

    case UPLOAD_ATTACHMENT_COMPILATION:
      {
        var _extends2;

        var attachmentUploadingState = payload.attachmentUploadingState,
            attachmentId = payload.attachmentId;
        newState.attachmentsUploadingState = _extends({}, newState.attachmentsUploadingState, (_extends2 = {}, _extends2[attachmentId] = attachmentUploadingState, _extends2));
        return newState;
      }

    case DESTROY_SESSION:
      {
        newState = initialState$1;
        return newState;
      }

    default:
      return state;
  }
});

var GET_MEMBERS = 'GET_MEMBERS';
var ADD_MEMBERS = 'ADD_MEMBERS';
var SET_MEMBERS_TO_LIST = 'SET_MEMBERS_TO_LIST';
var ADD_MEMBERS_TO_LIST = 'ADD_MEMBERS_TO_LIST';
var UPDATE_MEMBERS = 'UPDATE_MEMBERS';
var UPDATE_MEMBERS_PRESENCE = 'UPDATE_MEMBERS_PRESENCE';
var LOAD_MORE_MEMBERS = 'LOAD_MORE_MEMBERS';
var SET_MEMBERS_LOADING_STATE = 'SET_MEMBERS_LOADING_STATE';
var CLEAR_MEMBERS = 'CLEAR_MEMBERS';
var KICK_MEMBER = 'KICK_MEMBER';
var BLOCK_MEMBER = 'BLOCK_MEMBER';
var REPORT_MEMBER = 'REPORT_MEMBER';
var REMOVE_MEMBER_FROM_LIST = 'REMOVE_MEMBER_FROM_LIST';
var GET_ROLES = 'GET_ROLES';
var GET_ROLES_SUCCESS = 'GET_ROLES_SUCCESS';
var CHANGE_MEMBER_ROLE = 'CHANGE_MEMBER_ROLE';

var initialState$2 = {
  membersLoadingState: false,
  membersHasNext: true,
  activeChannelMembers: [],
  roles: []
};
var MembersReducer = (function (state, _ref) {
  if (state === void 0) {
    state = initialState$2;
  }

  var type = _ref.type,
      payload = _ref.payload;

  var newState = _extends({}, state);

  switch (type) {
    case SET_MEMBERS_TO_LIST:
      {
        var members = payload.members;
        newState.activeChannelMembers = [].concat(members);
        return newState;
      }

    case ADD_MEMBERS_TO_LIST:
      {
        var _members = payload.members;
        newState.activeChannelMembers = [].concat(newState.activeChannelMembers, _members);
        return newState;
      }

    case UPDATE_MEMBERS:
      {
        var _members2 = payload.members;
        var updateMembers = [];
        var membersCopy = [].concat(newState.activeChannelMembers);

        if (_members2.length) {
          var updatedMembersMap = {};

          for (var i = 0; i < _members2.length; i++) {
            updatedMembersMap[_members2[i].id] = _members2[i];
          }

          updateMembers = membersCopy.map(function (member) {
            if (updatedMembersMap[member.id]) {
              return updatedMembersMap[member.id];
            }

            return member;
          });
          newState.activeChannelMembers = updateMembers;
        }

        return newState;
      }

    case UPDATE_MEMBERS_PRESENCE:
      {
        var _members3 = payload.members;
        var _updateMembers = [];

        if (_members3.length && newState.activeChannelMembers.length) {
          var _membersCopy = [].concat(newState.activeChannelMembers);

          var _updatedMembersMap = {};

          for (var _i = 0; _i < _members3.length; _i++) {
            _updatedMembersMap[_members3[_i].id] = _members3[_i];
          }

          _updateMembers = _membersCopy.map(function (member) {
            if (_updatedMembersMap[member.id]) {
              return _extends({}, member, {
                presence: _updatedMembersMap[member.id].presence
              });
            }

            return member;
          });
          newState.activeChannelMembers = _updateMembers;
        }

        return newState;
      }

    case CLEAR_MEMBERS:
      {
        newState.activeChannelMembers = [];
        return newState;
      }

    case REMOVE_MEMBER_FROM_LIST:
      {
        var _members4 = payload.members;

        if (_members4.length) {
          var _updateMembers2 = [];

          var _membersCopy2 = [].concat(newState.activeChannelMembers);

          var removedMembersMap = {};

          for (var _i2 = 0; _i2 < _members4.length; _i2++) {
            removedMembersMap[_members4[_i2].id] = _members4[_i2];
          }

          _updateMembers2 = _membersCopy2.filter(function (member) {
            return !removedMembersMap[member.id];
          });
          newState.activeChannelMembers = _updateMembers2;
        }

        return newState;
      }

    case SET_MEMBERS_LOADING_STATE:
      {
        newState.membersLoadingState = payload.state;
        return newState;
      }

    case GET_ROLES_SUCCESS:
      {
        newState.roles = payload.roles;
        return newState;
      }

    case DESTROY_SESSION:
      {
        newState = initialState$2;
        return newState;
      }

    default:
      return state;
  }
});

var SET_CONNECTION_STATUS = 'SET_CONNECTION_STATUS';
var SET_CONTACT_LOADING_STATE = 'SET_CONTACT_LOADING_STATE';
var GET_CONTACTS = 'GET_CONTACTS';
var SET_CONTACTS = 'SET_CONTACTS';
var GET_USERS = 'GET_USERS';
var LOAD_MORE_USERS = 'LOAD_MORE_USERS';
var SET_USERS_LOADING_STATE = 'SET_USERS_LOADING_STATE';
var SET_USERS = 'SET_USERS';
var ADD_USERS = 'ADD_USERS';
var GET_ROLES$1 = 'GET_ROLES';
var SET_ROLES = 'SET_ROLES';
var BLOCK_USERS = 'BLOCK_USERS';
var UNBLOCK_USERS = 'UNBLOCK_USERS';
var SET_USER = 'SET_USER';
var UPDATE_PROFILE = 'UPDATE_PROFILE';
var UPDATE_USER_PROFILE = 'UPDATE_USER_PROFILE';
var BROWSER_TAB_IS_ACTIVE = 'BROWSER_TAB_IS_ACTIVE';
var CONNECTION_EVENT_TYPES = {
  TOKEN_WILL_EXPIRE: 'TOKEN_WILL_EXPIRE',
  CONNECTION_STATUS_CHANGED: 'CONNECTION_STATUS_CHANGED',
  TOKEN_EXPIRED: 'TOKEN_EXPIRED'
};
var CONNECTION_STATUS = {
  CONNECTING: 'Connecting',
  CONNECTED: 'Connected',
  CONNECTING_FAILED: 'Failed',
  DISCONNECTED: 'Disconnected'
};

var initialState$3 = {
  connectionStatus: '',
  contactList: [],
  usersList: [],
  usersLoadingState: null,
  rolesMap: {},
  contactsMap: {},
  user: {
    id: '',
    firstName: '',
    lastName: ''
  },
  browserTabIsActive: true
};
var UserReducer = (function (state, _ref) {
  if (state === void 0) {
    state = initialState$3;
  }

  var type = _ref.type,
      payload = _ref.payload;

  var newState = _extends({}, state);

  switch (type) {
    case SET_CONNECTION_STATUS:
      {
        var status = payload.status;
        newState.connectionStatus = status;
        return newState;
      }

    case SET_USER:
      {
        newState.user = _extends({}, payload.user);
        return newState;
      }

    case SET_USERS:
      {
        newState.usersList = [].concat(payload.users);
        return newState;
      }

    case ADD_USERS:
      {
        newState.usersList = [].concat(newState.usersList, payload.users);
        return newState;
      }

    case SET_USERS_LOADING_STATE:
      {
        newState.usersLoadingState = payload.state;
        return newState;
      }

    case SET_CONTACTS:
      {
        var contacts = payload.contacts;
        newState.contactList = [].concat(contacts);
        var contactsMap = {};
        contacts.map(function (contact) {
          contactsMap[contact.id] = contact;
        });
        newState.contactsMap = contactsMap;
        return newState;
      }

    case SET_ROLES:
      {
        var roles = payload.roles;
        var rolesMap = {};
        roles.map(function (role) {
          rolesMap[role.name] = role;
        });
        newState.rolesMap = rolesMap;
        return newState;
      }

    case UPDATE_USER_PROFILE:
      {
        console.log('update user.... ');
        newState.user = _extends({}, newState.user, payload.profile);
        return newState;
      }

    case BROWSER_TAB_IS_ACTIVE:
      {
        newState.browserTabIsActive = payload.state;
        return newState;
      }

    case DESTROY_SESSION:
      {
        newState = initialState$3;
        return newState;
      }

    default:
      return state;
  }
});

var reducers = combineReducers({
  ChannelReducer: ChannelReducer,
  MessageReducer: MessageReducer,
  MembersReducer: MembersReducer,
  UserReducer: UserReducer
});

function createChannelAC(channelData) {
  return {
    type: CREATE_CHANNEL,
    payload: {
      channelData: channelData
    }
  };
}
function getChannelsAC(params, isJoinChannel) {
  return {
    type: GET_CHANNELS,
    payload: {
      params: params,
      isJoinChannel: isJoinChannel
    }
  };
}
function loadMoreChannels(limit) {
  return {
    type: LOAD_MORE_CHANNEL,
    payload: {
      limit: limit
    }
  };
}
function getChannelsForForwardAC(searchValue) {
  return {
    type: GET_CHANNELS_FOR_FORWARD,
    payload: {
      searchValue: searchValue
    }
  };
}
function loadMoreChannelsForForward(limit) {
  return {
    type: LOAD_MORE_CHANNELS_FOR_FORWARD,
    payload: {
      limit: limit
    }
  };
}
function addChannelAC(channel) {
  return {
    type: ADD_CHANNEL,
    payload: {
      channel: channel
    }
  };
}
function addChannelsAC(channels) {
  return {
    type: ADD_CHANNELS,
    payload: {
      channels: channels
    }
  };
}
function addChannelsForForwardAC(channels) {
  return {
    type: ADD_CHANNELS_FOR_FORWARD,
    payload: {
      channels: channels
    }
  };
}
function deleteChannelAC(channelId) {
  return {
    type: DELETE_CHANNEL,
    payload: {
      channelId: channelId
    }
  };
}
function blockChannelAC(channelId) {
  return {
    type: BLOCK_CHANNEL,
    payload: {
      channelId: channelId
    }
  };
}
function removeChannelAC(channelId) {
  return {
    type: REMOVE_CHANNEL,
    payload: {
      channelId: channelId
    }
  };
}
function removeChannelCachesAC(channelId) {
  return {
    type: REMOVE_CHANNEL_CACHES,
    payload: {
      channelId: channelId
    }
  };
}
function setChannelToAddAC(channel) {
  return {
    type: SET_CHANNEL_TO_ADD,
    payload: {
      channel: channel
    }
  };
}
function setAddedToChannelAC(channel) {
  return {
    type: SET_ADDED_TO_CHANNEL,
    payload: {
      channel: channel
    }
  };
}
function setChannelToRemoveAC(channel) {
  return {
    type: SET_CHANNEL_TO_REMOVE,
    payload: {
      channel: channel
    }
  };
}
function setChannelToHideAC(channel) {
  return {
    type: SET_CHANNEL_TO_HIDE,
    payload: {
      channel: channel
    }
  };
}
function setChannelToUnHideAC(channel) {
  return {
    type: SET_CHANNEL_TO_UNHIDE,
    payload: {
      channel: channel
    }
  };
}
function setChannelsAC(channels) {
  return {
    type: SET_CHANNELS,
    payload: {
      channels: channels
    }
  };
}
function setChannelsFroForwardAC(channels) {
  return {
    type: SET_CHANNELS_FOR_FORWARD,
    payload: {
      channels: channels
    }
  };
}
function setChannelsLoadingStateAC(state, forForward) {
  return {
    type: SET_CHANNELS_LOADING_STATE,
    payload: {
      state: state,
      forForward: forForward
    }
  };
}
function channelHasNextAC(hasNext, forForward) {
  return {
    type: CHANNELS_HAS_NEXT,
    payload: {
      hasNext: hasNext,
      forForward: forForward
    }
  };
}
function setActiveChannelAC(channel) {
  return {
    type: SET_ACTIVE_CHANNEL,
    payload: {
      channel: channel
    }
  };
}
function switchChannelActionAC(channel) {
  return {
    type: SWITCH_CHANNEL,
    payload: {
      channel: channel
    }
  };
}
function updateChannelAC(channelId, config) {
  return {
    type: UPDATE_CHANNEL,
    payload: {
      channelId: channelId,
      config: config
    }
  };
}
function updateChannelDataAC(channelId, config) {
  return {
    type: UPDATE_CHANNEL_DATA,
    payload: {
      channelId: channelId,
      config: config
    }
  };
}
function updateChannelLastMessageAC(message, channel) {
  return {
    type: UPDATE_CHANNEL_LAST_MESSAGE,
    payload: {
      message: message,
      channel: channel
    }
  };
}
function updateChannelLastMessageStatusAC(message, channel) {
  return {
    type: UPDATE_CHANNEL_LAST_MESSAGE_STATUS,
    payload: {
      message: message,
      channel: channel
    }
  };
}
function markMessagesAsReadAC(channelId, messageIds) {
  return {
    type: MARK_MESSAGES_AS_READ,
    payload: {
      channelId: channelId,
      messageIds: messageIds
    }
  };
}
function markMessagesAsDeliveredAC(channelId, messageIds) {
  return {
    type: MARK_MESSAGES_AS_DELIVERED,
    payload: {
      channelId: channelId,
      messageIds: messageIds
    }
  };
}
function sendTypingAC(state) {
  return {
    type: SEND_TYPING,
    payload: {
      state: state
    }
  };
}
function switchTypingIndicatorAC(typingState, channelId, from) {
  return {
    type: SWITCH_TYPING_INDICATOR,
    payload: {
      typingState: typingState,
      from: from,
      channelId: channelId
    }
  };
}
function turnOffNotificationsAC(expireTime) {
  return {
    type: TURN_OFF_NOTIFICATION,
    payload: {
      expireTime: expireTime
    }
  };
}
function turnOnNotificationsAC() {
  return {
    type: TURN_ON_NOTIFICATION
  };
}
function markChannelAsReadAC(channelId) {
  return {
    type: MARK_CHANNEL_AS_READ,
    payload: {
      channelId: channelId
    }
  };
}
function markChannelAsUnReadAC(channelId) {
  return {
    type: MARK_CHANNEL_AS_UNREAD,
    payload: {
      channelId: channelId
    }
  };
}
function switchChannelInfoAC(open) {
  return {
    type: CHANNEL_INFO_OPEN_CLOSE,
    payload: {
      open: open
    }
  };
}
function leaveChannelAC(channelId) {
  return {
    type: LEAVE_CHANNEL,
    payload: {
      channelId: channelId
    }
  };
}
function toggleEditChannelAC(state) {
  return {
    type: TOGGLE_EDIT_CHANNEL,
    payload: {
      state: state
    }
  };
}
function checkUserStatusAC(usersMap) {
  return {
    type: CHECK_USER_STATUS,
    payload: {
      usersMap: usersMap
    }
  };
}
function updateUserStatusOnChannelAC(usersMap) {
  return {
    type: UPDATE_USER_STATUS_ON_CHANNEL,
    payload: {
      usersMap: usersMap
    }
  };
}
function setChannelListWithAC(width) {
  return {
    type: SET_CHANNEL_LIST_WIDTH,
    payload: {
      width: width
    }
  };
}
function clearHistoryAC(channelId) {
  return {
    type: CLEAR_HISTORY,
    payload: {
      channelId: channelId
    }
  };
}
function deleteAllMessagesAC(channelId) {
  return {
    type: DELETE_ALL_MESSAGES,
    payload: {
      channelId: channelId
    }
  };
}
function joinChannelAC(channelId) {
  return {
    type: JOIN_TO_CHANNEL,
    payload: {
      channelId: channelId
    }
  };
}
function setIsDraggingAC(isDragging) {
  return {
    type: SET_IS_DRAGGING,
    payload: {
      isDragging: isDragging
    }
  };
}
function setDraggedAttachments(attachments, type) {
  return {
    type: SET_DRAGGED_ATTACHMENTS,
    payload: {
      attachments: attachments,
      type: type
    }
  };
}
function watchForEventsAC() {
  return {
    type: WATCH_FOR_EVENTS
  };
}
function destroySession() {
  return {
    type: DESTROY_SESSION
  };
}

var channelsMap = {};
var activeChannelId = '';
function setChannelInMap(channel) {
  channelsMap[channel.id] = channel;
}
function setActiveChannelId(id) {
  activeChannelId = id;
}
function getActiveChannelId() {
  return activeChannelId;
}
function setChannelsInMap(channels) {
  channels.forEach(function (channel) {

    channelsMap[channel.id] = channel;
  });
  return JSON.parse(JSON.stringify(channels));
}
function getChannelFromMap(channelId) {
  return channelsMap[channelId];
}
function getLastChannelFromMap() {
  return Object.values(channelsMap)[0];
}
function removeChannelFromMap(channelId) {
  delete channelsMap[channelId];
}
function checkChannelExists(channelId) {
  return !!channelsMap[channelId];
}
function destroyChannelsMap() {
  channelsMap = {};
}
var query = {
  channelQuery: null,
  channelQueryForward: null,
  blockedQuery: null,
  current: null,
  membersQuery: null,
  usersQuery: null,
  hiddenQuery: null,
  messageQuery: null,
  blockedMembersQuery: null,
  AttachmentByTypeQuery: null,
  AttachmentByTypeQueryForPopup: null
};
var unreadScrollTo = {
  isScrolled: true
};
function getUnreadScrollTo() {
  return unreadScrollTo.isScrolled;
}
function setUnreadScrollTo(state) {
  unreadScrollTo.isScrolled = state;
}

function sendMessageAC(message, channelId, connectionState, sendAttachmentsAsSeparateMessage, isResend) {
  return {
    type: SEND_MESSAGE,
    payload: {
      message: message,
      channelId: channelId,
      connectionState: connectionState,
      sendAttachmentsAsSeparateMessage: sendAttachmentsAsSeparateMessage,
      isResend: isResend
    }
  };
}
function sendTextMessageAC(message, channelId, connectionState) {
  return {
    type: SEND_TEXT_MESSAGE,
    payload: {
      message: message,
      channelId: channelId,
      connectionState: connectionState
    }
  };
}
function resendMessageAC(message, channelId, connectionState) {
  return {
    type: RESEND_MESSAGE,
    payload: {
      channelId: channelId,
      message: message,
      connectionState: connectionState
    }
  };
}
function forwardMessageAC(message, channelId, connectionState) {
  return {
    type: FORWARD_MESSAGE,
    payload: {
      message: message,
      channelId: channelId,
      connectionState: connectionState
    }
  };
}
function deleteMessageAC(channelId, messageId, deleteOption) {
  return {
    type: DELETE_MESSAGE,
    payload: {
      channelId: channelId,
      messageId: messageId,
      deleteOption: deleteOption
    }
  };
}
function deleteMessageFromListAC(messageId) {
  return {
    type: DELETE_MESSAGE_FROM_LIST,
    payload: {
      messageId: messageId
    }
  };
}
function editMessageAC(channelId, message) {
  return {
    type: EDIT_MESSAGE,
    payload: {
      channelId: channelId,
      message: message
    }
  };
}
function setMessageToEditAC(message) {
  return {
    type: SET_MESSAGE_TO_EDIT,
    payload: {
      message: message
    }
  };
}
function getMessagesAC(channel, loadWithLastMessage, messageId, limit) {
  return {
    type: GET_MESSAGES,
    payload: {
      channel: channel,
      loadWithLastMessage: loadWithLastMessage,
      messageId: messageId,
      limit: limit
    }
  };
}
function setScrollToMessagesAC(messageId) {
  return {
    type: SET_SCROLL_TO_MESSAGE,
    payload: {
      messageId: messageId
    }
  };
}
function setMessagesLoadingStateAC(state) {
  return {
    type: SET_MESSAGES_LOADING_STATE,
    payload: {
      state: state
    }
  };
}
function addMessagesAC(messages, direction) {
  return {
    type: ADD_MESSAGES,
    payload: {
      messages: messages,
      direction: direction
    }
  };
}
function setMessagesAC(messages) {
  return {
    type: SET_MESSAGES,
    payload: {
      messages: messages
    }
  };
}
function addReactionAC(channelId, messageId, key, score, reason, enforceUnique) {
  return {
    type: ADD_REACTION,
    payload: {
      channelId: channelId,
      messageId: messageId,
      key: key,
      score: score,
      reason: reason,
      enforceUnique: enforceUnique
    }
  };
}
function deleteReactionAC(channelId, messageId, key) {
  return {
    type: DELETE_REACTION,
    payload: {
      channelId: channelId,
      messageId: messageId,
      key: key
    }
  };
}
function addReactionToMessageAC(message, reaction, isSelf) {
  return {
    type: ADD_REACTION_TO_MESSAGE,
    payload: {
      message: message,
      reaction: reaction,
      isSelf: isSelf
    }
  };
}
function deleteReactionFromMessageAC(message, reaction, isSelf) {
  return {
    type: DELETE_REACTION_FROM_MESSAGE,
    payload: {
      message: message,
      reaction: reaction,
      isSelf: isSelf
    }
  };
}
function updateAttachmentUploadingStateAC(attachmentUploadingState, attachmentId) {
  return {
    type: UPLOAD_ATTACHMENT_COMPILATION,
    payload: {
      attachmentUploadingState: attachmentUploadingState,
      attachmentId: attachmentId
    }
  };
}
function emptyChannelAttachmentsAC() {
  return {
    type: EMPTY_CHANNEL_ATTACHMENTS
  };
}
function addMessageAC(message) {
  return {
    type: ADD_MESSAGE,
    payload: {
      message: message
    }
  };
}
function scrollToNewMessageAC(scrollToBottom, updateMessageList) {
  return {
    type: SET_SCROLL_TO_NEW_MESSAGE,
    payload: {
      scrollToBottom: scrollToBottom,
      updateMessageList: updateMessageList
    }
  };
}
function showScrollToNewMessageButtonAC(state) {
  return {
    type: SET_SHOW_SCROLL_TO_NEW_MESSAGE_BUTTON,
    payload: {
      state: state
    }
  };
}
function loadMoreMessagesAC(channelId, limit, direction, messageId, hasNext) {
  return {
    type: LOAD_MORE_MESSAGES,
    payload: {
      limit: limit,
      direction: direction,
      channelId: channelId,
      messageId: messageId,
      hasNext: hasNext
    }
  };
}
function setMessagesHasPrevAC(hasPrev) {
  return {
    type: SET_HAS_PREV_MESSAGES,
    payload: {
      hasPrev: hasPrev
    }
  };
}
function setMessagesHasNextAC(hasNext) {
  return {
    type: SET_MESSAGES_HAS_NEXT,
    payload: {
      hasNext: hasNext
    }
  };
}
function updateMessageAC(messageId, params) {
  return {
    type: UPDATE_MESSAGE,
    payload: {
      messageId: messageId,
      params: params
    }
  };
}
function updateMessagesStatusAC(name, markersMap) {
  return {
    type: UPDATE_MESSAGES_STATUS,
    payload: {
      name: name,
      markersMap: markersMap
    }
  };
}
function clearMessagesAC() {
  return {
    type: CLEAR_MESSAGES
  };
}
function getAttachmentsAC(channelId, attachmentType, limit, direction, attachmentId, forPopup) {
  return {
    type: GET_MESSAGES_ATTACHMENTS,
    payload: {
      channelId: channelId,
      attachmentType: attachmentType,
      limit: limit,
      direction: direction,
      forPopup: forPopup,
      attachmentId: attachmentId
    }
  };
}
function setAttachmentsAC(attachments) {
  return {
    type: SET_ATTACHMENTS,
    payload: {
      attachments: attachments
    }
  };
}
function setAttachmentsForPopupAC(attachments) {
  return {
    type: SET_ATTACHMENTS_FOR_POPUP,
    payload: {
      attachments: attachments
    }
  };
}
function loadMoreAttachmentsAC(limit) {
  return {
    type: LOAD_MORE_MESSAGES_ATTACHMENTS,
    payload: {
      limit: limit
    }
  };
}
function addAttachmentsAC(attachments) {
  return {
    type: ADD_ATTACHMENTS,
    payload: {
      attachments: attachments
    }
  };
}
function addAttachmentsForPopupAC(attachments, direction) {
  return {
    type: ADD_ATTACHMENTS_FOR_POPUP,
    payload: {
      attachments: attachments,
      direction: direction
    }
  };
}
function setAttachmentsCompleteAC(hasPrev) {
  return {
    type: SET_ATTACHMENTS_COMPLETE,
    payload: {
      hasPrev: hasPrev
    }
  };
}
function setAttachmentsCompleteForPopupAC(hasPrev) {
  return {
    type: SET_ATTACHMENTS_COMPLETE_FOR_POPUP,
    payload: {
      hasPrev: hasPrev
    }
  };
}
function pauseAttachmentUploadingAC(attachmentId) {
  return {
    type: PAUSE_ATTACHMENT_UPLOADING,
    payload: {
      attachmentId: attachmentId
    }
  };
}
function resumeAttachmentUploadingAC(attachmentId) {
  return {
    type: RESUME_ATTACHMENT_UPLOADING,
    payload: {
      attachmentId: attachmentId
    }
  };
}
function setSendMessageInputHeightAC(height) {
  return {
    type: SET_SEND_MESSAGE_INPUT_HEIGHT,
    payload: {
      height: height
    }
  };
}
function setMessageForReplyAC(message) {
  return {
    type: SET_MESSAGE_FOR_REPLY,
    payload: {
      message: message
    }
  };
}

function setConnectionStatusAC(status) {
  return {
    type: SET_CONNECTION_STATUS,
    payload: {
      status: status
    }
  };
}
function getUsersAC(params) {
  return {
    type: GET_USERS,
    payload: {
      params: params
    }
  };
}
function loadMoreUsersAC(limit) {
  return {
    type: LOAD_MORE_USERS,
    payload: {
      limit: limit
    }
  };
}
function setUsersLoadingStateAC(state) {
  return {
    type: SET_USERS_LOADING_STATE,
    payload: {
      state: state
    }
  };
}
function setUsersAC(users) {
  return {
    type: SET_USERS,
    payload: {
      users: users
    }
  };
}
function addUsersAC(users) {
  return {
    type: ADD_USERS,
    payload: {
      users: users
    }
  };
}
function getContactsAC() {
  return {
    type: GET_CONTACTS,
    payload: {}
  };
}
function setContactsAC(contacts) {
  return {
    type: SET_CONTACTS,
    payload: {
      contacts: contacts
    }
  };
}
function getRolesAC() {
  return {
    type: GET_ROLES$1,
    payload: {}
  };
}
function setRolesAC(roles) {
  return {
    type: SET_ROLES,
    payload: {
      roles: roles
    }
  };
}
function blockUserAC(userIds) {
  return {
    type: BLOCK_USERS,
    payload: {
      userIds: userIds
    }
  };
}
function unblockUserAC(userIds) {
  return {
    type: UNBLOCK_USERS,
    payload: {
      userIds: userIds
    }
  };
}
function setContactsLoadingStateAC(status) {
  return {
    type: SET_CONTACT_LOADING_STATE,
    payload: {
      status: status
    }
  };
}
function setUserAC(user) {
  return {
    type: SET_USER,
    payload: {
      user: user
    }
  };
}
function updateUserProfileAC(profile) {
  return {
    type: UPDATE_USER_PROFILE,
    payload: {
      profile: profile
    }
  };
}
function browserTabIsActiveAC(state) {
  return {
    type: BROWSER_TAB_IS_ACTIVE,
    payload: {
      state: state
    }
  };
}
function updateProfileAC(user, firstName, lastName, avatarUrl, metadata, avatarFile, presence) {
  return {
    type: UPDATE_PROFILE,
    payload: {
      user: user,
      firstName: firstName,
      lastName: lastName,
      avatarUrl: avatarUrl,
      metadata: metadata,
      avatarFile: avatarFile,
      presence: presence
    }
  };
}

var userDisplayNameFromContact = false;
var setShowOnlyContactUsers = function setShowOnlyContactUsers(value) {
  userDisplayNameFromContact = value;
};
var getShowOnlyContactUsers = function getShowOnlyContactUsers() {
  return userDisplayNameFromContact;
};

var contactsMap = {};
var logoSrc = '';
var setNotification = function setNotification(body, user, channel) {
  var getFromContacts = getShowOnlyContactUsers();
  var notification = new Notification("New Message from " + makeUserName(contactsMap[user.id], user, getFromContacts), {
    body: body,
    icon: logoSrc
  });

  notification.onclick = function (event) {
    event.preventDefault();
    window.focus();
    store.dispatch({
      type: SWITCH_CHANNEL,
      payload: {
        channel: channel
      }
    });
    notification.close();
  };

  if (window.sceytTabNotifications) {
    window.sceytTabNotifications.close();
  }

  window.sceytTabNotifications = notification;
};
var setNotificationLogoSrc = function setNotificationLogoSrc(src) {
  logoSrc = src;
};
var setContactsMap = function setContactsMap(contacts) {
  contactsMap = contacts;
};

function getMembersAC(channelId) {
  return {
    type: GET_MEMBERS,
    payload: {
      channelId: channelId
    }
  };
}
function setMembersToListAC(members) {
  return {
    type: SET_MEMBERS_TO_LIST,
    payload: {
      members: members
    }
  };
}
function addMembersToListAC(members) {
  return {
    type: ADD_MEMBERS_TO_LIST,
    payload: {
      members: members
    }
  };
}
function updateMembersAC(members) {
  return {
    type: UPDATE_MEMBERS,
    payload: {
      members: members
    }
  };
}
function updateMembersPresenceAC(members) {
  return {
    type: UPDATE_MEMBERS_PRESENCE,
    payload: {
      members: members
    }
  };
}
function loadMoreMembersAC(limit) {
  return {
    type: LOAD_MORE_MEMBERS,
    payload: {
      limit: limit
    }
  };
}
function setMembersLoadingStateAC(state) {
  return {
    type: SET_MEMBERS_LOADING_STATE,
    payload: {
      state: state
    }
  };
}
function addMembersAC(channelId, members) {
  return {
    type: ADD_MEMBERS,
    payload: {
      channelId: channelId,
      members: members
    }
  };
}
function kickMemberAC(channelId, memberId) {
  return {
    type: KICK_MEMBER,
    payload: {
      channelId: channelId,
      memberId: memberId
    }
  };
}
function blockMemberAC(channelId, memberId) {
  return {
    type: BLOCK_MEMBER,
    payload: {
      channelId: channelId,
      memberId: memberId
    }
  };
}
function removeMemberFromListAC(members) {
  return {
    type: REMOVE_MEMBER_FROM_LIST,
    payload: {
      members: members
    }
  };
}
function getRolesAC$1() {
  return {
    type: GET_ROLES
  };
}
function getRolesSuccess(roles) {
  return {
    type: GET_ROLES_SUCCESS,
    payload: {
      roles: roles
    }
  };
}
function changeMemberRoleAC(channelId, members) {
  return {
    type: CHANGE_MEMBER_ROLE,
    payload: {
      channelId: channelId,
      members: members
    }
  };
}

var _marked = /*#__PURE__*/_regeneratorRuntime().mark(watchForEvents);
function watchForEvents() {
  var SceytChatClient, channelListener, connectionListener, typingUsersTimeout, chan, _yield$take, type, args, createdChannel, channelExists, channel, _channel, member, _activeChannelId, _channel2, _channelExists, _channel3, removedMembers, _activeChannelId2, _channelExists2, activeChannel, _channel4, _activeChannelId3, _channelExists3, updatedChannel, _channelExists4, subject, avatarUrl, _channel5, message, _activeChannelId4, _channelExists5, channelForAdd, _ret, _ret2, _channel6, from, channelId, _activeChannelId6, _channel7, _activeChannel, _channel8, deletedMessage, _activeChannelId7, _channelExists6, _channel9, _message, _activeChannelId8, _channelExists7, _channel10, user, _message2, reaction, isSelf, _activeChannelId9, _channel11, _user, _message3, _reaction, _isSelf, _activeChannelId10, _channel12, channelUnreadCount, _updatedChannel, _channel13, _activeChannelId11, channelExist, _channel14, _channel15, _channel16, _channel17, _channel18, _channel19, status;

  return _regeneratorRuntime().wrap(function watchForEvents$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          SceytChatClient = getClient();
          channelListener = new SceytChatClient.ChannelListener();
          connectionListener = new SceytChatClient.ConnectionListener();
          typingUsersTimeout = {};
          chan = eventChannel(function (emitter) {
            channelListener.onCreated = function (createdChannel) {
              emitter({
                type: CHANNEL_EVENT_TYPES.CREATE,
                args: {
                  createdChannel: createdChannel
                }
              });
            };

            channelListener.onMemberJoined = function (channel, joinedMember) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.JOIN,
                args: {
                  channel: channel,
                  joinedMember: joinedMember
                }
              });
            };

            channelListener.onMemberLeft = function (channel, member) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.LEAVE,
                args: {
                  channel: channel,
                  member: member
                }
              });
            };

            channelListener.onBlocked = function (channel) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.BLOCK,
                args: {
                  channel: channel
                }
              });
            };

            channelListener.onUnblocked = function (channel) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.UNBLOCK,
                args: {
                  channel: channel
                }
              });
            };

            channelListener.onMembersAdded = function (_ref) {
              var channel = _ref.channel,
                  addedMembers = _ref.addedMembers;
              return emitter({
                type: CHANNEL_EVENT_TYPES.ADD_MEMBERS,
                args: {
                  channel: channel,
                  addedMembers: addedMembers
                }
              });
            };

            channelListener.onMembersKicked = function (_ref2) {
              var channel = _ref2.channel,
                  removedMembers = _ref2.removedMembers;
              return emitter({
                type: CHANNEL_EVENT_TYPES.KICK_MEMBERS,
                args: {
                  channel: channel,
                  removedMembers: removedMembers
                }
              });
            };

            channelListener.onUpdated = function (updatedChannel) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.UPDATE_CHANNEL,
                args: {
                  updatedChannel: updatedChannel
                }
              });
            };

            channelListener.onMessage = function (channel, message) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.MESSAGE,
                args: {
                  channel: channel,
                  message: message
                }
              });
            };

            channelListener.onDeleted = function (channelId) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.DELETE,
                args: {
                  channelId: channelId
                }
              });
            };

            channelListener.onMessageEdited = function (channel, user, message) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.EDIT_MESSAGE,
                args: {
                  channel: channel,
                  user: user,
                  message: message
                }
              });
            };

            channelListener.onMessageDeleted = function (channel, user, deletedMessage) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.DELETE_MESSAGE,
                args: {
                  channel: channel,
                  user: user,
                  deletedMessage: deletedMessage
                }
              });
            };

            channelListener.onReactionAdded = function (channel, user, message, reaction) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.REACTION_ADDED,
                args: {
                  channel: channel,
                  user: user,
                  message: message,
                  reaction: reaction
                }
              });
            };

            channelListener.onReactionDeleted = function (channel, user, message, reaction) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.REACTION_DELETED,
                args: {
                  channel: channel,
                  user: user,
                  message: message,
                  reaction: reaction
                }
              });
            };

            channelListener.onMemberStartedTyping = function (channel, from) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.START_TYPING,
                args: {
                  channel: channel,
                  from: from
                }
              });
            };

            channelListener.onMemberStoppedTyping = function (channel, from) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.STOP_TYPING,
                args: {
                  channel: channel,
                  from: from
                }
              });
            };

            channelListener.onReceivedMessageListMarker = function (channelId, markerList) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.MESSAGE_MARKERS_RECEIVED,
                args: {
                  channelId: channelId,
                  markerList: markerList
                }
              });
            };

            channelListener.onTotalUnreadCountUpdated = function (channel, unreadChannels, totalUnread, channelUnreadCount) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.UNREAD_MESSAGES_INFO,
                args: {
                  channel: channel,
                  unreadChannels: unreadChannels,
                  totalUnread: totalUnread,
                  channelUnreadCount: channelUnreadCount
                }
              });
            };

            channelListener.onHidden = function (channel) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.HIDE,
                args: {
                  channel: channel
                }
              });
            };

            channelListener.onMuted = function (channel) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.MUTE,
                args: {
                  channel: channel
                }
              });
            };

            channelListener.onUnmuted = function (channel) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.UNMUTE,
                args: {
                  channel: channel
                }
              });
            };

            channelListener.onShown = function (channel) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.UNHIDE,
                args: {
                  channel: channel
                }
              });
            };

            connectionListener.onConnectionStatusChanged = function (status) {
              return emitter({
                type: CONNECTION_EVENT_TYPES.CONNECTION_STATUS_CHANGED,
                args: {
                  status: status
                }
              });
            };

            channelListener.onMarkedAsUnread = function (channel) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.CHANNEL_MARKED_AS_UNREAD,
                args: {
                  channel: channel
                }
              });
            };

            channelListener.onMarkedAsRead = function (channel) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.CHANNEL_MARKED_AS_READ,
                args: {
                  channel: channel
                }
              });
            };

            channelListener.onHistoryCleared = function (channel) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.CLEAR_HISTORY,
                args: {
                  channel: channel
                }
              });
            };

            channelListener.onDeletedAllMessages = function (channel) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.CLEAR_HISTORY,
                args: {
                  channel: channel
                }
              });
            };

            channelListener.onMembersRoleChanged = function (channel, members) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.CHANGE_ROLE,
                args: {
                  channel: channel,
                  members: members
                }
              });
            };

            channelListener.onOwnerChanged = function (channel, newOwner, oldOwner) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.CHANGE_OWNER,
                args: {
                  channel: channel,
                  newOwner: newOwner,
                  oldOwner: oldOwner
                }
              });
            };

            channelListener.onMembersBlocked = function (channel, removedMembers) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.MEMBER_BLOCKED,
                args: {
                  channel: channel,
                  removedMembers: removedMembers
                }
              });
            };

            channelListener.onMembersUnblocked = function (channel, unblockedMembers) {
              return emitter({
                type: CHANNEL_EVENT_TYPES.MEMBER_UNBLOCKED,
                args: {
                  channel: channel,
                  unblockedMembers: unblockedMembers
                }
              });
            };

            SceytChatClient.addChannelListener('CHANNEL_EVENTS', channelListener);
            SceytChatClient.addConnectionListener('CONNECTION_EVENTS', connectionListener);
            return function () {
              SceytChatClient.removeChannelListener('CHANNEL_EVENTS');
              SceytChatClient.removeConnectionListener('CONNECTION_EVENTS');
            };
          });

        case 5:

          _context3.next = 8;
          return take(chan);

        case 8:
          _yield$take = _context3.sent;
          type = _yield$take.type;
          args = _yield$take.args;
          _context3.t0 = type;
          _context3.next = _context3.t0 === CHANNEL_EVENT_TYPES.CREATE ? 14 : _context3.t0 === CHANNEL_EVENT_TYPES.JOIN ? 25 : _context3.t0 === CHANNEL_EVENT_TYPES.LEAVE ? 32 : _context3.t0 === CHANNEL_EVENT_TYPES.BLOCK ? 41 : _context3.t0 === CHANNEL_EVENT_TYPES.UNBLOCK ? 48 : _context3.t0 === CHANNEL_EVENT_TYPES.KICK_MEMBERS ? 50 : _context3.t0 === CHANNEL_EVENT_TYPES.ADD_MEMBERS ? 75 : _context3.t0 === CHANNEL_EVENT_TYPES.UPDATE_CHANNEL ? 91 : _context3.t0 === CHANNEL_EVENT_TYPES.MESSAGE ? 98 : _context3.t0 === CHANNEL_EVENT_TYPES.MESSAGE_MARKERS_RECEIVED ? 135 : _context3.t0 === CHANNEL_EVENT_TYPES.START_TYPING ? 139 : _context3.t0 === CHANNEL_EVENT_TYPES.STOP_TYPING ? 143 : _context3.t0 === CHANNEL_EVENT_TYPES.DELETE ? 148 : _context3.t0 === CHANNEL_EVENT_TYPES.DELETE_MESSAGE ? 168 : _context3.t0 === CHANNEL_EVENT_TYPES.EDIT_MESSAGE ? 184 : _context3.t0 === CHANNEL_EVENT_TYPES.REACTION_ADDED ? 197 : _context3.t0 === CHANNEL_EVENT_TYPES.REACTION_DELETED ? 205 : _context3.t0 === CHANNEL_EVENT_TYPES.UNREAD_MESSAGES_INFO ? 213 : _context3.t0 === CHANNEL_EVENT_TYPES.CLEAR_HISTORY ? 219 : _context3.t0 === CHANNEL_EVENT_TYPES.MUTE ? 236 : _context3.t0 === CHANNEL_EVENT_TYPES.UNMUTE ? 241 : _context3.t0 === CHANNEL_EVENT_TYPES.HIDE ? 246 : _context3.t0 === CHANNEL_EVENT_TYPES.UNHIDE ? 251 : _context3.t0 === CHANNEL_EVENT_TYPES.CHANNEL_MARKED_AS_UNREAD ? 256 : _context3.t0 === CHANNEL_EVENT_TYPES.CHANNEL_MARKED_AS_READ ? 260 : _context3.t0 === CHANNEL_EVENT_TYPES.CHANGE_ROLE ? 264 : _context3.t0 === CONNECTION_EVENT_TYPES.CONNECTION_STATUS_CHANGED ? 271 : 275;
          break;

        case 14:
          createdChannel = args.createdChannel;
          console.log('CHANNEL_EVENT_CREATE ... ', createdChannel);
          channelExists = checkChannelExists(createdChannel.id);

          if (channelExists) {
            _context3.next = 24;
            break;
          }

          _context3.next = 20;
          return put(getContactsAC());

        case 20:
          _context3.next = 22;
          return call(setChannelInMap, createdChannel);

        case 22:
          _context3.next = 24;
          return put(setChannelToAddAC(JSON.parse(JSON.stringify(createdChannel))));

        case 24:
          return _context3.abrupt("break", 276);

        case 25:
          channel = args.channel;
          console.log('channel JOIN ... ', channel);
          _context3.next = 29;
          return call(getActiveChannelId);

        case 29:

          return _context3.abrupt("break", 276);

        case 32:
          console.log('channel LEAVE ... ');
          _channel = args.channel, member = args.member;
          _context3.next = 36;
          return call(getActiveChannelId);

        case 36:
          _activeChannelId = _context3.sent;

          if (!(_activeChannelId === _channel.id)) {
            _context3.next = 40;
            break;
          }

          _context3.next = 40;
          return put(removeMemberFromListAC([member]));

        case 40:
          return _context3.abrupt("break", 276);

        case 41:
          console.log('channel BLOCK ... ');
          _channel2 = args.channel;
          _channelExists = checkChannelExists(_channel2.id);

          if (!_channelExists) {
            _context3.next = 47;
            break;
          }

          _context3.next = 47;
          return put(removeChannelAC(_channel2.id));

        case 47:
          return _context3.abrupt("break", 276);

        case 48:
          console.log('channel UNBLOCK ... ');
          return _context3.abrupt("break", 276);

        case 50:
          _channel3 = args.channel, removedMembers = args.removedMembers;
          console.log('channel KICK_MEMBERS ... ', removedMembers);
          _context3.next = 54;
          return call(getActiveChannelId);

        case 54:
          _activeChannelId2 = _context3.sent;

          if (!(removedMembers[0].id === SceytChatClient.chatClient.user.id)) {
            _context3.next = 71;
            break;
          }

          _channelExists2 = checkChannelExists(_channel3.id);
          console.log('channelExists ... ', _channelExists2);

          if (!_channelExists2) {
            _context3.next = 69;
            break;
          }

          _context3.next = 61;
          return call(removeChannelFromMap, _channel3.id);

        case 61:
          _context3.next = 63;
          return put(removeChannelAC(_channel3.id));

        case 63:
          _context3.next = 65;
          return call(getLastChannelFromMap);

        case 65:
          activeChannel = _context3.sent;

          if (!activeChannel) {
            _context3.next = 69;
            break;
          }

          _context3.next = 69;
          return put(switchChannelActionAC(JSON.parse(JSON.stringify(activeChannel))));

        case 69:
          _context3.next = 74;
          break;

        case 71:
          if (!(_activeChannelId2 === _channel3.id)) {
            _context3.next = 74;
            break;
          }

          _context3.next = 74;
          return put(updateChannelDataAC(_channel3.id, {
            memberCount: _channel3.memberCount
          }));

        case 74:
          return _context3.abrupt("break", 276);

        case 75:
          _channel4 = args.channel;
          console.log('channel ADD_MEMBERS ... ');
          _context3.next = 79;
          return call(getActiveChannelId);

        case 79:
          _activeChannelId3 = _context3.sent;
          _channelExists3 = checkChannelExists(_channel4.id);

          if (_channelExists3) {
            _context3.next = 87;
            break;
          }

          console.log('event call set addedTp');
          _context3.next = 85;
          return call(setChannelInMap, _channel4);

        case 85:
          _context3.next = 87;
          return put(setAddedToChannelAC(JSON.parse(JSON.stringify(_channel4))));

        case 87:
          if (!(_activeChannelId3 === _channel4.id)) {
            _context3.next = 90;
            break;
          }

          _context3.next = 90;
          return put(updateChannelDataAC(_channel4.id, {
            memberCount: _channel4.memberCount
          }));

        case 90:
          return _context3.abrupt("break", 276);

        case 91:
          updatedChannel = args.updatedChannel;
          _channelExists4 = checkChannelExists(updatedChannel.id);

          if (!_channelExists4) {
            _context3.next = 97;
            break;
          }

          subject = updatedChannel.subject, avatarUrl = updatedChannel.avatarUrl;
          _context3.next = 97;
          return put(updateChannelDataAC(updatedChannel.id, {
            subject: subject,
            avatarUrl: avatarUrl
          }));

        case 97:
          return _context3.abrupt("break", 276);

        case 98:
          _channel5 = args.channel, message = args.message;
          _context3.next = 101;
          return call(getActiveChannelId);

        case 101:
          _activeChannelId4 = _context3.sent;
          _channelExists5 = checkChannelExists(_channel5.id);
          channelForAdd = JSON.parse(JSON.stringify(_channel5));
          _context3.next = 106;
          return put(addChannelAC(channelForAdd));

        case 106:
          if (_channelExists5) {
            _context3.next = 111;
            break;
          }

          _context3.next = 109;
          return call(setChannelInMap, _channel5);

        case 109:
          _context3.next = 116;
          break;

        case 111:
          if (message.repliedInThread) {
            _context3.next = 116;
            break;
          }

          _context3.next = 114;
          return put(updateChannelLastMessageAC(message, channelForAdd));

        case 114:
          _context3.next = 116;
          return put(updateChannelDataAC(message, channelForAdd));

        case 116:
          if (!(_channel5.id === _activeChannelId4)) {
            _context3.next = 122;
            break;
          }

          if (getHasNextCached()) {
            _context3.next = 120;
            break;
          }

          _context3.next = 120;
          return put(addMessageAC(message));

        case 120:
          addAllMessages([message], MESSAGE_LOAD_DIRECTION.NEXT);

        case 122:
          if (getMessagesFromMap(_channel5.id) && getMessagesFromMap(_channel5.id).length) {
            addMessageToMap(_channel5.id, message);
          }

          _context3.next = 125;
          return put(updateChannelDataAC(_channel5.id, _extends({}, channelForAdd)));

        case 125:
          if (!(message.user.id !== SceytChatClient.chatClient.user.id)) {
            _context3.next = 134;
            break;
          }

          if (Notification.permission === 'granted') {
            if (document.visibilityState !== 'visible' || _channel5.id !== _activeChannelId4) {
              setNotification(message.body, message.user, _channel5);
            }
          }

          if (!(message.repliedInThread && message.parent.id)) {
            _context3.next = 132;
            break;
          }

          _context3.next = 130;
          return put(markMessagesAsDeliveredAC(message.parent.id, [message.id]));

        case 130:
          _context3.next = 134;
          break;

        case 132:
          _context3.next = 134;
          return put(markMessagesAsDeliveredAC(_channel5.id, [message.id]));

        case 134:
          return _context3.abrupt("break", 276);

        case 135:
          return _context3.delegateYield( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var channelId, markerList, channel, _activeChannelId5, lastMessage, updateLastMessage, markersMap;

            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    channelId = args.channelId, markerList = args.markerList;
                    console.log('channel MESSAGE_MARKERS_RECEIVED ...', channelId, markerList);
                    _context.next = 4;
                    return call(getChannelFromMap, channelId);

                  case 4:
                    channel = _context.sent;

                    if (!channel) {
                      _context.next = 22;
                      break;
                    }

                    _context.next = 8;
                    return call(getActiveChannelId);

                  case 8:
                    _activeChannelId5 = _context.sent;
                    lastMessage = _extends({}, channel.lastMessage, {
                      deliveryStatus: markerList.name
                    });
                    updateLastMessage = false;
                    markerList.messageIds.forEach(function (messageId) {
                      if (channel.lastMessage && messageId === channel.lastMessage.id) {
                        updateLastMessage = true;
                      }
                    });

                    if (!updateLastMessage) {
                      _context.next = 15;
                      break;
                    }

                    _context.next = 15;
                    return put(updateChannelLastMessageStatusAC(lastMessage, JSON.parse(JSON.stringify(channel))));

                  case 15:
                    markersMap = {};
                    markerList.messageIds.forEach(function (messageId) {
                      return markersMap[messageId] = true;
                    });

                    if (!(_activeChannelId5 === channelId)) {
                      _context.next = 21;
                      break;
                    }

                    _context.next = 20;
                    return put(updateMessagesStatusAC(markerList.name, markersMap));

                  case 20:
                    updateMarkersOnAllMessages(markersMap, markerList.name);

                  case 21:
                    updateMessageStatusOnMap(channel.id, {
                      name: markerList.name,
                      markersMap: markersMap
                    });

                  case 22:
                    return _context.abrupt("return", "break");

                  case 23:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          })(), "t1", 136);

        case 136:
          _ret = _context3.t1;

          if (!(_ret === "break")) {
            _context3.next = 139;
            break;
          }

          return _context3.abrupt("break", 276);

        case 139:
          return _context3.delegateYield( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
            var channel, from;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    channel = args.channel, from = args.from;

                    if (typingUsersTimeout[from.id]) {
                      clearTimeout(typingUsersTimeout[from.id]);
                    }

                    typingUsersTimeout[from.id] = setTimeout(function () {
                      channelListener.onMemberStoppedTyping(channel, from);
                    }, 4000);
                    _context2.next = 5;
                    return put(switchTypingIndicatorAC(true, channel.id, from));

                  case 5:
                    return _context2.abrupt("return", "break");

                  case 6:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          })(), "t2", 140);

        case 140:
          _ret2 = _context3.t2;

          if (!(_ret2 === "break")) {
            _context3.next = 143;
            break;
          }

          return _context3.abrupt("break", 276);

        case 143:
          _channel6 = args.channel, from = args.from;

          if (typingUsersTimeout[from.id]) {
            clearTimeout(typingUsersTimeout[from.id]);
          }

          _context3.next = 147;
          return put(switchTypingIndicatorAC(false, _channel6.id, from));

        case 147:
          return _context3.abrupt("break", 276);

        case 148:
          channelId = args.channelId;
          console.log('channel DELETE ... ');
          _context3.next = 152;
          return call(getActiveChannelId);

        case 152:
          _activeChannelId6 = _context3.sent;
          _channel7 = getChannelFromMap(channelId);

          if (!_channel7) {
            _context3.next = 159;
            break;
          }

          _context3.next = 157;
          return put(removeChannelAC(channelId));

        case 157:
          _context3.next = 159;
          return call(removeChannelFromMap, channelId);

        case 159:
          _context3.next = 161;
          return put(setChannelToRemoveAC(_channel7));

        case 161:
          if (!(_activeChannelId6 === channelId)) {
            _context3.next = 167;
            break;
          }

          _context3.next = 164;
          return call(getLastChannelFromMap);

        case 164:
          _activeChannel = _context3.sent;
          _context3.next = 167;
          return put(switchChannelActionAC(JSON.parse(JSON.stringify(_activeChannel))));

        case 167:
          return _context3.abrupt("break", 276);

        case 168:
          _channel8 = args.channel, deletedMessage = args.deletedMessage;
          _activeChannelId7 = getActiveChannelId();
          console.log('channel DELETE_MESSAGE ... ');
          _channelExists6 = checkChannelExists(_channel8.id);

          if (!(_channel8.id === _activeChannelId7)) {
            _context3.next = 176;
            break;
          }

          updateMessageOnAllMessages(deletedMessage.id, deletedMessage);
          _context3.next = 176;
          return put(updateMessageAC(deletedMessage.id, deletedMessage));

        case 176:
          updateMessageOnMap(_channel8.id, {
            messageId: deletedMessage.id,
            params: deletedMessage
          });

          if (!_channelExists6) {
            _context3.next = 183;
            break;
          }

          _context3.next = 180;
          return put(updateChannelDataAC(_channel8.id, {
            unreadMessageCount: _channel8.unreadMessageCount
          }));

        case 180:
          if (!(_channel8.lastMessage.id === deletedMessage.id)) {
            _context3.next = 183;
            break;
          }

          _context3.next = 183;
          return put(updateChannelLastMessageAC(deletedMessage, _channel8));

        case 183:
          return _context3.abrupt("break", 276);

        case 184:
          _channel9 = args.channel, _message = args.message;
          console.log('channel EDIT_MESSAGE ... ');
          _activeChannelId8 = getActiveChannelId();
          _channelExists7 = checkChannelExists(_channel9.id);

          if (!(_channel9.id === _activeChannelId8)) {
            _context3.next = 191;
            break;
          }

          _context3.next = 191;
          return put(updateMessageAC(_message.id, {
            body: _message.body,
            state: _message.state,
            attachments: _message.attachments
          }));

        case 191:
          if (!_channelExists7) {
            _context3.next = 195;
            break;
          }

          if (!(_channel9.lastMessage.id === _message.id)) {
            _context3.next = 195;
            break;
          }

          _context3.next = 195;
          return put(updateChannelLastMessageAC(_message, _channel9));

        case 195:
          if (checkChannelExistsOnMessagesMap(_channel9.id)) {
            updateMessageOnMap(_channel9.id, {
              messageId: _message.id,
              params: _message
            });
          }

          return _context3.abrupt("break", 276);

        case 197:
          console.log('channel REACTION_ADDED ... ');
          _channel10 = args.channel, user = args.user, _message2 = args.message, reaction = args.reaction;
          isSelf = user.id === SceytChatClient.chatClient.user.id;
          _activeChannelId9 = getActiveChannelId();

          if (!(_channel10.id === _activeChannelId9)) {
            _context3.next = 204;
            break;
          }

          _context3.next = 204;
          return put(addReactionToMessageAC(_message2, reaction, isSelf));

        case 204:
          return _context3.abrupt("break", 276);

        case 205:
          _channel11 = args.channel, _user = args.user, _message3 = args.message, _reaction = args.reaction;
          console.log('channel REACTION_DELETED ... ');
          _isSelf = _user.id === SceytChatClient.chatClient.user.id;
          _activeChannelId10 = getActiveChannelId();

          if (!(_channel11.id === _activeChannelId10)) {
            _context3.next = 212;
            break;
          }

          _context3.next = 212;
          return put(deleteReactionFromMessageAC(_message3, _reaction, _isSelf));

        case 212:
          return _context3.abrupt("break", 276);

        case 213:
          _channel12 = args.channel, channelUnreadCount = args.channelUnreadCount;
          console.log('channel UNREAD_MESSAGES_INFO .', channelUnreadCount);
          _updatedChannel = JSON.parse(JSON.stringify(_channel12));
          _context3.next = 218;
          return put(updateChannelDataAC(_channel12.id, _updatedChannel));

        case 218:
          return _context3.abrupt("break", 276);

        case 219:
          _channel13 = args.channel;
          console.log('CLEAR_HISTORY: ', _channel13);
          _context3.next = 223;
          return call(getActiveChannelId);

        case 223:
          _activeChannelId11 = _context3.sent;
          _context3.next = 226;
          return call(checkChannelExists, _channel13.id);

        case 226:
          channelExist = _context3.sent;

          if (!(_channel13.id === _activeChannelId11)) {
            _context3.next = 231;
            break;
          }

          _context3.next = 230;
          return put(clearMessagesAC());

        case 230:
          removeAllMessages();

        case 231:
          removeMessagesFromMap(_channel13.id);

          if (!channelExist) {
            _context3.next = 235;
            break;
          }

          _context3.next = 235;
          return put(updateChannelDataAC(_channel13.id, {
            lastMessage: {},
            unreadMessageCount: 0
          }));

        case 235:
          return _context3.abrupt("break", 276);

        case 236:
          _channel14 = args.channel;
          console.log('channel MUTE ... ');
          _context3.next = 240;
          return put(updateChannelDataAC(_channel14.id, {
            muted: _channel14.muted,
            muteExpireDate: _channel14.muteExpireDate
          }));

        case 240:
          return _context3.abrupt("break", 276);

        case 241:
          _channel15 = args.channel;
          console.log('channel UNMUTE ... ');
          _context3.next = 245;
          return put(updateChannelDataAC(_channel15.id, {
            muted: _channel15.muted,
            muteExpireDate: _channel15.muteExpireDate
          }));

        case 245:
          return _context3.abrupt("break", 276);

        case 246:
          _channel16 = args.channel;
          console.log('channel HIDE ... ');
          _context3.next = 250;
          return put(setChannelToHideAC(_channel16));

        case 250:
          return _context3.abrupt("break", 276);

        case 251:
          _channel17 = args.channel;
          console.log('channel UNHIDE ... ');
          _context3.next = 255;
          return put(setChannelToUnHideAC(_channel17));

        case 255:
          return _context3.abrupt("break", 276);

        case 256:
          _channel18 = args.channel;
          _context3.next = 259;
          return put(updateChannelDataAC(_channel18.id, {
            markedAsUnread: _channel18.markedAsUnread
          }));

        case 259:
          return _context3.abrupt("break", 276);

        case 260:
          _channel19 = args.channel;
          _context3.next = 263;
          return put(updateChannelDataAC(_channel19.id, {
            markedAsUnread: _channel19.markedAsUnread
          }));

        case 263:
          return _context3.abrupt("break", 276);

        case 264:
          console.log('channel CHANGE_ROLE ... ');
          _context3.next = 268;
          return call(getActiveChannelId);

        case 268:

          return _context3.abrupt("break", 276);

        case 271:
          status = args.status;
          _context3.next = 274;
          return put(setConnectionStatusAC(status));

        case 274:
          return _context3.abrupt("break", 276);

        case 275:
          console.warn('UNHANDLED EVENT FROM REDUX-SAGA EVENT-CHANNEL');

        case 276:
          _context3.next = 5;
          break;

        case 278:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked);
}

var _marked$1 = /*#__PURE__*/_regeneratorRuntime().mark(createChannel),
    _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(getChannels),
    _marked3 = /*#__PURE__*/_regeneratorRuntime().mark(getChannelsForForward),
    _marked4 = /*#__PURE__*/_regeneratorRuntime().mark(channelsLoadMore),
    _marked5 = /*#__PURE__*/_regeneratorRuntime().mark(channelsForForwardLoadMore),
    _marked6 = /*#__PURE__*/_regeneratorRuntime().mark(markMessagesRead),
    _marked7 = /*#__PURE__*/_regeneratorRuntime().mark(markMessagesDelivered),
    _marked8 = /*#__PURE__*/_regeneratorRuntime().mark(switchChannel),
    _marked9 = /*#__PURE__*/_regeneratorRuntime().mark(notificationsTurnOff),
    _marked10 = /*#__PURE__*/_regeneratorRuntime().mark(notificationsTurnOn),
    _marked11 = /*#__PURE__*/_regeneratorRuntime().mark(markChannelAsRead),
    _marked12 = /*#__PURE__*/_regeneratorRuntime().mark(markChannelAsUnRead),
    _marked13 = /*#__PURE__*/_regeneratorRuntime().mark(removeChannelCaches),
    _marked14 = /*#__PURE__*/_regeneratorRuntime().mark(leaveChannel),
    _marked15 = /*#__PURE__*/_regeneratorRuntime().mark(deleteChannel),
    _marked16 = /*#__PURE__*/_regeneratorRuntime().mark(blockChannel),
    _marked17 = /*#__PURE__*/_regeneratorRuntime().mark(updateChannel),
    _marked18 = /*#__PURE__*/_regeneratorRuntime().mark(checkUsersStatus),
    _marked19 = /*#__PURE__*/_regeneratorRuntime().mark(sendTyping),
    _marked20 = /*#__PURE__*/_regeneratorRuntime().mark(clearHistory),
    _marked21 = /*#__PURE__*/_regeneratorRuntime().mark(deleteAllMessages),
    _marked22 = /*#__PURE__*/_regeneratorRuntime().mark(joinChannel),
    _marked23 = /*#__PURE__*/_regeneratorRuntime().mark(watchForChannelEvents),
    _marked24 = /*#__PURE__*/_regeneratorRuntime().mark(ChannelsSaga);

function createChannel(action) {
  var payload, channelData, SceytChatClient, createChannelData, fileToUpload, createdChannel, checkChannelExist, messageToSend;
  return _regeneratorRuntime().wrap(function createChannel$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          payload = action.payload;
          channelData = payload.channelData;
          SceytChatClient = getClient();
          createChannelData = _extends({}, channelData);

          if (!createChannelData.avatarFile) {
            _context.next = 11;
            break;
          }

          fileToUpload = {
            data: createChannelData.avatarFile,
            progress: function progress(progressPercent) {
              console.log('upload percent - ', progressPercent);
            }
          };
          _context.next = 9;
          return call(SceytChatClient.chatClient.uploadFile, fileToUpload);

        case 9:
          createChannelData.avatarUrl = _context.sent;
          delete createChannelData.avatarFile;

        case 11:
          _context.next = 13;
          return call(SceytChatClient.chatClient[channelData.type + "Channel"].create, createChannelData);

        case 13:
          createdChannel = _context.sent;
          checkChannelExist = false;

          if (!(createdChannel.type === CHANNEL_TYPE.DIRECT)) {
            _context.next = 19;
            break;
          }

          _context.next = 18;
          return call(checkChannelExists, createdChannel.id);

        case 18:
          checkChannelExist = _context.sent;

        case 19:
          if (checkChannelExist) {
            _context.next = 28;
            break;
          }

          _context.next = 22;
          return call(setChannelInMap, createdChannel);

        case 22:
          if (!(createdChannel.type !== CHANNEL_TYPE.DIRECT)) {
            _context.next = 26;
            break;
          }

          messageToSend = {
            body: createdChannel.type === CHANNEL_TYPE.PUBLIC ? 'CC' : 'CG',
            mentionedMembers: [],
            attachments: [],
            type: 'system'
          };
          _context.next = 26;
          return put(sendTextMessageAC(messageToSend, createdChannel.id, CONNECTION_STATUS.CONNECTED));

        case 26:
          _context.next = 28;
          return put(addChannelAC(JSON.parse(JSON.stringify(createdChannel))));

        case 28:
          _context.next = 30;
          return put(switchChannelActionAC(JSON.parse(JSON.stringify(createdChannel))));

        case 30:
          _context.next = 32;
          return call(setActiveChannelId, createdChannel.id);

        case 32:
          _context.next = 37;
          break;

        case 34:
          _context.prev = 34;
          _context.t0 = _context["catch"](0);
          console.log(_context.t0, 'Error on create channel');

        case 37:
        case "end":
          return _context.stop();
      }
    }
  }, _marked$1, null, [[0, 34]]);
}

function getChannels(action) {
  var payload, params, SceytChatClient, searchBy, directChannelQueryBuilder, directChannelQuery, directChannelsData, groupChannelQueryBuilder, groupChannelQuery, groupChannelsData, allChannels, mappedChannels, channelQueryBuilder, channelQuery, channelsData, channelId, activeChannel, _mappedChannels, _channelsData$channel;

  return _regeneratorRuntime().wrap(function getChannels$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          payload = action.payload;
          params = payload.params;
          SceytChatClient = getClient();
          _context2.next = 6;
          return put(setChannelsLoadingStateAC(LOADING_STATE.LOADING));

        case 6:
          searchBy = params.search;

          if (!searchBy) {
            _context2.next = 39;
            break;
          }

          directChannelQueryBuilder = new SceytChatClient.chatClient.ChannelListQueryBuilder();
          directChannelQueryBuilder.direct();
          directChannelQueryBuilder.userContains(searchBy);
          directChannelQueryBuilder.sortByLastMessage();
          directChannelQueryBuilder.limit(10);
          _context2.next = 15;
          return call(directChannelQueryBuilder.build);

        case 15:
          directChannelQuery = _context2.sent;
          _context2.next = 18;
          return call(directChannelQuery.loadNextPage);

        case 18:
          directChannelsData = _context2.sent;
          groupChannelQueryBuilder = new SceytChatClient.chatClient.ChannelListQueryBuilder();
          groupChannelQueryBuilder.subjectContains(searchBy);
          groupChannelQueryBuilder.sortByLastMessage();
          groupChannelQueryBuilder.limit(20);
          _context2.next = 25;
          return call(groupChannelQueryBuilder.build);

        case 25:
          groupChannelQuery = _context2.sent;
          _context2.next = 28;
          return call(groupChannelQuery.loadNextPage);

        case 28:
          groupChannelsData = _context2.sent;
          allChannels = directChannelsData.channels.concat(groupChannelsData.channels);
          _context2.next = 32;
          return call(destroyChannelsMap);

        case 32:
          _context2.next = 34;
          return call(setChannelsInMap, allChannels);

        case 34:
          mappedChannels = _context2.sent;
          _context2.next = 37;
          return put(setChannelsAC(mappedChannels));

        case 37:
          _context2.next = 88;
          break;

        case 39:
          channelQueryBuilder = new SceytChatClient.chatClient.ChannelListQueryBuilder();

          if (!(params.filter && params.filter.channelType)) {
            _context2.next = 55;
            break;
          }

          console.log('params.filter.channelType ... ', params.filter.channelType);

          if (!(params.filter.channelType.toLowerCase() === 'direct')) {
            _context2.next = 46;
            break;
          }

          channelQueryBuilder.direct();
          _context2.next = 55;
          break;

        case 46:
          if (!(params.filter.channelType.toLowerCase() === 'public')) {
            _context2.next = 50;
            break;
          }

          channelQueryBuilder["public"]();
          _context2.next = 55;
          break;

        case 50:
          if (!(params.filter.channelType.toLowerCase() === 'private')) {
            _context2.next = 54;
            break;
          }

          channelQueryBuilder["private"]();
          _context2.next = 55;
          break;

        case 54:
          throw new Error('Bad filter type');

        case 55:
          channelQueryBuilder.sortByLastMessage();
          channelQueryBuilder.limit(params.limit || 20);
          _context2.next = 59;
          return call(channelQueryBuilder.build);

        case 59:
          channelQuery = _context2.sent;
          _context2.next = 62;
          return call(channelQuery.loadNextPage);

        case 62:
          channelsData = _context2.sent;
          _context2.next = 65;
          return put(channelHasNextAC(channelsData.hasNext));

        case 65:
          _context2.next = 67;
          return call(getActiveChannelId);

        case 67:
          channelId = _context2.sent;

          if (!channelId) {
            _context2.next = 74;
            break;
          }

          _context2.next = 71;
          return call(getChannelFromMap, channelId);

        case 71:
          _context2.t0 = _context2.sent;
          _context2.next = 75;
          break;

        case 74:
          _context2.t0 = null;

        case 75:
          activeChannel = _context2.t0;
          _context2.next = 78;
          return call(destroyChannelsMap);

        case 78:
          _context2.next = 80;
          return call(setChannelsInMap, channelsData.channels);

        case 80:
          _mappedChannels = _context2.sent;
          _context2.next = 83;
          return put(setChannelsAC(_mappedChannels));

        case 83:
          if (!channelId) {
            _channelsData$channel = channelsData.channels;
            activeChannel = _channelsData$channel[0];
          }

          query.channelQuery = channelQuery;

          if (!activeChannel) {
            _context2.next = 88;
            break;
          }

          _context2.next = 88;
          return put(switchChannelActionAC(JSON.parse(JSON.stringify(activeChannel))));

        case 88:
          _context2.next = 90;
          return put(setChannelsLoadingStateAC(LOADING_STATE.LOADED));

        case 90:
          _context2.next = 96;
          break;

        case 92:
          _context2.prev = 92;
          _context2.t1 = _context2["catch"](0);
          console.log(_context2.t1, 'Error on get channels');

        case 96:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[0, 92]]);
}

function getChannelsForForward(action) {
  var payload, searchValue, SceytChatClient, directChannelQueryBuilder, directChannelQuery, directChannelsData, directChannelsToAdd, groupChannelQueryBuilder, groupChannelQuery, groupChannelsData, groupChannelsToAdd, allChannels, mappedChannels, channelQueryBuilder, channelQuery, channelsData, channelsToAdd, _mappedChannels2;

  return _regeneratorRuntime().wrap(function getChannelsForForward$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.prev = 0;
          payload = action.payload;
          searchValue = payload.searchValue;
          SceytChatClient = getClient();
          _context3.next = 6;
          return put(setChannelsLoadingStateAC(LOADING_STATE.LOADING, true));

        case 6:
          if (!searchValue) {
            _context3.next = 40;
            break;
          }

          directChannelQueryBuilder = new SceytChatClient.chatClient.ChannelListQueryBuilder();
          directChannelQueryBuilder.direct();
          directChannelQueryBuilder.userContains(searchValue);
          directChannelQueryBuilder.sortByLastMessage();
          directChannelQueryBuilder.limit(10);
          _context3.next = 14;
          return call(directChannelQueryBuilder.build);

        case 14:
          directChannelQuery = _context3.sent;
          _context3.next = 17;
          return call(directChannelQuery.loadNextPage);

        case 17:
          directChannelsData = _context3.sent;
          directChannelsToAdd = directChannelsData.channels.filter(function (channel) {
            return !!(channel.peer && channel.peer.id);
          });
          groupChannelQueryBuilder = new SceytChatClient.chatClient.ChannelListQueryBuilder();
          groupChannelQueryBuilder.subjectContains(searchValue);
          groupChannelQueryBuilder.sortByLastMessage();
          groupChannelQueryBuilder.limit(20);
          _context3.next = 25;
          return call(groupChannelQueryBuilder.build);

        case 25:
          groupChannelQuery = _context3.sent;
          _context3.next = 28;
          return call(groupChannelQuery.loadNextPage);

        case 28:
          groupChannelsData = _context3.sent;
          groupChannelsToAdd = groupChannelsData.channels.filter(function (channel) {
            return channel.type === CHANNEL_TYPE.PUBLIC ? channel.role === 'admin' || channel.role === 'owner' : true;
          });
          allChannels = directChannelsToAdd.concat(groupChannelsToAdd);
          _context3.next = 33;
          return call(setChannelsInMap, allChannels);

        case 33:
          mappedChannels = _context3.sent;
          _context3.next = 36;
          return put(setChannelsFroForwardAC(mappedChannels));

        case 36:
          _context3.next = 38;
          return put(channelHasNextAC(false, true));

        case 38:
          _context3.next = 58;
          break;

        case 40:
          channelQueryBuilder = new SceytChatClient.chatClient.ChannelListQueryBuilder();
          channelQueryBuilder.sortByLastMessage();
          channelQueryBuilder.limit(20);
          _context3.next = 45;
          return call(channelQueryBuilder.build);

        case 45:
          channelQuery = _context3.sent;
          _context3.next = 48;
          return call(channelQuery.loadNextPage);

        case 48:
          channelsData = _context3.sent;
          _context3.next = 51;
          return put(channelHasNextAC(channelsData.hasNext, true));

        case 51:
          channelsToAdd = channelsData.channels.filter(function (channel) {
            return channel.type === CHANNEL_TYPE.PUBLIC ? channel.role === 'admin' || channel.role === 'owner' : channel.type === CHANNEL_TYPE.DIRECT ? channel.peer.id : true;
          });
          _context3.next = 54;
          return call(setChannelsInMap, channelsToAdd);

        case 54:
          _mappedChannels2 = _context3.sent;
          _context3.next = 57;
          return put(setChannelsFroForwardAC(_mappedChannels2));

        case 57:
          query.channelQueryForward = channelQuery;

        case 58:
          _context3.next = 60;
          return put(setChannelsLoadingStateAC(LOADING_STATE.LOADED, true));

        case 60:
          _context3.next = 66;
          break;

        case 62:
          _context3.prev = 62;
          _context3.t0 = _context3["catch"](0);
          console.log(_context3.t0, 'Error on get for forward channels');

        case 66:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, null, [[0, 62]]);
}

function channelsLoadMore(action) {
  var payload, limit, channelQuery, channelsData, mappedChannels;
  return _regeneratorRuntime().wrap(function channelsLoadMore$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.prev = 0;
          payload = action.payload;
          limit = payload.limit;
          channelQuery = query.channelQuery;

          if (limit) {
            channelQuery.limit = limit;
          }

          _context4.next = 7;
          return put(setChannelsLoadingStateAC(LOADING_STATE.LOADING));

        case 7:
          _context4.next = 9;
          return call(channelQuery.loadNextPage);

        case 9:
          channelsData = _context4.sent;
          _context4.next = 12;
          return put(channelHasNextAC(channelsData.hasNext));

        case 12:
          _context4.next = 14;
          return call(setChannelsInMap, channelsData.channels);

        case 14:
          mappedChannels = _context4.sent;
          _context4.next = 17;
          return put(addChannelsAC(mappedChannels));

        case 17:
          _context4.next = 19;
          return put(setChannelsLoadingStateAC(LOADING_STATE.LOADED));

        case 19:
          _context4.next = 24;
          break;

        case 21:
          _context4.prev = 21;
          _context4.t0 = _context4["catch"](0);
          console.log(_context4.t0, 'Error in load more channels');

        case 24:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, null, [[0, 21]]);
}

function channelsForForwardLoadMore(action) {
  var payload, limit, channelQueryForward, channelsData, channelsToAdd, mappedChannels;
  return _regeneratorRuntime().wrap(function channelsForForwardLoadMore$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.prev = 0;
          payload = action.payload;
          limit = payload.limit;
          channelQueryForward = query.channelQueryForward;

          if (limit) {
            channelQueryForward.limit = limit;
          }

          _context5.next = 7;
          return put(setChannelsLoadingStateAC(LOADING_STATE.LOADING));

        case 7:
          _context5.next = 9;
          return call(channelQueryForward.loadNextPage);

        case 9:
          channelsData = _context5.sent;
          _context5.next = 12;
          return put(channelHasNextAC(channelsData.hasNext, true));

        case 12:
          channelsToAdd = channelsData.channels.filter(function (channel) {
            return channel.type === CHANNEL_TYPE.PUBLIC ? channel.role === 'admin' || channel.role === 'owner' : channel.type === CHANNEL_TYPE.DIRECT ? channel.peer.id : true;
          });
          _context5.next = 15;
          return call(setChannelsInMap, channelsToAdd);

        case 15:
          mappedChannels = _context5.sent;
          _context5.next = 18;
          return put(addChannelsForForwardAC(mappedChannels));

        case 18:
          _context5.next = 20;
          return put(setChannelsLoadingStateAC(LOADING_STATE.LOADED));

        case 20:
          _context5.next = 25;
          break;

        case 22:
          _context5.prev = 22;
          _context5.t0 = _context5["catch"](0);
          console.log(_context5.t0, 'Error in load more channels for forward');

        case 25:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5, null, [[0, 22]]);
}

function markMessagesRead(action) {
  var payload, channelId, messageIds, channel, markedMessageIds, _iterator, _step, messageId;

  return _regeneratorRuntime().wrap(function markMessagesRead$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          payload = action.payload;
          channelId = payload.channelId, messageIds = payload.messageIds;
          _context6.next = 4;
          return call(getChannelFromMap, channelId);

        case 4:
          channel = _context6.sent;

          if (!channel) {
            _context6.next = 18;
            break;
          }

          _context6.next = 8;
          return call(channel.markMessagesAsRead, messageIds);

        case 8:
          markedMessageIds = _context6.sent;
          _context6.next = 11;
          return put(updateChannelDataAC(channel.id, {
            markedAsUnread: channel.markedAsUnread,
            lastReadMessageId: channel.lastReadMessageId,
            unreadMessageCount: channel.unreadMessageCount
          }));

        case 11:
          _iterator = _createForOfIteratorHelperLoose(markedMessageIds);

        case 12:
          if ((_step = _iterator()).done) {
            _context6.next = 18;
            break;
          }

          messageId = _step.value;
          _context6.next = 16;
          return put(updateMessageAC(messageId, {
            deliveryStatus: MESSAGE_DELIVERY_STATUS.READ,
            selfMarkers: [MESSAGE_DELIVERY_STATUS.READ]
          }));

        case 16:
          _context6.next = 12;
          break;

        case 18:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6);
}

function markMessagesDelivered(action) {
  var payload, channelId, messageIds, channel;
  return _regeneratorRuntime().wrap(function markMessagesDelivered$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          payload = action.payload;
          channelId = payload.channelId, messageIds = payload.messageIds;
          _context7.next = 4;
          return call(getChannelFromMap, channelId);

        case 4:
          channel = _context7.sent;

          if (!channel) {
            _context7.next = 8;
            break;
          }

          _context7.next = 8;
          return call(channel.markMessagesAsDelivered, messageIds);

        case 8:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked7);
}

function switchChannel(action) {
  var payload, channel;
  return _regeneratorRuntime().wrap(function switchChannel$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _context8.prev = 0;
          payload = action.payload;
          channel = payload.channel;
          _context8.next = 5;
          return call(setUnreadScrollTo, true);

        case 5:
          _context8.next = 7;
          return call(setActiveChannelId, channel && channel.id);

        case 7:
          _context8.next = 9;
          return put(setActiveChannelAC(_extends({}, channel)));

        case 9:

          _context8.next = 15;
          break;

        case 12:
          _context8.prev = 12;
          _context8.t0 = _context8["catch"](0);
          console.log('error in switch channel');

        case 15:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked8, null, [[0, 12]]);
}

function notificationsTurnOff(action) {
  var expireTime, activeChannelId, channel, updatedChannel;
  return _regeneratorRuntime().wrap(function notificationsTurnOff$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          expireTime = action.payload.expireTime;
          _context9.next = 3;
          return call(getActiveChannelId);

        case 3:
          activeChannelId = _context9.sent;
          _context9.next = 6;
          return call(getChannelFromMap, activeChannelId);

        case 6:
          channel = _context9.sent;
          _context9.prev = 7;
          _context9.next = 10;
          return call(channel.mute, expireTime);

        case 10:
          updatedChannel = _context9.sent;
          _context9.next = 13;
          return put(updateChannelDataAC(updatedChannel.id, {
            muted: updatedChannel.muted,
            muteExpireDate: updatedChannel.muteExpireDate
          }));

        case 13:
          _context9.next = 18;
          break;

        case 15:
          _context9.prev = 15;
          _context9.t0 = _context9["catch"](7);
          console.log('ERROR turn off notifications', _context9.t0.message);

        case 18:
        case "end":
          return _context9.stop();
      }
    }
  }, _marked9, null, [[7, 15]]);
}

function notificationsTurnOn() {
  var activeChannelId, channel, updatedChannel;
  return _regeneratorRuntime().wrap(function notificationsTurnOn$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          _context10.next = 2;
          return call(getActiveChannelId);

        case 2:
          activeChannelId = _context10.sent;
          _context10.next = 5;
          return call(getChannelFromMap, activeChannelId);

        case 5:
          channel = _context10.sent;
          _context10.prev = 6;
          _context10.next = 9;
          return call(channel.unmute);

        case 9:
          updatedChannel = _context10.sent;
          _context10.next = 12;
          return put(updateChannelDataAC(updatedChannel.id, {
            muted: updatedChannel.muted,
            muteExpireDate: updatedChannel.muteExpireDate
          }));

        case 12:
          _context10.next = 17;
          break;

        case 14:
          _context10.prev = 14;
          _context10.t0 = _context10["catch"](6);
          console.log('ERROR turn on notifications: ', _context10.t0.message);

        case 17:
        case "end":
          return _context10.stop();
      }
    }
  }, _marked10, null, [[6, 14]]);
}

function markChannelAsRead(action) {
  var channelId, channel, updatedChannel;
  return _regeneratorRuntime().wrap(function markChannelAsRead$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          _context11.prev = 0;
          channelId = action.payload.channelId;
          _context11.next = 4;
          return call(getChannelFromMap, channelId);

        case 4:
          channel = _context11.sent;
          _context11.next = 7;
          return call(channel.markAsRead);

        case 7:
          updatedChannel = _context11.sent;
          _context11.next = 10;
          return put(updateChannelDataAC(channel.id, _extends({}, updatedChannel)));

        case 10:
          _context11.next = 15;
          break;

        case 12:
          _context11.prev = 12;
          _context11.t0 = _context11["catch"](0);
          console.log(_context11.t0, 'Error in set channel unread');

        case 15:
        case "end":
          return _context11.stop();
      }
    }
  }, _marked11, null, [[0, 12]]);
}

function markChannelAsUnRead(action) {
  var channelId, channel, updatedChannel;
  return _regeneratorRuntime().wrap(function markChannelAsUnRead$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          _context12.prev = 0;
          channelId = action.payload.channelId;
          _context12.next = 4;
          return call(getChannelFromMap, channelId);

        case 4:
          channel = _context12.sent;
          _context12.next = 7;
          return call(channel.markAsUnRead);

        case 7:
          updatedChannel = _context12.sent;
          console.log(' channel -- ', channel);
          console.log('updated channel -- ', updatedChannel);
          _context12.next = 12;
          return put(updateChannelDataAC(channel.id, _extends({}, updatedChannel)));

        case 12:
          _context12.next = 17;
          break;

        case 14:
          _context12.prev = 14;
          _context12.t0 = _context12["catch"](0);
          console.log(_context12.t0, 'Error in set channel unread');

        case 17:
        case "end":
          return _context12.stop();
      }
    }
  }, _marked12, null, [[0, 14]]);
}

function removeChannelCaches(action) {
  var payload, channelId, activeChannelId, activeChannel;
  return _regeneratorRuntime().wrap(function removeChannelCaches$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          payload = action.payload;
          channelId = payload.channelId;
          _context13.next = 4;
          return call(getActiveChannelId);

        case 4:
          activeChannelId = _context13.sent;
          removeChannelFromMap(channelId);
          removeMessagesFromMap(channelId);

          if (!(activeChannelId === channelId)) {
            _context13.next = 14;
            break;
          }

          _context13.next = 10;
          return call(getLastChannelFromMap);

        case 10:
          activeChannel = _context13.sent;

          if (!activeChannel) {
            _context13.next = 14;
            break;
          }

          _context13.next = 14;
          return put(switchChannelActionAC(JSON.parse(JSON.stringify(activeChannel))));

        case 14:
        case "end":
          return _context13.stop();
      }
    }
  }, _marked13);
}

function leaveChannel(action) {
  var payload, channelId, channel, messageBuilder, messageToSend;
  return _regeneratorRuntime().wrap(function leaveChannel$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          _context14.prev = 0;
          payload = action.payload;
          channelId = payload.channelId;
          _context14.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context14.sent;

          if (!channel) {
            _context14.next = 22;
            break;
          }

          if (!(channel.type === CHANNEL_TYPE.PRIVATE)) {
            _context14.next = 15;
            break;
          }

          messageBuilder = channel.createMessageBuilder();
          messageBuilder.setBody('LG').setType('system').setDisplayCount(0).setSilent(true);
          messageToSend = messageBuilder.create();

          console.log('send message for left');
          _context14.next = 15;
          return call(channel.sendMessage, messageToSend);

        case 15:
          console.log('leave');
          _context14.next = 18;
          return call(channel.leave);

        case 18:
          _context14.next = 20;
          return put(removeChannelAC(channelId));

        case 20:
          _context14.next = 22;
          return put(removeChannelCachesAC(channelId));

        case 22:
          _context14.next = 27;
          break;

        case 24:
          _context14.prev = 24;
          _context14.t0 = _context14["catch"](0);
          console.log('ERROR in leave channel - ', _context14.t0.message);

        case 27:
        case "end":
          return _context14.stop();
      }
    }
  }, _marked14, null, [[0, 24]]);
}

function deleteChannel(action) {
  var payload, channelId, channel;
  return _regeneratorRuntime().wrap(function deleteChannel$(_context15) {
    while (1) {
      switch (_context15.prev = _context15.next) {
        case 0:
          _context15.prev = 0;
          payload = action.payload;
          channelId = payload.channelId;
          _context15.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context15.sent;

          if (!channel) {
            _context15.next = 13;
            break;
          }

          _context15.next = 9;
          return call(channel["delete"]);

        case 9:
          _context15.next = 11;
          return put(removeChannelAC(channelId));

        case 11:
          _context15.next = 13;
          return put(removeChannelCachesAC(channelId));

        case 13:
          _context15.next = 18;
          break;

        case 15:
          _context15.prev = 15;
          _context15.t0 = _context15["catch"](0);
          console.log('ERROR in delete channel');

        case 18:
        case "end":
          return _context15.stop();
      }
    }
  }, _marked15, null, [[0, 15]]);
}

function blockChannel(action) {
  var payload, channelId, channel;
  return _regeneratorRuntime().wrap(function blockChannel$(_context16) {
    while (1) {
      switch (_context16.prev = _context16.next) {
        case 0:
          _context16.prev = 0;
          payload = action.payload;
          channelId = payload.channelId;
          _context16.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context16.sent;

          if (!channel) {
            _context16.next = 13;
            break;
          }

          _context16.next = 9;
          return call(channel.block);

        case 9:
          _context16.next = 11;
          return put(removeChannelAC(channelId));

        case 11:
          _context16.next = 13;
          return put(removeChannelCachesAC(channelId));

        case 13:
          _context16.next = 18;
          break;

        case 15:
          _context16.prev = 15;
          _context16.t0 = _context16["catch"](0);
          console.log('ERROR in block channel - ', _context16.t0.message);

        case 18:
        case "end":
          return _context16.stop();
      }
    }
  }, _marked16, null, [[0, 15]]);
}

function updateChannel(action) {
  var payload, channelId, config, SceytChatClient, channel, paramsToUpdate, fileToUpload, _yield$call, subject, avatarUrl, label, metadata;

  return _regeneratorRuntime().wrap(function updateChannel$(_context17) {
    while (1) {
      switch (_context17.prev = _context17.next) {
        case 0:
          _context17.prev = 0;
          payload = action.payload;
          channelId = payload.channelId, config = payload.config;
          SceytChatClient = getClient();
          _context17.next = 6;
          return call(getChannelFromMap, channelId);

        case 6:
          channel = _context17.sent;
          paramsToUpdate = {
            uri: channel.uri,
            subject: channel.subject,
            label: channel.label,
            metadata: channel.metadata,
            avatarUrl: channel.avatarUrl
          };

          if (!config.avatar) {
            _context17.next = 13;
            break;
          }

          fileToUpload = {
            data: config.avatar,
            progress: function progress(progressPercent) {
              console.log('upload percent - ', progressPercent);
            }
          };
          _context17.next = 12;
          return call(SceytChatClient.chatClient.uploadFile, fileToUpload);

        case 12:
          paramsToUpdate.avatarUrl = _context17.sent;

        case 13:
          if (config.subject) {
            paramsToUpdate.subject = config.subject;
          }

          if (config.metadata) {
            paramsToUpdate.metadata = JSON.stringify(config.metadata);
          }

          if (config.avatarUrl === '') {
            paramsToUpdate.avatarUrl = '';
          }

          _context17.next = 18;
          return call(channel.update, paramsToUpdate);

        case 18:
          _yield$call = _context17.sent;
          subject = _yield$call.subject;
          avatarUrl = _yield$call.avatarUrl;
          label = _yield$call.label;
          metadata = _yield$call.metadata;
          _context17.next = 25;
          return put(updateChannelDataAC(channelId, {
            subject: subject,
            avatarUrl: avatarUrl,
            label: label,
            metadata: metadata
          }));

        case 25:
          _context17.next = 30;
          break;

        case 27:
          _context17.prev = 27;
          _context17.t0 = _context17["catch"](0);
          console.log('ERROR in update channel', _context17.t0.message);

        case 30:
        case "end":
          return _context17.stop();
      }
    }
  }, _marked17, null, [[0, 27]]);
}

function checkUsersStatus(action) {
  var payload, usersMap, SceytChatClient, usersForUpdate, updatedUsers, usersToUpdateMap, update;
  return _regeneratorRuntime().wrap(function checkUsersStatus$(_context18) {
    while (1) {
      switch (_context18.prev = _context18.next) {
        case 0:
          _context18.prev = 0;
          payload = action.payload;
          usersMap = payload.usersMap;
          SceytChatClient = getClient();
          usersForUpdate = Object.keys(usersMap);
          _context18.next = 7;
          return call(SceytChatClient.chatClient.getUsers, usersForUpdate);

        case 7:
          updatedUsers = _context18.sent;
          usersToUpdateMap = {};
          update = false;
          updatedUsers.forEach(function (updatedUser) {
            if (updatedUser.presence && updatedUser.presence.state !== usersMap[updatedUser.id].state) {
              usersToUpdateMap[updatedUser.id] = updatedUser;
              update = true;
            }
          });

          if (!update) {
            _context18.next = 16;
            break;
          }

          _context18.next = 14;
          return put(updateMembersPresenceAC(Object.values(usersToUpdateMap)));

        case 14:
          _context18.next = 16;
          return put(updateUserStatusOnChannelAC(usersToUpdateMap));

        case 16:
          _context18.next = 21;
          break;

        case 18:
          _context18.prev = 18;
          _context18.t0 = _context18["catch"](0);
          console.log('ERROR in check user status : ', _context18.t0.message);

        case 21:
        case "end":
          return _context18.stop();
      }
    }
  }, _marked18, null, [[0, 18]]);
}

function sendTyping(action) {
  var state, activeChannelId, channel;
  return _regeneratorRuntime().wrap(function sendTyping$(_context19) {
    while (1) {
      switch (_context19.prev = _context19.next) {
        case 0:
          state = action.payload.state;
          _context19.next = 3;
          return call(getActiveChannelId);

        case 3:
          activeChannelId = _context19.sent;
          _context19.next = 6;
          return call(getChannelFromMap, activeChannelId);

        case 6:
          channel = _context19.sent;

          if (!channel) {
            _context19.next = 15;
            break;
          }

          if (!state) {
            _context19.next = 13;
            break;
          }

          _context19.next = 11;
          return call(channel.startTyping);

        case 11:
          _context19.next = 15;
          break;

        case 13:
          _context19.next = 15;
          return call(channel.stopTyping);

        case 15:
        case "end":
          return _context19.stop();
      }
    }
  }, _marked19);
}

function clearHistory(action) {
  var payload, channelId, channel, activeChannelId;
  return _regeneratorRuntime().wrap(function clearHistory$(_context20) {
    while (1) {
      switch (_context20.prev = _context20.next) {
        case 0:
          _context20.prev = 0;
          payload = action.payload;
          channelId = payload.channelId;
          _context20.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context20.sent;
          _context20.next = 8;
          return call(getActiveChannelId);

        case 8:
          activeChannelId = _context20.sent;

          if (!channel) {
            _context20.next = 18;
            break;
          }

          _context20.next = 12;
          return call(channel.deleteAllMessages, true);

        case 12:
          _context20.next = 14;
          return put(clearMessagesAC());

        case 14:
          removeMessagesFromMap(channelId);

          if (channelId === activeChannelId) {
            removeAllMessages();
          }

          _context20.next = 18;
          return put(updateChannelDataAC(channel.id, {
            lastMessage: {},
            unreadMessageCount: 0
          }));

        case 18:
          _context20.next = 23;
          break;

        case 20:
          _context20.prev = 20;
          _context20.t0 = _context20["catch"](0);
          console.log('ERROR in clear history');

        case 23:
        case "end":
          return _context20.stop();
      }
    }
  }, _marked20, null, [[0, 20]]);
}

function deleteAllMessages(action) {
  var payload, channelId, channel, activeChannelId;
  return _regeneratorRuntime().wrap(function deleteAllMessages$(_context21) {
    while (1) {
      switch (_context21.prev = _context21.next) {
        case 0:
          _context21.prev = 0;
          payload = action.payload;
          channelId = payload.channelId;
          _context21.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context21.sent;
          _context21.next = 8;
          return call(getActiveChannelId);

        case 8:
          activeChannelId = _context21.sent;

          if (!channel) {
            _context21.next = 19;
            break;
          }

          _context21.next = 12;
          return call(channel.deleteAllMessages);

        case 12:
          removeMessagesFromMap(channelId);

          if (!(channelId === activeChannelId)) {
            _context21.next = 17;
            break;
          }

          _context21.next = 16;
          return put(clearMessagesAC());

        case 16:
          removeAllMessages();

        case 17:
          _context21.next = 19;
          return put(updateChannelLastMessageAC({}, channel));

        case 19:
          _context21.next = 24;
          break;

        case 21:
          _context21.prev = 21;
          _context21.t0 = _context21["catch"](0);
          console.log('ERROR in clear history');

        case 24:
        case "end":
          return _context21.stop();
      }
    }
  }, _marked21, null, [[0, 21]]);
}

function joinChannel(action) {
  var payload, channelId, channel;
  return _regeneratorRuntime().wrap(function joinChannel$(_context22) {
    while (1) {
      switch (_context22.prev = _context22.next) {
        case 0:
          _context22.prev = 0;
          payload = action.payload;
          channelId = payload.channelId;
          _context22.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context22.sent;
          _context22.next = 8;
          return call(channel.join);

        case 8:
          _context22.next = 10;
          return put(getChannelsAC({
            search: ''
          }));

        case 10:
          _context22.next = 15;
          break;

        case 12:
          _context22.prev = 12;
          _context22.t0 = _context22["catch"](0);
          console.log(_context22.t0, 'Error in join to channel');

        case 15:
        case "end":
          return _context22.stop();
      }
    }
  }, _marked22, null, [[0, 12]]);
}

function watchForChannelEvents() {
  return _regeneratorRuntime().wrap(function watchForChannelEvents$(_context23) {
    while (1) {
      switch (_context23.prev = _context23.next) {
        case 0:
          _context23.next = 2;
          return call(watchForEvents);

        case 2:
        case "end":
          return _context23.stop();
      }
    }
  }, _marked23);
}

function ChannelsSaga() {
  return _regeneratorRuntime().wrap(function ChannelsSaga$(_context24) {
    while (1) {
      switch (_context24.prev = _context24.next) {
        case 0:
          _context24.next = 2;
          return takeLatest(CREATE_CHANNEL, createChannel);

        case 2:
          _context24.next = 4;
          return takeLatest(GET_CHANNELS, getChannels);

        case 4:
          _context24.next = 6;
          return takeLatest(GET_CHANNELS_FOR_FORWARD, getChannelsForForward);

        case 6:
          _context24.next = 8;
          return takeLatest(LOAD_MORE_CHANNEL, channelsLoadMore);

        case 8:
          _context24.next = 10;
          return takeLatest(LOAD_MORE_CHANNELS_FOR_FORWARD, channelsForForwardLoadMore);

        case 10:
          _context24.next = 12;
          return takeEvery(SWITCH_CHANNEL, switchChannel);

        case 12:
          _context24.next = 14;
          return takeLatest(LEAVE_CHANNEL, leaveChannel);

        case 14:
          _context24.next = 16;
          return takeLatest(DELETE_CHANNEL, deleteChannel);

        case 16:
          _context24.next = 18;
          return takeLatest(BLOCK_CHANNEL, blockChannel);

        case 18:
          _context24.next = 20;
          return takeLatest(UPDATE_CHANNEL, updateChannel);

        case 20:
          _context24.next = 22;
          return takeEvery(MARK_MESSAGES_AS_READ, markMessagesRead);

        case 22:
          _context24.next = 24;
          return takeLatest(MARK_MESSAGES_AS_DELIVERED, markMessagesDelivered);

        case 24:
          _context24.next = 26;
          return takeLatest(WATCH_FOR_EVENTS, watchForChannelEvents);

        case 26:
          _context24.next = 28;
          return takeLatest(TURN_OFF_NOTIFICATION, notificationsTurnOff);

        case 28:
          _context24.next = 30;
          return takeLatest(TURN_ON_NOTIFICATION, notificationsTurnOn);

        case 30:
          _context24.next = 32;
          return takeLatest(MARK_CHANNEL_AS_READ, markChannelAsRead);

        case 32:
          _context24.next = 34;
          return takeLatest(MARK_CHANNEL_AS_UNREAD, markChannelAsUnRead);

        case 34:
          _context24.next = 36;
          return takeLatest(CHECK_USER_STATUS, checkUsersStatus);

        case 36:
          _context24.next = 38;
          return takeLatest(SEND_TYPING, sendTyping);

        case 38:
          _context24.next = 40;
          return takeLatest(CLEAR_HISTORY, clearHistory);

        case 40:
          _context24.next = 42;
          return takeLatest(JOIN_TO_CHANNEL, joinChannel);

        case 42:
          _context24.next = 44;
          return takeLatest(DELETE_ALL_MESSAGES, deleteAllMessages);

        case 44:
          _context24.next = 46;
          return takeLatest(REMOVE_CHANNEL_CACHES, removeChannelCaches);

        case 46:
        case "end":
          return _context24.stop();
      }
    }
  }, _marked24);
}

var MAX_WIDTH = 1280;
var MAX_HEIGHT = 1080;
var MIME_TYPE = 'image/jpeg';
var QUALITY = 0.9;
var THUMBNAIL_MAX_WIDTH = 6;
var THUMBNAIL_MAX_HEIGHT = 6;
var THUMBNAIL_MIME_TYPE = 'image/jpeg';
var THUMBNAIL_QUALITY = 0.7;
function resizeImage(file, maxWidth, maxHeight, quality) {
  console.log('resize image. .. ', quality);
  return new Promise(function (resolve) {
    var blobURL = URL.createObjectURL(file);
    var img = new Image();
    img.src = blobURL;

    img.onerror = function () {
      URL.revokeObjectURL(this.src);
      console.log('Cannot load image');
    };

    img.onload = function () {
      URL.revokeObjectURL(this.src);

      var _calculateSize = calculateSize(img.width, img.height, maxWidth || MAX_WIDTH, maxHeight || MAX_HEIGHT),
          newWidth = _calculateSize[0],
          newHeight = _calculateSize[1];

      var canvas = document.createElement('canvas');
      canvas.width = newWidth;
      canvas.height = newHeight;
      var ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, newWidth, newHeight);
      canvas.toBlob(function (blob) {
        resolve({
          file: file,
          blob: blob,
          newWidth: newWidth,
          newHeight: newHeight
        });
      }, MIME_TYPE, quality || QUALITY);
    };
  });
}
function createFileImageThumbnail(file) {
  return new Promise(function (resolve) {
    var blobURL = URL.createObjectURL(file);
    var img = new Image();
    img.src = blobURL;

    img.onerror = function () {
      URL.revokeObjectURL(this.src);
      console.log('Cannot load image');
    };

    img.onload = function () {
      URL.revokeObjectURL(this.src);

      var _calculateSize2 = calculateSize(img.width, img.height, 50, 50),
          newWidth = _calculateSize2[0],
          newHeight = _calculateSize2[1];

      var canvas = document.createElement('canvas');
      canvas.width = newWidth;
      canvas.height = newHeight;
      var ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, newWidth, newHeight);
      var base64String = canvas.toDataURL(THUMBNAIL_MIME_TYPE, THUMBNAIL_QUALITY);
      resolve(base64String);
    };
  });
}
function createImageThumbnail(file, path, maxWidth, maxHeight) {
  return new Promise(function (resolve) {
    var blobURL;

    if (file) {
      blobURL = URL.createObjectURL(file);
    }

    var img = new Image();
    img.src = blobURL || path || '';

    img.onerror = function () {
      URL.revokeObjectURL(this.src);
      console.log('Cannot load image');
    };

    img.onload = function () {
      if (blobURL) {
        URL.revokeObjectURL(this.src);
      }

      var _calculateSize3 = calculateSize(img.width, img.height, maxWidth || THUMBNAIL_MAX_WIDTH, maxHeight || THUMBNAIL_MAX_HEIGHT),
          newWidth = _calculateSize3[0],
          newHeight = _calculateSize3[1];

      var canvas = document.createElement('canvas');
      canvas.width = newWidth;
      canvas.height = newHeight;
      var ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, newWidth, newHeight);
      var base64String = canvas.toDataURL(THUMBNAIL_MIME_TYPE, THUMBNAIL_QUALITY);
      resolve({
        thumbnail: base64String.replace('data:image/jpeg;base64,', ''),
        imageWidth: img.width,
        imageHeight: img.height
      });
    };
  });
}
function getImageSize(path) {
  return new Promise(function (resolve) {
    fetch(path).then(function (response) {
      response.blob().then(function (res) {
        resolve(res.size);
      });
    });
  });
}
function calculateSize(width, height, maxWidth, maxHeight) {
  if (width > height) {
    if (width > maxWidth) {
      height = Math.round(height * maxWidth / width);
      width = maxWidth;
    }
  } else {
    if (height > maxHeight) {
      width = Math.round(width * maxHeight / height);
      height = maxHeight;
    }
  }

  if (height < 1) {
    height = 1;
  }

  return [width, height];
}

var activeChannelMessagesSelector = function activeChannelMessagesSelector(store) {
  return store.MessageReducer.activeChannelMessages;
};
var messagesLoadingState = function messagesLoadingState(store) {
  return store.MessageReducer.messagesLoadingState;
};
var messagesHasNextSelector = function messagesHasNextSelector(store) {
  return store.MessageReducer.messagesHasNext;
};
var messagesHasPrevSelector = function messagesHasPrevSelector(store) {
  return store.MessageReducer.messagesHasPrev;
};
var attachmentCompilationStateSelector = function attachmentCompilationStateSelector(store) {
  return store.MessageReducer.attachmentsUploadingState;
};
var activeTabAttachmentsSelector = function activeTabAttachmentsSelector(store) {
  return store.MessageReducer.activeTabAttachments;
};
var activeTabAttachmentsHasNextSelector = function activeTabAttachmentsHasNextSelector(store) {
  return store.MessageReducer.attachmentHasNext;
};
var attachmentsForPopupSelector = function attachmentsForPopupSelector(store) {
  return store.MessageReducer.attachmentsForPopup;
};
var messageForReplySelector = function messageForReplySelector(store) {
  return store.MessageReducer.messageForReply;
};
var messageToEditSelector = function messageToEditSelector(store) {
  return store.MessageReducer.messageToEdit;
};
var scrollToNewMessageSelector = function scrollToNewMessageSelector(store) {
  return store.MessageReducer.scrollToNewMessage;
};
var showScrollToNewMessageButtonSelector = function showScrollToNewMessageButtonSelector(store) {
  return store.MessageReducer.showScrollToNewMessageButton;
};
var sendMessageInputHeightSelector = function sendMessageInputHeightSelector(store) {
  return store.MessageReducer.sendMessageInputHeight;
};
var scrollToMessageSelector = function scrollToMessageSelector(store) {
  return store.MessageReducer.scrollToMessage;
};

var _marked$2 = /*#__PURE__*/_regeneratorRuntime().mark(sendMessage),
    _marked2$1 = /*#__PURE__*/_regeneratorRuntime().mark(sendTextMessage),
    _marked3$1 = /*#__PURE__*/_regeneratorRuntime().mark(forwardMessage),
    _marked4$1 = /*#__PURE__*/_regeneratorRuntime().mark(resendMessage),
    _marked5$1 = /*#__PURE__*/_regeneratorRuntime().mark(deleteMessage),
    _marked6$1 = /*#__PURE__*/_regeneratorRuntime().mark(editMessage),
    _marked7$1 = /*#__PURE__*/_regeneratorRuntime().mark(getMessagesQuery),
    _marked8$1 = /*#__PURE__*/_regeneratorRuntime().mark(loadMoreMessages),
    _marked9$1 = /*#__PURE__*/_regeneratorRuntime().mark(addReaction),
    _marked10$1 = /*#__PURE__*/_regeneratorRuntime().mark(deleteReaction),
    _marked11$1 = /*#__PURE__*/_regeneratorRuntime().mark(getMessageAttachments),
    _marked12$1 = /*#__PURE__*/_regeneratorRuntime().mark(loadMoreMessageAttachments),
    _marked13$1 = /*#__PURE__*/_regeneratorRuntime().mark(pauseAttachmentUploading),
    _marked14$1 = /*#__PURE__*/_regeneratorRuntime().mark(resumeAttachmentUploading),
    _marked15$1 = /*#__PURE__*/_regeneratorRuntime().mark(MessageSaga);

function sendMessage(action) {
  var payload, message, connectionState, channelId, sendAttachmentsAsSeparateMessage, channel, mentionedUserIds, customUploader, thumbnailMetas, messageAttachment, fileType, messageBuilder, messageToSend, messageCopy, pendingMessage, hasNextMessages, filePath, handleUploadProgress, handleUpdateLocalPath, uri, fileSize, attachmentMeta, attachmentBuilder, attachmentToSend, messageResponse, messageUpdateData, attachmentsToSend, _messageBuilder, _messageToSend, attachmentsLocalPaths, receivedPaths, uploadAllAttachments, uploadedAttachments, _messageCopy2, _messageResponse, _messageUpdateData;

  return _regeneratorRuntime().wrap(function sendMessage$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          payload = action.payload;
          message = payload.message, connectionState = payload.connectionState, channelId = payload.channelId, sendAttachmentsAsSeparateMessage = payload.sendAttachmentsAsSeparateMessage;
          _context.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context.sent;
          mentionedUserIds = message.mentionedMembers.map(function (member) {
            return member.id;
          });
          customUploader = getCustomUploader();

          if (!(message.attachments && message.attachments.length)) {
            _context.next = 134;
            break;
          }

          if (!sendAttachmentsAsSeparateMessage) {
            _context.next = 100;
            break;
          }

          thumbnailMetas = {};
          messageAttachment = _extends({}, message.attachments[0], {
            url: message.attachments[0].data
          });
          fileType = messageAttachment.type;

          if (!(fileType === 'video')) {
            _context.next = 17;
            break;
          }

          thumbnailMetas = getVideoThumb(messageAttachment.attachmentId);
          _context.next = 21;
          break;

        case 17:
          if (!(fileType === 'image')) {
            _context.next = 21;
            break;
          }

          _context.next = 20;
          return call(createImageThumbnail, message.attachments[0].data, undefined, messageAttachment.type === 'file' ? 50 : undefined, messageAttachment.type === 'file' ? 50 : undefined);

        case 20:
          thumbnailMetas = _context.sent;

        case 21:
          messageAttachment.metadata = _extends({}, messageAttachment.metadata, {
            tmb: thumbnailMetas.thumbnail,
            szw: thumbnailMetas.imageWidth,
            szh: thumbnailMetas.imageHeight,
            dur: thumbnailMetas.duration && Math.floor(thumbnailMetas.duration)
          });
          setPendingAttachment(messageAttachment.attachmentId, messageAttachment.data);
          messageBuilder = channel.createMessageBuilder();
          messageBuilder.setBody(message.body).setAttachments([]).setMentionUserIds(mentionedUserIds).setType(message.type).setDisplayCount(message.type === 'system' ? 0 : 1).setSilent(message.type === 'system').setMetadata(JSON.stringify(message.metadata));

          if (message.parent) {
            messageBuilder.setParentMessageId(message.parent ? message.parent.id : null);
          }

          if (message.repliedInThread) {
            messageBuilder.setReplyInThread();
          }

          messageToSend = messageBuilder.create();
          messageCopy = _extends({}, messageToSend, {
            attachments: [].concat(messageAttachment)
          });
          pendingMessage = JSON.parse(JSON.stringify(_extends({}, messageCopy, {
            createdAt: new Date(Date.now()),
            parent: message.parent
          })));
          _context.next = 32;
          return select(messagesHasNextSelector);

        case 32:
          hasNextMessages = _context.sent;

          if (getHasNextCached()) {
            _context.next = 41;
            break;
          }

          if (!hasNextMessages) {
            _context.next = 39;
            break;
          }

          _context.next = 37;
          return put(getMessagesAC(channel));

        case 37:
          _context.next = 41;
          break;

        case 39:
          _context.next = 41;
          return put(addMessageAC(_extends({}, pendingMessage)));

        case 41:
          console.log('add pending message .. ', pendingMessage);
          addMessageToMap(channelId, pendingMessage);
          addAllMessages([pendingMessage], MESSAGE_LOAD_DIRECTION.NEXT);
          _context.next = 46;
          return put(scrollToNewMessageAC(true, true));

        case 46:
          _context.next = 48;
          return put(updateAttachmentUploadingStateAC(UPLOAD_STATE.UPLOADING, messageAttachment.attachmentId));

        case 48:
          if (!customUploader) {
            _context.next = 98;
            break;
          }

          handleUploadProgress = function handleUploadProgress(_ref) {
            var loaded = _ref.loaded,
                total = _ref.total;
            console.log('progress  ... ', loaded / total);
          };

          handleUpdateLocalPath = function handleUpdateLocalPath(updatedLink) {
            filePath = updatedLink;
            thumbnailMetas = getVideoThumb(messageAttachment.attachmentId);
            messageCopy.attachments[0] = _extends({}, messageCopy.attachments[0], {
              attachmentUrl: updatedLink
            });
            var updateAttachmentPath = {
              attachments: [_extends({}, messageCopy.attachments[0], {
                attachmentUrl: updatedLink
              })]
            };
            store.dispatch({
              type: UPDATE_MESSAGE,
              payload: {
                message: JSON.parse(JSON.stringify(_extends({}, updateAttachmentPath)))
              }
            });
          };

          _context.prev = 51;

          if (!(connectionState === CONNECTION_STATUS.CONNECTED)) {
            _context.next = 87;
            break;
          }

          _context.next = 55;
          return call(customUpload, messageAttachment, handleUploadProgress, handleUpdateLocalPath);

        case 55:
          uri = _context.sent;
          console.log('upload res .... uri, ,, ', uri);
          _context.next = 59;
          return put(updateAttachmentUploadingStateAC(UPLOAD_STATE.SUCCESS, messageAttachment.attachmentId));

        case 59:
          fileSize = messageAttachment.size;

          if (!(messageAttachment.url.type.split('/')[0] === 'image')) {
            _context.next = 67;
            break;
          }

          _context.next = 63;
          return call(getImageSize, filePath);

        case 63:
          fileSize = _context.sent;
          _context.next = 66;
          return call(createImageThumbnail, null, filePath, messageAttachment.type === 'file' ? 50 : undefined, messageAttachment.type === 'file' ? 50 : undefined);

        case 66:
          thumbnailMetas = _context.sent;

        case 67:
          attachmentMeta = JSON.stringify(_extends({}, messageAttachment.metadata, thumbnailMetas && thumbnailMetas.thumbnail && {
            tmb: thumbnailMetas.thumbnail,
            szw: thumbnailMetas.imageWidth,
            szh: thumbnailMetas.imageHeight
          }));
          attachmentBuilder = channel.createAttachmentBuilder(uri, messageAttachment.type);
          attachmentToSend = attachmentBuilder.setName(messageAttachment.name).setMetadata(attachmentMeta).setFileSize(fileSize).setUpload(false).create();
          attachmentToSend.attachmentId = messageAttachment.attachmentId;
          attachmentToSend.attachmentUrl = messageAttachment.attachmentUrl;
          messageToSend.attachments = [attachmentToSend];
          _context.next = 75;
          return call(channel.sendMessage, messageToSend);

        case 75:
          messageResponse = _context.sent;
          deletePendingAttachment(messageAttachment.attachmentId);
          messageUpdateData = {
            id: messageResponse.id,
            deliveryStatus: messageResponse.deliveryStatus,
            attachments: [_extends({}, messageResponse.attachments[0], {
              attachmentUrl: attachmentToSend.attachmentUrl,
              attachmentId: attachmentToSend.attachmentId
            })],
            mentionedUsers: messageResponse.mentionedUsers,
            metadata: messageResponse.metadata,
            parent: messageResponse.parent,
            repliedInThread: messageResponse.repliedInThread,
            createdAt: messageResponse.createdAt
          };
          _context.next = 80;
          return put(updateMessageAC(messageToSend.tid, messageUpdateData));

        case 80:
          if (fileType === 'video') {
            deleteVideoThumb(messageAttachment.attachmentId);
          }

          updateMessageOnMap(channel.id, {
            messageId: messageToSend.tid,
            params: messageUpdateData
          });
          updateMessageOnAllMessages(messageToSend.tid, messageUpdateData);
          _context.next = 85;
          return put(updateChannelLastMessageAC(JSON.parse(JSON.stringify(messageResponse)), {
            id: channel.id
          }));

        case 85:
          _context.next = 88;
          break;

        case 87:
          throw Error('Network error');

        case 88:
          _context.next = 98;
          break;

        case 90:
          _context.prev = 90;
          _context.t0 = _context["catch"](51);
          _context.next = 94;
          return put(updateAttachmentUploadingStateAC(UPLOAD_STATE.FAIL, messageAttachment.attachmentId));

        case 94:
          updateMessageOnMap(channel.id, {
            messageId: messageToSend.tid,
            params: {
              state: MESSAGE_STATUS.FAILED
            }
          });
          updateMessageOnAllMessages(messageToSend.tid, {
            state: MESSAGE_STATUS.FAILED
          });
          _context.next = 98;
          return put(updateMessageAC(messageToSend.tid, {
            state: MESSAGE_STATUS.FAILED
          }));

        case 98:
          _context.next = 134;
          break;

        case 100:
          attachmentsToSend = message.attachments.map(function (attachment) {
            var attachmentBuilder = channel.createAttachmentBuilder(attachment.data, attachment.type);
            var att = attachmentBuilder.setName(attachment.name).setMetadata(attachment.metadata).setUpload(customUploader ? false : attachment.upload).create();

            if (!customUploader) {
              att.progress = function (progressPercent) {
                console.log('progress ... ', progressPercent);
              };

              att.completion = function (updatedAttachment, error) {
                if (error) {
                  console.log('fail to upload attachment ... ', error);
                } else {
                  console.log('success attachment. .. ', updatedAttachment);
                }
              };
            }

            att.attachmentId = attachment.attachmentId;
            att.attachmentUrl = attachment.attachmentUrl;
            return att;
          });
          _messageBuilder = channel.createMessageBuilder();

          _messageBuilder.setBody(message.body).setAttachments(message.attachments).setMentionUserIds(mentionedUserIds).setType(message.type).setDisplayCount(message.type === 'system' ? 0 : 1).setSilent(message.type === 'system').setMetadata(JSON.stringify(message.metadata));

          if (message.parent) {
            _messageBuilder.setParentMessageId(message.parent ? message.parent.id : null);
          }

          if (message.repliedInThread) {
            _messageBuilder.setReplyInThread();
          }

          _messageToSend = _messageBuilder.create();

          if (!customUploader) {
            _context.next = 118;
            break;
          }

          attachmentsLocalPaths = {};
          receivedPaths = 1;

          uploadAllAttachments = function uploadAllAttachments() {
            try {
              return Promise.resolve(Promise.all(attachmentsToSend.map(function (attachment) {
                return customUpload(attachment, function (_ref2) {
                  var loaded = _ref2.loaded,
                      total = _ref2.total;
                  console.log('progress  ... ', loaded / total);
                }, function (updatedLink) {
                  if (attachment.attachmentId) {
                    receivedPaths++;
                    attachmentsLocalPaths[attachment.attachmentId] = updatedLink;

                    if (receivedPaths === attachmentsToSend.length) {
                      var _messageCopy = _extends({}, _messageToSend, {
                        attachments: message.attachments.map(function (att) {
                          return {
                            attachmentId: att.attachmentId,
                            name: att.name,
                            data: {},
                            type: att.type,
                            attachmentUrl: attachmentsLocalPaths[attachment.attachmentId]
                          };
                        })
                      });

                      store.dispatch({
                        type: ADD_MESSAGE,
                        payload: {
                          message: JSON.parse(JSON.stringify(_extends({}, _messageCopy, {
                            createdAt: new Date(Date.now()),
                            parent: message.parent
                          })))
                        }
                      });
                    }
                  }
                });
              })));
            } catch (e) {
              return Promise.reject(e);
            }
          };

          _context.next = 112;
          return call(uploadAllAttachments);

        case 112:
          uploadedAttachments = _context.sent;
          _context.next = 115;
          return call(function () {
            try {
              return Promise.resolve(Promise.all(uploadedAttachments.map(function (att) {
                try {
                  return Promise.resolve(new Promise(function (resolve) {
                    store.dispatch({
                      type: UPLOAD_ATTACHMENT_COMPILATION,
                      payload: {
                        attachmentUploadingState: UPLOAD_STATE.UPLOADING,
                        attachment: att.attachment
                      }
                    });
                    createImageThumbnail(null, att.filePath).then(function (_ref3) {
                      var thumbnail = _ref3.thumbnail,
                          imageWidth = _ref3.imageWidth,
                          imageHeight = _ref3.imageHeight;
                      store.dispatch({
                        type: UPLOAD_ATTACHMENT_COMPILATION,
                        payload: {
                          attachmentUploadingState: UPLOAD_STATE.SUCCESS,
                          attachment: att.attachment
                        }
                      });
                      return resolve(_extends({}, att.attachment, {
                        url: att.uri,
                        metadata: JSON.stringify({
                          thumbnail: thumbnail,
                          width: imageWidth,
                          height: imageHeight
                        })
                      }));
                    });
                  }));
                } catch (e) {
                  return Promise.reject(e);
                }
              })));
            } catch (e) {
              return Promise.reject(e);
            }
          });

        case 115:
          attachmentsToSend = _context.sent;
          _context.next = 121;
          break;

        case 118:
          _messageCopy2 = _extends({}, _messageToSend, {
            attachments: message.attachments.map(function (att) {
              return {
                attachmentId: att.attachmentId,
                name: att.name,
                data: {},
                type: att.type,
                attachmentUrl: att.attachmentUrl
              };
            })
          });
          _context.next = 121;
          return put(addMessageAC(JSON.parse(JSON.stringify(_extends({}, _messageCopy2, {
            createdAt: new Date(Date.now()),
            parent: message.parent
          })))));

        case 121:
          _messageToSend.attachments = attachmentsToSend;

          if (!(connectionState === CONNECTION_STATUS.CONNECTED)) {
            _context.next = 134;
            break;
          }

          console.log('message to send .... ', _messageToSend);
          _context.next = 126;
          return call(channel.sendMessage, _messageToSend);

        case 126:
          _messageResponse = _context.sent;
          console.log('message response ... ', _messageResponse);
          _messageUpdateData = {
            id: _messageResponse.id,
            deliveryStatus: _messageResponse.deliveryStatus,
            attachments: _messageResponse.attachments,
            mentionedUsers: _messageResponse.mentionedUsers,
            metadata: _messageResponse.metadata,
            parent: _messageResponse.parent,
            repliedInThread: _messageResponse.repliedInThread,
            createdAt: _messageResponse.createdAt
          };
          _context.next = 131;
          return put(updateMessageAC(_messageToSend.tid, _messageUpdateData));

        case 131:
          updateMessageOnMap(channel.id, {
            messageId: _messageToSend.tid,
            params: _messageUpdateData
          });
          _context.next = 134;
          return put(updateChannelLastMessageAC(JSON.parse(JSON.stringify(_messageResponse)), {
            id: channel.id
          }));

        case 134:
          _context.next = 136;
          return put(scrollToNewMessageAC(true));

        case 136:
          _context.next = 141;
          break;

        case 138:
          _context.prev = 138;
          _context.t1 = _context["catch"](0);
          console.log('error on send message ... ', _context.t1);

        case 141:
        case "end":
          return _context.stop();
      }
    }
  }, _marked$2, null, [[0, 138], [51, 90]]);
}

function sendTextMessage(action) {
  var payload, _message, connectionState, channelId, channel, mentionedUserIds, attachments, attachmentBuilder, att, messageBuilder, messageToSend, pendingMessage, hasNextMessages, messageResponse, messageUpdateData;

  return _regeneratorRuntime().wrap(function sendTextMessage$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          payload = action.payload;
          _message = payload.message, connectionState = payload.connectionState, channelId = payload.channelId;
          _context2.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context2.sent;
          mentionedUserIds = _message.mentionedMembers.map(function (member) {
            return member.id;
          });
          attachments = _message.attachments;

          if (_message.attachments && _message.attachments.length) {
            attachmentBuilder = channel.createAttachmentBuilder(attachments[0].data, attachments[0].type);
            att = attachmentBuilder.setName('').setUpload(attachments[0].upload).create();
            attachments = [att];
          }

          messageBuilder = channel.createMessageBuilder();
          messageBuilder.setBody(_message.body).setAttachments(attachments).setMentionUserIds(mentionedUserIds).setType(_message.type).setDisplayCount(_message.type === 'system' ? 0 : 1).setSilent(_message.type === 'system').setMetadata(JSON.stringify(_message.metadata));

          if (_message.parent) {
            messageBuilder.setParentMessageId(_message.parent ? _message.parent.id : null);
          }

          if (_message.repliedInThread) {
            messageBuilder.setReplyInThread();
          }

          messageToSend = messageBuilder.create();
          pendingMessage = JSON.parse(JSON.stringify(_extends({}, messageToSend, {
            createdAt: new Date(Date.now()),
            parent: _message.parent
          })));
          _context2.next = 17;
          return select(messagesHasNextSelector);

        case 17:
          hasNextMessages = _context2.sent;

          if (getHasNextCached()) {
            _context2.next = 26;
            break;
          }

          if (!hasNextMessages) {
            _context2.next = 24;
            break;
          }

          _context2.next = 22;
          return put(getMessagesAC(channel));

        case 22:
          _context2.next = 26;
          break;

        case 24:
          _context2.next = 26;
          return put(addMessageAC(_extends({}, pendingMessage)));

        case 26:
          addMessageToMap(channelId, pendingMessage);
          addAllMessages([pendingMessage], MESSAGE_LOAD_DIRECTION.NEXT);
          _context2.next = 30;
          return put(scrollToNewMessageAC(true, true));

        case 30:
          if (!(connectionState === CONNECTION_STATUS.CONNECTED)) {
            _context2.next = 41;
            break;
          }

          _context2.next = 33;
          return call(channel.sendMessage, messageToSend);

        case 33:
          messageResponse = _context2.sent;
          messageUpdateData = {
            id: messageResponse.id,
            deliveryStatus: messageResponse.deliveryStatus,
            attachments: messageResponse.attachments,
            mentionedUsers: messageResponse.mentionedUsers,
            metadata: messageResponse.metadata,
            parent: messageResponse.parent,
            repliedInThread: messageResponse.repliedInThread,
            createdAt: messageResponse.createdAt
          };
          _context2.next = 37;
          return put(updateMessageAC(messageToSend.tid, messageUpdateData));

        case 37:
          updateMessageOnMap(channel.id, {
            messageId: messageToSend.tid,
            params: messageUpdateData
          });
          updateMessageOnAllMessages(messageToSend.tid, messageUpdateData);
          _context2.next = 41;
          return put(updateChannelLastMessageAC(JSON.parse(JSON.stringify(messageResponse)), {
            id: channel.id
          }));

        case 41:
          _context2.next = 46;
          break;

        case 43:
          _context2.prev = 43;
          _context2.t0 = _context2["catch"](0);
          console.log('error on send message ... ', _context2.t0);

        case 46:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2$1, null, [[0, 43]]);
}

function forwardMessage(action) {
  var payload, _message2, channelId, connectionState, channel, mentionedUserIds, attachments, attachmentBuilder, att, messageBuilder, messageToSend, pendingMessage, activeChannelId, isCachedChannel, hasNextMessages, messageResponse, messageUpdateData;

  return _regeneratorRuntime().wrap(function forwardMessage$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.prev = 0;
          payload = action.payload;
          _message2 = payload.message, channelId = payload.channelId, connectionState = payload.connectionState;
          _context3.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context3.sent;
          mentionedUserIds = _message2.mentionedMembers ? _message2.mentionedMembers.map(function (member) {
            return member.id;
          }) : [];
          attachments = _message2.attachments;

          if (channel.type === CHANNEL_TYPE.PUBLIC && !(channel.role === 'admin' || channel.role === 'owner')) {
            _context3.next = 55;
            break;
          }

          if (_message2.attachments && _message2.attachments.length) {
            attachmentBuilder = channel.createAttachmentBuilder(attachments[0].url, attachments[0].type);
            att = attachmentBuilder.setName(attachments[0].name).setMetadata(JSON.stringify(attachments[0].metadata)).setFileSize(attachments[0].fileSize).setUpload(false).create();
            attachments = [att];
          }

          messageBuilder = channel.createMessageBuilder();
          messageBuilder.setBody(_message2.body).setAttachments(attachments).setMentionUserIds(mentionedUserIds).setType(_message2.type).setMetadata(_message2.metadata ? JSON.stringify(_message2.metadata) : '').setForwardingMessageId(_message2.id);
          messageToSend = messageBuilder.create();
          pendingMessage = JSON.parse(JSON.stringify(_extends({}, messageToSend, {
            createdAt: new Date(Date.now())
          })));
          pendingMessage.forwardingDetails.user = _message2.user;
          pendingMessage.forwardingDetails.channelId = channelId;
          pendingMessage.forwardingDetails.hops = _message2.forwardingDetails ? _message2.forwardingDetails.hops : 1;
          activeChannelId = getActiveChannelId();
          isCachedChannel = checkChannelExistsOnMessagesMap(channelId);

          if (!(channelId === activeChannelId)) {
            _context3.next = 37;
            break;
          }

          _context3.next = 22;
          return select(messagesHasNextSelector);

        case 22:
          hasNextMessages = _context3.sent;

          if (getHasNextCached()) {
            _context3.next = 31;
            break;
          }

          if (!hasNextMessages) {
            _context3.next = 29;
            break;
          }

          _context3.next = 27;
          return put(getMessagesAC(channel));

        case 27:
          _context3.next = 31;
          break;

        case 29:
          _context3.next = 31;
          return put(addMessageAC(_extends({}, pendingMessage)));

        case 31:
          addMessageToMap(channelId, pendingMessage);
          addAllMessages([pendingMessage], MESSAGE_LOAD_DIRECTION.NEXT);
          _context3.next = 35;
          return put(scrollToNewMessageAC(true, true));

        case 35:
          _context3.next = 38;
          break;

        case 37:
          if (isCachedChannel) {
            addMessageToMap(channelId, pendingMessage);
          }

        case 38:
          if (!(connectionState === CONNECTION_STATUS.CONNECTED)) {
            _context3.next = 55;
            break;
          }

          _context3.next = 41;
          return call(channel.sendMessage, messageToSend);

        case 41:
          messageResponse = _context3.sent;
          messageUpdateData = {
            id: messageResponse.id,
            deliveryStatus: messageResponse.deliveryStatus,
            attachments: messageResponse.attachments,
            mentionedUsers: messageResponse.mentionedUsers,
            metadata: messageResponse.metadata,
            parent: messageResponse.parent,
            repliedInThread: messageResponse.repliedInThread,
            createdAt: messageResponse.createdAt
          };

          if (!(channelId === activeChannelId)) {
            _context3.next = 50;
            break;
          }

          _context3.next = 46;
          return put(updateMessageAC(messageToSend.tid, messageUpdateData));

        case 46:
          updateMessageOnMap(channel.id, {
            messageId: messageToSend.tid,
            params: messageUpdateData
          });
          updateMessageOnAllMessages(messageToSend.tid, messageUpdateData);
          _context3.next = 51;
          break;

        case 50:
          if (isCachedChannel) {
            updateMessageOnMap(channel.id, {
              messageId: messageToSend.tid,
              params: messageUpdateData
            });
          }

        case 51:
          _context3.next = 53;
          return put(addChannelAC(channel));

        case 53:
          _context3.next = 55;
          return put(updateChannelLastMessageAC(JSON.parse(JSON.stringify(messageResponse)), {
            id: channel.id
          }));

        case 55:
          _context3.next = 60;
          break;

        case 57:
          _context3.prev = 57;
          _context3.t0 = _context3["catch"](0);
          console.log('error on forward message ... ', _context3.t0);

        case 60:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3$1, null, [[0, 57]]);
}

function resendMessage(action) {
  var payload, _message3, connectionState, channelId, channel, customUploader, attachmentCompilation, _messageAttachment, _messageCopy3, pendingAttachment, fileType, handleUploadProgress, uri, attachmentToSend, messageResponse, messageUpdateData;

  return _regeneratorRuntime().wrap(function resendMessage$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.prev = 0;
          payload = action.payload;
          _message3 = payload.message, connectionState = payload.connectionState, channelId = payload.channelId;
          console.log('resend message .... ', _message3);
          _context4.next = 6;
          return call(getChannelFromMap, channelId);

        case 6:
          channel = _context4.sent;
          customUploader = getCustomUploader();

          if (!(_message3.attachments && _message3.attachments.length)) {
            _context4.next = 61;
            break;
          }

          _context4.next = 11;
          return select(attachmentCompilationStateSelector);

        case 11:
          attachmentCompilation = _context4.sent;
          _messageAttachment = _extends({}, _message3.attachments[0]);
          _messageCopy3 = _extends({}, _message3, {
            attachments: [_messageAttachment]
          });
          console.log('attachmentCompilation. .. . .', attachmentCompilation);

          if (!(attachmentCompilation[_messageAttachment.attachmentId] && attachmentCompilation[_messageAttachment.attachmentId] === UPLOAD_STATE.FAIL)) {
            _context4.next = 61;
            break;
          }

          pendingAttachment = getPendingAttachment(_message3.attachments[0].attachmentId);
          console.log('pending attachment for resend ... ', pendingAttachment);
          _messageAttachment.data = pendingAttachment;
          _messageAttachment.url = pendingAttachment;
          fileType = _messageAttachment.data.type.split('/')[0];
          _context4.next = 23;
          return put(updateAttachmentUploadingStateAC(UPLOAD_STATE.UPLOADING, _messageAttachment.attachmentId));

        case 23:
          if (!customUploader) {
            _context4.next = 61;
            break;
          }

          handleUploadProgress = function handleUploadProgress(_ref4) {
            var loaded = _ref4.loaded,
                total = _ref4.total;
            console.log('progress ... ', loaded / total);
          };

          _context4.prev = 25;
          console.log('going to upload attachments ..... ', _messageAttachment);
          _context4.next = 29;
          return call(customUpload, _messageAttachment, handleUploadProgress);

        case 29:
          uri = _context4.sent;
          _context4.next = 32;
          return put(updateAttachmentUploadingStateAC(UPLOAD_STATE.SUCCESS, _messageAttachment.attachmentId));

        case 32:
          attachmentToSend = _extends({}, _messageAttachment, {
            url: uri,
            upload: false
          });
          _context4.next = 35;
          return put(updateMessageAC(_messageCopy3.tid, JSON.parse(JSON.stringify(_extends({}, _messageCopy3, {
            attachments: [attachmentToSend]
          })))));

        case 35:
          delete _messageCopy3.createdAt;
          _messageCopy3.attachments = [attachmentToSend];

          if (!(connectionState === CONNECTION_STATUS.CONNECTED)) {
            _context4.next = 50;
            break;
          }

          _context4.next = 40;
          return call(channel.sendMessage, _messageCopy3);

        case 40:
          messageResponse = _context4.sent;
          deletePendingAttachment(_messageAttachment.attachmentId);
          messageUpdateData = {
            id: messageResponse.id,
            deliveryStatus: messageResponse.deliveryStatus,
            attachments: [_extends({}, messageResponse.attachments[0], {
              attachmentUrl: attachmentToSend.attachmentUrl,
              attachmentId: attachmentToSend.attachmentId
            })],
            mentionedUsers: messageResponse.mentionedUsers,
            metadata: messageResponse.metadata,
            parent: messageResponse.parent,
            repliedInThread: messageResponse.repliedInThread,
            createdAt: messageResponse.createdAt
          };
          _context4.next = 45;
          return put(updateMessageAC(_messageCopy3.tid, messageUpdateData));

        case 45:
          if (fileType === 'video') {
            deleteVideoThumb(_messageAttachment.attachmentId);
          }

          updateMessageOnMap(channel.id, {
            messageId: _messageCopy3.tid,
            params: messageUpdateData
          });
          updateMessageOnAllMessages(_messageCopy3.tid, messageUpdateData);
          _context4.next = 50;
          return put(updateChannelLastMessageAC(JSON.parse(JSON.stringify(messageResponse)), {
            id: channel.id
          }));

        case 50:
          _context4.next = 61;
          break;

        case 52:
          _context4.prev = 52;
          _context4.t0 = _context4["catch"](25);
          console.log('fail upload attachment on resend message ... ');
          _context4.next = 57;
          return put(updateAttachmentUploadingStateAC(UPLOAD_STATE.FAIL, _messageAttachment.attachmentId));

        case 57:
          updateMessageOnMap(channel.id, {
            messageId: _messageCopy3.tid,
            params: {
              state: MESSAGE_STATUS.FAILED
            }
          });
          updateMessageOnAllMessages(_messageCopy3.tid, {
            state: MESSAGE_STATUS.FAILED
          });
          _context4.next = 61;
          return put(updateMessageAC(_messageCopy3.tid, {
            state: MESSAGE_STATUS.FAILED
          }));

        case 61:
          _context4.next = 63;
          return put(scrollToNewMessageAC(true, true));

        case 63:
          _context4.next = 68;
          break;

        case 65:
          _context4.prev = 65;
          _context4.t1 = _context4["catch"](0);
          console.log('ERROR in resend message', _context4.t1.message);

        case 68:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4$1, null, [[0, 65], [25, 52]]);
}

function deleteMessage(action) {
  var payload, messageId, channelId, deleteOption, channel, deletedMessage;
  return _regeneratorRuntime().wrap(function deleteMessage$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.prev = 0;
          payload = action.payload;
          messageId = payload.messageId, channelId = payload.channelId, deleteOption = payload.deleteOption;
          _context5.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context5.sent;
          _context5.next = 8;
          return call(channel.deleteMessageById, messageId, deleteOption === 'forMe');

        case 8:
          deletedMessage = _context5.sent;
          _context5.next = 11;
          return put(updateMessageAC(deletedMessage.id, deletedMessage));

        case 11:
          updateMessageOnMap(channel.id, {
            messageId: deletedMessage.id,
            params: deletedMessage
          });
          updateMessageOnAllMessages(messageId, deletedMessage);

          if (!(channel.lastMessage.id === messageId)) {
            _context5.next = 16;
            break;
          }

          _context5.next = 16;
          return put(updateChannelLastMessageAC(deletedMessage, channel));

        case 16:
          _context5.next = 21;
          break;

        case 18:
          _context5.prev = 18;
          _context5.t0 = _context5["catch"](0);
          console.log('ERROR in delete message', _context5.t0.message);

        case 21:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5$1, null, [[0, 18]]);
}

function editMessage(action) {
  var payload, _message4, channelId, channel, editedMessage;

  return _regeneratorRuntime().wrap(function editMessage$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.prev = 0;
          payload = action.payload;
          _message4 = payload.message, channelId = payload.channelId;
          _context6.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context6.sent;
          _context6.next = 8;
          return call(channel.editMessage, _extends({}, _message4, {
            metadata: JSON.stringify(_message4.metadata),
            attachments: _message4.attachments.map(function (att) {
              return _extends({}, att, {
                metadata: JSON.stringify(att.metadata)
              });
            })
          }));

        case 8:
          editedMessage = _context6.sent;
          _context6.next = 11;
          return put(updateMessageAC(editedMessage.id, editedMessage));

        case 11:
          updateMessageOnMap(channel.id, {
            messageId: editedMessage.id,
            params: editedMessage
          });

          if (!(channel.lastMessage.id === _message4.id)) {
            _context6.next = 16;
            break;
          }

          updateMessageOnAllMessages(_message4.id, editedMessage);
          _context6.next = 16;
          return put(updateChannelLastMessageAC(editedMessage, channel));

        case 16:
          _context6.next = 21;
          break;

        case 18:
          _context6.prev = 18;
          _context6.t0 = _context6["catch"](0);
          console.log('ERROR in edit message', _context6.t0.message);

        case 21:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6$1, null, [[0, 18]]);
}

function getMessagesQuery(action) {
  var _action$payload, channel, loadWithLastMessage, messageId, limit, SceytChatClient, messageQueryBuilder, messageQuery, cachedMessages, result, allMessages, messageIndex, maxLengthPart;

  return _regeneratorRuntime().wrap(function getMessagesQuery$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          _context7.prev = 0;
          _action$payload = action.payload, channel = _action$payload.channel, loadWithLastMessage = _action$payload.loadWithLastMessage, messageId = _action$payload.messageId, limit = _action$payload.limit;

          if (!channel.id) {
            _context7.next = 90;
            break;
          }

          SceytChatClient = getClient();
          messageQueryBuilder = new SceytChatClient.chatClient.MessageListQueryBuilder(channel.id);
          messageQueryBuilder.limit(limit || MESSAGES_MAX_LENGTH);
          messageQueryBuilder.reverse(true);
          _context7.next = 9;
          return call(messageQueryBuilder.build);

        case 9:
          messageQuery = _context7.sent;
          query.messageQuery = messageQuery;
          _context7.next = 13;
          return put(setMessagesLoadingStateAC(LOADING_STATE.LOADING));

        case 13:
          cachedMessages = getMessagesFromMap(channel.id);
          result = {
            messages: [],
            hasNext: false
          };

          if (!loadWithLastMessage) {
            _context7.next = 19;
            break;
          }

          result.messages = getFromAllMessagesByMessageId('', '', true);
          _context7.next = 81;
          break;

        case 19:
          if (!messageId) {
            _context7.next = 46;
            break;
          }

          allMessages = getAllMessages();
          messageIndex = allMessages.findIndex(function (msg) {
            return msg.id === messageId;
          });
          maxLengthPart = MESSAGES_MAX_LENGTH / 2;

          if (!(messageIndex >= maxLengthPart)) {
            _context7.next = 31;
            break;
          }

          result.messages = allMessages.slice(messageIndex - maxLengthPart, messageIndex + maxLengthPart);
          _context7.next = 27;
          return put(setMessagesAC(result.messages));

        case 27:
          setHasPrevCached(messageIndex > maxLengthPart);
          setHasNextCached(allMessages.length > maxLengthPart);
          _context7.next = 42;
          break;

        case 31:
          messageQuery.limit = MESSAGES_MAX_LENGTH;
          _context7.next = 34;
          return call(messageQuery.loadNearMessageId, messageId);

        case 34:
          result = _context7.sent;
          _context7.next = 37;
          return put(setMessagesHasNextAC(true));

        case 37:
          _context7.next = 39;
          return put(setMessagesAC([].concat(result.messages)));

        case 39:
          setAllMessages([].concat(result.messages));
          setHasPrevCached(false);
          setHasNextCached(false);

        case 42:
          _context7.next = 44;
          return put(setScrollToMessagesAC(messageId));

        case 44:
          _context7.next = 81;
          break;

        case 46:
          if (!(channel.unreadMessageCount && channel.lastReadMessageId)) {
            _context7.next = 68;
            break;
          }

          setAllMessages([]);
          messageQuery.limit = MESSAGES_MAX_LENGTH;

          if (!(getMessagesFromMap(channel.id) && getMessagesFromMap(channel.id).length)) {
            _context7.next = 55;
            break;
          }

          result.messages = getMessagesFromMap(channel.id);
          _context7.next = 53;
          return put(setMessagesAC([].concat(result.messages)));

        case 53:
          _context7.next = 59;
          break;

        case 55:
          _context7.next = 57;
          return call(messageQuery.loadNearMessageId, channel.lastReadMessageId);

        case 57:
          result = _context7.sent;
          setMessagesToMap(channel.id, result.messages);

        case 59:
          _context7.next = 61;
          return put(setMessagesHasPrevAC(true));

        case 61:
          _context7.next = 63;
          return put(setMessagesHasNextAC(channel.lastMessage && result.messages.length > 0 && channel.lastMessage.id !== result.messages[result.messages.length - 1].id));

        case 63:
          setAllMessages([].concat(result.messages));
          _context7.next = 66;
          return put(setMessagesAC([].concat(result.messages)));

        case 66:
          _context7.next = 81;
          break;

        case 68:
          setAllMessages([]);

          if (!(cachedMessages && cachedMessages.length)) {
            _context7.next = 73;
            break;
          }

          setAllMessages([].concat(cachedMessages));
          _context7.next = 73;
          return put(setMessagesAC(cachedMessages));

        case 73:
          _context7.next = 75;
          return call(messageQuery.loadPrevious);

        case 75:
          result = _context7.sent;
          result.messages.forEach(function (msg) {
            updateMessageOnMap(channel.id, {
              messageId: msg.id,
              params: msg
            });
            updateMessageOnAllMessages(msg.id, msg);
          });
          _context7.next = 79;
          return put(setMessagesHasPrevAC(result.hasNext));

        case 79:
          _context7.next = 81;
          return put(setMessagesHasNextAC(false));

        case 81:
          if (!(!(cachedMessages && cachedMessages.length) || loadWithLastMessage)) {
            _context7.next = 88;
            break;
          }

          _context7.next = 85;
          return put(setMessagesAC([].concat(result.messages)));

        case 85:
          setMessagesToMap(channel.id, result.messages);

          if (!loadWithLastMessage) {
            setAllMessages([].concat(result.messages));
          }

          if (loadWithLastMessage) {
            setHasNextCached(false);
          }

        case 88:
          _context7.next = 90;
          return put(setMessagesLoadingStateAC(LOADING_STATE.LOADED));

        case 90:
          _context7.next = 95;
          break;

        case 92:
          _context7.prev = 92;
          _context7.t0 = _context7["catch"](0);
          console.log('error in message query', _context7.t0);

        case 95:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked7$1, null, [[0, 92]]);
}

function loadMoreMessages(action) {
  var payload, limit, direction, channelId, messageId, hasNext, SceytChatClient, messageQueryBuilder, messageQuery, result;
  return _regeneratorRuntime().wrap(function loadMoreMessages$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _context8.prev = 0;
          payload = action.payload;
          limit = payload.limit, direction = payload.direction, channelId = payload.channelId, messageId = payload.messageId, hasNext = payload.hasNext;
          SceytChatClient = getClient();
          messageQueryBuilder = new SceytChatClient.chatClient.MessageListQueryBuilder(channelId);
          messageQueryBuilder.reverse(true);
          _context8.next = 8;
          return call(messageQueryBuilder.build);

        case 8:
          messageQuery = _context8.sent;
          messageQuery.limit = limit || 5;
          _context8.next = 12;
          return put(setMessagesLoadingStateAC(LOADING_STATE.LOADING));

        case 12:
          result = {
            messages: [],
            hasNext: false
          };

          if (!(direction === MESSAGE_LOAD_DIRECTION.PREV)) {
            _context8.next = 27;
            break;
          }

          if (!getHasPrevCached()) {
            _context8.next = 18;
            break;
          }

          result.messages = getFromAllMessagesByMessageId(messageId, MESSAGE_LOAD_DIRECTION.PREV);
          _context8.next = 25;
          break;

        case 18:
          if (!hasNext) {
            _context8.next = 25;
            break;
          }

          _context8.next = 21;
          return call(messageQuery.loadPreviousMessageId, messageId);

        case 21:
          result = _context8.sent;

          if (result.messages.length) {
            addAllMessages(result.messages, MESSAGE_LOAD_DIRECTION.PREV);
          }

          _context8.next = 25;
          return put(setMessagesHasPrevAC(result.hasNext));

        case 25:
          _context8.next = 39;
          break;

        case 27:
          if (!getHasNextCached()) {
            _context8.next = 31;
            break;
          }

          result.messages = getFromAllMessagesByMessageId(messageId, MESSAGE_LOAD_DIRECTION.NEXT);
          _context8.next = 39;
          break;

        case 31:
          if (!hasNext) {
            _context8.next = 39;
            break;
          }

          messageQuery.reverse = false;
          _context8.next = 35;
          return call(messageQuery.loadNextMessageId, messageId);

        case 35:
          result = _context8.sent;

          if (result.messages.length) {
            addAllMessages(result.messages, MESSAGE_LOAD_DIRECTION.NEXT);
          }

          _context8.next = 39;
          return put(setMessagesHasNextAC(result.hasNext));

        case 39:
          if (!(result.messages && result.messages.length && result.messages.length > 0)) {
            _context8.next = 42;
            break;
          }

          _context8.next = 42;
          return put(addMessagesAC(result.messages, direction));

        case 42:
          _context8.next = 44;
          return put(setMessagesLoadingStateAC(LOADING_STATE.LOADED));

        case 44:
          _context8.next = 49;
          break;

        case 46:
          _context8.prev = 46;
          _context8.t0 = _context8["catch"](0);
          console.log('error in load more messages', _context8.t0);

        case 49:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked8$1, null, [[0, 46]]);
}

function addReaction(action) {
  var payload, channelId, messageId, key, score, reason, enforceUnique, channel, _yield$call, _message5, reaction;

  return _regeneratorRuntime().wrap(function addReaction$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          _context9.prev = 0;
          payload = action.payload;
          channelId = payload.channelId, messageId = payload.messageId, key = payload.key, score = payload.score, reason = payload.reason, enforceUnique = payload.enforceUnique;
          _context9.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context9.sent;
          _context9.next = 8;
          return call(channel.addReaction, messageId, key, score, reason, enforceUnique);

        case 8:
          _yield$call = _context9.sent;
          _message5 = _yield$call.message;
          reaction = _yield$call.reaction;
          _context9.next = 13;
          return put(addReactionToMessageAC(_message5, reaction, true));

        case 13:
          addReactionToMessageOnMap(channelId, _message5, reaction, true);
          _context9.next = 19;
          break;

        case 16:
          _context9.prev = 16;
          _context9.t0 = _context9["catch"](0);
          console.log('ERROR in add reaction', _context9.t0.message);

        case 19:
        case "end":
          return _context9.stop();
      }
    }
  }, _marked9$1, null, [[0, 16]]);
}

function deleteReaction(action) {
  var payload, channelId, messageId, key, channel, _yield$call2, _message6, reaction;

  return _regeneratorRuntime().wrap(function deleteReaction$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          _context10.prev = 0;
          payload = action.payload;
          channelId = payload.channelId, messageId = payload.messageId, key = payload.key;
          _context10.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context10.sent;
          _context10.next = 8;
          return call(channel.deleteReaction, messageId, key);

        case 8:
          _yield$call2 = _context10.sent;
          _message6 = _yield$call2.message;
          reaction = _yield$call2.reaction;
          _context10.next = 13;
          return put(deleteReactionFromMessageAC(_message6, reaction, true));

        case 13:
          _context10.next = 18;
          break;

        case 15:
          _context10.prev = 15;
          _context10.t0 = _context10["catch"](0);
          console.log('ERROR in delete reaction', _context10.t0.message);

        case 18:
        case "end":
          return _context10.stop();
      }
    }
  }, _marked10$1, null, [[0, 15]]);
}

function getMessageAttachments(action) {
  var _action$payload2, channelId, attachmentType, limit, direction, attachmentId, forPopup, SceytChatClient, typeList, AttachmentByTypeQueryBuilder, AttachmentByTypeQuery, result;

  return _regeneratorRuntime().wrap(function getMessageAttachments$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          _context11.prev = 0;
          _action$payload2 = action.payload, channelId = _action$payload2.channelId, attachmentType = _action$payload2.attachmentType, limit = _action$payload2.limit, direction = _action$payload2.direction, attachmentId = _action$payload2.attachmentId, forPopup = _action$payload2.forPopup;
          SceytChatClient = getClient();
          typeList = [attachmentTypes.video, attachmentTypes.image, attachmentTypes.file, attachmentTypes.link, attachmentTypes.voice];

          if (attachmentType === channelDetailsTabs.media) {
            typeList = [attachmentTypes.video, attachmentTypes.image];
          } else if (attachmentType === channelDetailsTabs.file) {
            typeList = [attachmentTypes.file];
          } else if (attachmentType === channelDetailsTabs.link) {
            typeList = [attachmentTypes.link];
          } else if (attachmentType === channelDetailsTabs.voice) {
            typeList = [attachmentTypes.voice];
          }

          AttachmentByTypeQueryBuilder = new SceytChatClient.chatClient.AttachmentListQueryBuilder(channelId, typeList);
          AttachmentByTypeQueryBuilder.limit(limit || 34);
          _context11.next = 9;
          return call(AttachmentByTypeQueryBuilder.build);

        case 9:
          AttachmentByTypeQuery = _context11.sent;

          if (forPopup) {
            AttachmentByTypeQuery.reverse = true;
          }

          result = {
            attachments: [],
            hasNext: true
          };

          if (!(direction === queryDirection.NEXT)) {
            _context11.next = 18;
            break;
          }

          _context11.next = 15;
          return call(AttachmentByTypeQuery.loadPrevious);

        case 15:
          result = _context11.sent;
          _context11.next = 27;
          break;

        case 18:
          if (!(direction === queryDirection.NEAR)) {
            _context11.next = 24;
            break;
          }

          _context11.next = 21;
          return call(AttachmentByTypeQuery.loadNearMessageId, attachmentId);

        case 21:
          result = _context11.sent;
          _context11.next = 27;
          break;

        case 24:
          _context11.next = 26;
          return call(AttachmentByTypeQuery.loadPrevious);

        case 26:
          result = _context11.sent;

        case 27:
          if (!forPopup) {
            _context11.next = 35;
            break;
          }

          query.AttachmentByTypeQueryForPopup = AttachmentByTypeQuery;
          _context11.next = 31;
          return put(setAttachmentsForPopupAC(result.attachments));

        case 31:
          _context11.next = 33;
          return put(setAttachmentsCompleteForPopupAC(result.hasNext));

        case 33:
          _context11.next = 40;
          break;

        case 35:
          query.AttachmentByTypeQuery = AttachmentByTypeQuery;
          _context11.next = 38;
          return put(setAttachmentsCompleteAC(result.hasNext));

        case 38:
          _context11.next = 40;
          return put(setAttachmentsAC(result.attachments));

        case 40:
          _context11.next = 45;
          break;

        case 42:
          _context11.prev = 42;
          _context11.t0 = _context11["catch"](0);
          console.log('error in message attachment query');

        case 45:
        case "end":
          return _context11.stop();
      }
    }
  }, _marked11$1, null, [[0, 42]]);
}

function loadMoreMessageAttachments(action) {
  var _action$payload3, limit, direction, forPopup, AttachmentQuery, _yield$call3, attachments, hasNext;

  return _regeneratorRuntime().wrap(function loadMoreMessageAttachments$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          _context12.prev = 0;
          _action$payload3 = action.payload, limit = _action$payload3.limit, direction = _action$payload3.direction, forPopup = _action$payload3.forPopup;

          if (forPopup) {
            AttachmentQuery = query.AttachmentByTypeQueryForPopup;
          } else {
            AttachmentQuery = query.AttachmentByTypeQuery;
          }

          _context12.next = 5;
          return put(setMessagesLoadingStateAC(LOADING_STATE.LOADING));

        case 5:
          AttachmentQuery.limit = limit;
          _context12.next = 8;
          return call(AttachmentQuery.loadPrevious);

        case 8:
          _yield$call3 = _context12.sent;
          attachments = _yield$call3.attachments;
          hasNext = _yield$call3.hasNext;

          if (!forPopup) {
            _context12.next = 16;
            break;
          }

          _context12.next = 14;
          return put(addAttachmentsForPopupAC(attachments, direction));

        case 14:
          _context12.next = 22;
          break;

        case 16:
          _context12.next = 18;
          return put(setAttachmentsCompleteAC(hasNext));

        case 18:
          _context12.next = 20;
          return put(setMessagesLoadingStateAC(LOADING_STATE.LOADED));

        case 20:
          _context12.next = 22;
          return put(addAttachmentsAC(attachments));

        case 22:
          _context12.next = 28;
          break;

        case 24:
          _context12.prev = 24;
          _context12.t0 = _context12["catch"](0);
          console.log('error in message attachment query', _context12.t0);

        case 28:
        case "end":
          return _context12.stop();
      }
    }
  }, _marked12$1, null, [[0, 24]]);
}

function pauseAttachmentUploading(action) {
  var attachmentId, isPaused;
  return _regeneratorRuntime().wrap(function pauseAttachmentUploading$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          _context13.prev = 0;
          attachmentId = action.payload.attachmentId;

          if (!getCustomUploader()) {
            _context13.next = 7;
            break;
          }

          isPaused = pauseUpload(attachmentId);

          if (!isPaused) {
            _context13.next = 7;
            break;
          }

          _context13.next = 7;
          return put(updateAttachmentUploadingStateAC(UPLOAD_STATE.PAUSED, attachmentId));

        case 7:
          _context13.next = 13;
          break;

        case 9:
          _context13.prev = 9;
          _context13.t0 = _context13["catch"](0);
          console.log('error in pause attachment uploading', _context13.t0);

        case 13:
        case "end":
          return _context13.stop();
      }
    }
  }, _marked13$1, null, [[0, 9]]);
}

function resumeAttachmentUploading(action) {
  var attachmentId, isResumed;
  return _regeneratorRuntime().wrap(function resumeAttachmentUploading$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          _context14.prev = 0;
          attachmentId = action.payload.attachmentId;
          console.log('resume for attachment ... ', attachmentId);

          if (!getCustomUploader()) {
            _context14.next = 8;
            break;
          }

          isResumed = resumeUpload(attachmentId);

          if (!isResumed) {
            _context14.next = 8;
            break;
          }

          _context14.next = 8;
          return put(updateAttachmentUploadingStateAC(UPLOAD_STATE.UPLOADING, attachmentId));

        case 8:
          _context14.next = 14;
          break;

        case 10:
          _context14.prev = 10;
          _context14.t0 = _context14["catch"](0);
          console.log('error in resume attachment uploading', _context14.t0);

        case 14:
        case "end":
          return _context14.stop();
      }
    }
  }, _marked14$1, null, [[0, 10]]);
}

function MessageSaga() {
  return _regeneratorRuntime().wrap(function MessageSaga$(_context15) {
    while (1) {
      switch (_context15.prev = _context15.next) {
        case 0:
          _context15.next = 2;
          return takeEvery(SEND_MESSAGE, sendMessage);

        case 2:
          _context15.next = 4;
          return takeEvery(SEND_TEXT_MESSAGE, sendTextMessage);

        case 4:
          _context15.next = 6;
          return takeEvery(FORWARD_MESSAGE, forwardMessage);

        case 6:
          _context15.next = 8;
          return takeEvery(RESEND_MESSAGE, resendMessage);

        case 8:
          _context15.next = 10;
          return takeLatest(EDIT_MESSAGE, editMessage);

        case 10:
          _context15.next = 12;
          return takeEvery(DELETE_MESSAGE, deleteMessage);

        case 12:
          _context15.next = 14;
          return takeLatest(GET_MESSAGES, getMessagesQuery);

        case 14:
          _context15.next = 16;
          return takeLatest(GET_MESSAGES_ATTACHMENTS, getMessageAttachments);

        case 16:
          _context15.next = 18;
          return takeLatest(LOAD_MORE_MESSAGES_ATTACHMENTS, loadMoreMessageAttachments);

        case 18:
          _context15.next = 20;
          return takeLatest(ADD_REACTION, addReaction);

        case 20:
          _context15.next = 22;
          return takeLatest(DELETE_REACTION, deleteReaction);

        case 22:
          _context15.next = 24;
          return takeEvery(LOAD_MORE_MESSAGES, loadMoreMessages);

        case 24:
          _context15.next = 26;
          return takeEvery(PAUSE_ATTACHMENT_UPLOADING, pauseAttachmentUploading);

        case 26:
          _context15.next = 28;
          return takeEvery(RESUME_ATTACHMENT_UPLOADING, resumeAttachmentUploading);

        case 28:
        case "end":
          return _context15.stop();
      }
    }
  }, _marked15$1);
}

var _marked$3 = /*#__PURE__*/_regeneratorRuntime().mark(getMembers),
    _marked2$2 = /*#__PURE__*/_regeneratorRuntime().mark(loadMoreMembers),
    _marked3$2 = /*#__PURE__*/_regeneratorRuntime().mark(addMembers),
    _marked4$2 = /*#__PURE__*/_regeneratorRuntime().mark(kickMemberFromChannel),
    _marked5$2 = /*#__PURE__*/_regeneratorRuntime().mark(blockMember),
    _marked6$2 = /*#__PURE__*/_regeneratorRuntime().mark(changeMemberRole),
    _marked7$2 = /*#__PURE__*/_regeneratorRuntime().mark(reportMember),
    _marked8$2 = /*#__PURE__*/_regeneratorRuntime().mark(getRoles),
    _marked9$2 = /*#__PURE__*/_regeneratorRuntime().mark(MembersSaga);

function getMembers(action) {
  var payload, channelId, SceytChatClient, membersQueryBuilder, membersQuery, _yield$call, members;

  return _regeneratorRuntime().wrap(function getMembers$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          payload = action.payload;
          channelId = payload.channelId;
          SceytChatClient = getClient();
          membersQueryBuilder = new SceytChatClient.chatClient.MemberListQueryBuilder(channelId);
          membersQueryBuilder.all().byAffiliationOrder().orderKeyByUsername().limit(50);
          _context.next = 8;
          return call(membersQueryBuilder.build);

        case 8:
          membersQuery = _context.sent;
          query.membersQuery = membersQuery;
          _context.next = 12;
          return put(setMembersLoadingStateAC(LOADING_STATE.LOADING));

        case 12:
          _context.next = 14;
          return call(membersQuery.loadNextPage);

        case 14:
          _yield$call = _context.sent;
          members = _yield$call.members;
          _context.next = 18;
          return put(setMembersToListAC(members));

        case 18:
          _context.next = 20;
          return put(setMembersLoadingStateAC(LOADING_STATE.LOADED));

        case 20:
          _context.next = 26;
          break;

        case 22:
          _context.prev = 22;
          _context.t0 = _context["catch"](0);
          console.log('ERROR in get member - ', _context.t0.message);

        case 26:
        case "end":
          return _context.stop();
      }
    }
  }, _marked$3, null, [[0, 22]]);
}

function loadMoreMembers(action) {
  var payload, limit, membersQuery, _yield$call2, members;

  return _regeneratorRuntime().wrap(function loadMoreMembers$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          payload = action.payload;
          limit = payload.limit;
          membersQuery = query.membersQuery;

          if (limit && membersQuery) {
            membersQuery.limit = limit;
          }

          _context2.next = 7;
          return put(setMembersLoadingStateAC(LOADING_STATE.LOADING));

        case 7:
          _context2.next = 9;
          return call(membersQuery.loadNextPage);

        case 9:
          _yield$call2 = _context2.sent;
          members = _yield$call2.members;
          _context2.next = 13;
          return put(addMembersToListAC(members));

        case 13:
          _context2.next = 15;
          return put(setMembersLoadingStateAC(LOADING_STATE.LOADED));

        case 15:
          _context2.next = 20;
          break;

        case 17:
          _context2.prev = 17;
          _context2.t0 = _context2["catch"](0);

        case 20:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2$2, null, [[0, 17]]);
}

function addMembers(action) {
  var payload, members, channelId, channel, membersToAdd, addedMembers, membersIds, messageToSend;
  return _regeneratorRuntime().wrap(function addMembers$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.prev = 0;
          payload = action.payload;
          members = payload.members, channelId = payload.channelId;
          _context3.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context3.sent;

          if (!channel) {
            _context3.next = 21;
            break;
          }

          membersToAdd = members.map(function (mem) {
            var memberBuilder = channel.createMemberBuilder(mem.id);
            return memberBuilder.setRole(mem.role).create();
          });
          _context3.next = 10;
          return call(channel.addMembers, membersToAdd);

        case 10:
          addedMembers = _context3.sent;

          if (!(channel.type === CHANNEL_TYPE.PRIVATE)) {
            _context3.next = 17;
            break;
          }

          membersIds = [];
          addedMembers.forEach(function (mem) {
            membersIds.push(mem.id);
          });
          messageToSend = {
            metadata: {
              m: membersIds
            },
            body: 'AM',
            mentionedMembers: [],
            attachments: [],
            type: 'system'
          };
          _context3.next = 17;
          return put(sendTextMessageAC(messageToSend, channelId, CONNECTION_STATUS.CONNECTED));

        case 17:
          _context3.next = 19;
          return put(addMembersToListAC(addedMembers));

        case 19:
          _context3.next = 21;
          return put(updateChannelDataAC(channel.id, {
            memberCount: channel.memberCount
          }));

        case 21:
          _context3.next = 26;
          break;

        case 23:
          _context3.prev = 23;
          _context3.t0 = _context3["catch"](0);
          console.log('error on add members... ', _context3.t0);

        case 26:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3$2, null, [[0, 23]]);
}

function kickMemberFromChannel(action) {
  var payload, memberId, channelId, channel, removedMembers, membersIds, messageToSend;
  return _regeneratorRuntime().wrap(function kickMemberFromChannel$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.prev = 0;
          payload = action.payload;
          memberId = payload.memberId, channelId = payload.channelId;
          _context4.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context4.sent;
          _context4.next = 8;
          return call(channel.kickMembers, [memberId]);

        case 8:
          removedMembers = _context4.sent;

          if (!(channel.type === CHANNEL_TYPE.PRIVATE)) {
            _context4.next = 15;
            break;
          }

          membersIds = [];
          removedMembers.forEach(function (mem) {
            membersIds.push(mem.id);
          });
          messageToSend = {
            metadata: {
              m: membersIds
            },
            body: 'RM',
            mentionedMembers: [],
            attachments: [],
            type: 'system'
          };
          _context4.next = 15;
          return put(sendTextMessageAC(messageToSend, channelId, CONNECTION_STATUS.CONNECTED));

        case 15:
          _context4.next = 17;
          return put(removeMemberFromListAC(removedMembers));

        case 17:
          _context4.next = 19;
          return put(updateChannelDataAC(channel.id, {
            memberCount: channel.memberCount
          }));

        case 19:
          _context4.next = 23;
          break;

        case 21:
          _context4.prev = 21;
          _context4.t0 = _context4["catch"](0);

        case 23:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4$2, null, [[0, 21]]);
}

function blockMember(action) {
  var payload, memberId, channelId, channel, removedMembers;
  return _regeneratorRuntime().wrap(function blockMember$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.prev = 0;
          payload = action.payload;
          memberId = payload.memberId, channelId = payload.channelId;
          _context5.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context5.sent;
          _context5.next = 8;
          return call(channel.blockMembers, [memberId]);

        case 8:
          removedMembers = _context5.sent;
          _context5.next = 11;
          return put(removeMemberFromListAC(removedMembers));

        case 11:
          _context5.next = 13;
          return put(updateChannelDataAC(channel.id, {
            memberCount: channel.memberCount
          }));

        case 13:
          _context5.next = 17;
          break;

        case 15:
          _context5.prev = 15;
          _context5.t0 = _context5["catch"](0);

        case 17:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5$2, null, [[0, 15]]);
}

function changeMemberRole(action) {
  var payload, channelId, members, channel, updatedMembers;
  return _regeneratorRuntime().wrap(function changeMemberRole$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.prev = 0;
          payload = action.payload;
          channelId = payload.channelId, members = payload.members;
          _context6.next = 5;
          return call(getChannelFromMap, channelId);

        case 5:
          channel = _context6.sent;
          _context6.next = 8;
          return call(channel.changeMembersRole, members);

        case 8:
          updatedMembers = _context6.sent;
          _context6.next = 11;
          return put(updateMembersAC(updatedMembers));

        case 11:
          _context6.next = 16;
          break;

        case 13:
          _context6.prev = 13;
          _context6.t0 = _context6["catch"](0);
          console.log('error in change member role');

        case 16:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6$2, null, [[0, 13]]);
}

function reportMember(action) {
  var reportData, SceytChatClient;
  return _regeneratorRuntime().wrap(function reportMember$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          reportData = action.payload.reportData;
          SceytChatClient = getClient();
          _context7.prev = 2;
          _context7.next = 5;
          return call(SceytChatClient.chatClient.userReport, reportData.reportReason, reportData.userId, reportData.messageIds, reportData.reportDescription);

        case 5:
          _context7.next = 10;
          break;

        case 7:
          _context7.prev = 7;
          _context7.t0 = _context7["catch"](2);
          console.log('ERROR report user', _context7.t0.message);

        case 10:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked7$2, null, [[2, 7]]);
}

function getRoles() {
  var SceytChatClient, roles;
  return _regeneratorRuntime().wrap(function getRoles$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _context8.prev = 0;
          SceytChatClient = getClient();
          _context8.next = 4;
          return call(SceytChatClient.chatClient.getRoles);

        case 4:
          roles = _context8.sent;
          _context8.next = 7;
          return put(getRolesSuccess(roles));

        case 7:
          _context8.next = 12;
          break;

        case 9:
          _context8.prev = 9;
          _context8.t0 = _context8["catch"](0);
          console.log('error in get roles');

        case 12:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked8$2, null, [[0, 9]]);
}

function MembersSaga() {
  return _regeneratorRuntime().wrap(function MembersSaga$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          _context9.next = 2;
          return takeLatest(GET_MEMBERS, getMembers);

        case 2:
          _context9.next = 4;
          return takeLatest(LOAD_MORE_MEMBERS, loadMoreMembers);

        case 4:
          _context9.next = 6;
          return takeLatest(ADD_MEMBERS, addMembers);

        case 6:
          _context9.next = 8;
          return takeLatest(KICK_MEMBER, kickMemberFromChannel);

        case 8:
          _context9.next = 10;
          return takeLatest(BLOCK_MEMBER, blockMember);

        case 10:
          _context9.next = 12;
          return takeLatest(REPORT_MEMBER, reportMember);

        case 12:
          _context9.next = 14;
          return takeLatest(CHANGE_MEMBER_ROLE, changeMemberRole);

        case 14:
          _context9.next = 16;
          return takeLatest(GET_ROLES, getRoles);

        case 16:
        case "end":
          return _context9.stop();
      }
    }
  }, _marked9$2);
}

var _marked$4 = /*#__PURE__*/_regeneratorRuntime().mark(getContacts),
    _marked2$3 = /*#__PURE__*/_regeneratorRuntime().mark(getRoles$1),
    _marked3$3 = /*#__PURE__*/_regeneratorRuntime().mark(blockUser),
    _marked4$3 = /*#__PURE__*/_regeneratorRuntime().mark(unblockUser),
    _marked5$3 = /*#__PURE__*/_regeneratorRuntime().mark(updateProfile),
    _marked6$3 = /*#__PURE__*/_regeneratorRuntime().mark(getUsers),
    _marked7$3 = /*#__PURE__*/_regeneratorRuntime().mark(loadMoreUsers),
    _marked8$3 = /*#__PURE__*/_regeneratorRuntime().mark(MembersSaga$1);

function getContacts() {
  var SceytChatClient, contactsData;
  return _regeneratorRuntime().wrap(function getContacts$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          SceytChatClient = getClient();
          _context.next = 4;
          return call(SceytChatClient.chatClient.getAllContacts);

        case 4:
          contactsData = _context.sent;
          _context.next = 7;
          return put(setContactsAC(JSON.parse(JSON.stringify(contactsData))));

        case 7:
          _context.next = 9;
          return put(setContactsLoadingStateAC(LOADING_STATE.LOADED));

        case 9:
          _context.next = 15;
          break;

        case 11:
          _context.prev = 11;
          _context.t0 = _context["catch"](0);
          console.log('ERROR in get contacts - :', _context.t0.message);

        case 15:
        case "end":
          return _context.stop();
      }
    }
  }, _marked$4, null, [[0, 11]]);
}

function getRoles$1() {
  var SceytChatClient, roles;
  return _regeneratorRuntime().wrap(function getRoles$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          SceytChatClient = getClient();
          _context2.next = 4;
          return call(SceytChatClient.chatClient.getRoles);

        case 4:
          roles = _context2.sent;
          _context2.next = 7;
          return put(setRolesAC(roles));

        case 7:
          _context2.next = 13;
          break;

        case 9:
          _context2.prev = 9;
          _context2.t0 = _context2["catch"](0);
          console.log('ERROR in get roles - ', _context2.t0.message);

        case 13:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2$3, null, [[0, 9]]);
}

function blockUser(action) {
  var SceytChatClient, payload, userIds, blockedUsers, activeChannelId, activeChannel;
  return _regeneratorRuntime().wrap(function blockUser$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.prev = 0;
          SceytChatClient = getClient();
          payload = action.payload;
          userIds = payload.userIds;
          _context3.next = 6;
          return call(SceytChatClient.chatClient.blockUsers, userIds);

        case 6:
          blockedUsers = _context3.sent;
          _context3.next = 9;
          return call(getActiveChannelId);

        case 9:
          activeChannelId = _context3.sent;
          _context3.next = 12;
          return call(getChannelFromMap, activeChannelId);

        case 12:
          activeChannel = _context3.sent;

          if (!(activeChannel.peer && activeChannel.peer.id === blockedUsers[0].id)) {
            _context3.next = 16;
            break;
          }

          _context3.next = 16;
          return put(updateChannelDataAC(activeChannelId, {
            peer: blockedUsers[0]
          }));

        case 16:
          _context3.next = 21;
          break;

        case 18:
          _context3.prev = 18;
          _context3.t0 = _context3["catch"](0);
          console.log('error in block users', _context3.t0.message);

        case 21:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3$3, null, [[0, 18]]);
}

function unblockUser(action) {
  var SceytChatClient, payload, userIds, unblockedUsers, activeChannelId, activeChannel;
  return _regeneratorRuntime().wrap(function unblockUser$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.prev = 0;
          SceytChatClient = getClient();
          payload = action.payload;
          userIds = payload.userIds;
          _context4.next = 6;
          return call(SceytChatClient.chatClient.unblockUsers, userIds);

        case 6:
          unblockedUsers = _context4.sent;
          _context4.next = 9;
          return call(getActiveChannelId);

        case 9:
          activeChannelId = _context4.sent;
          _context4.next = 12;
          return call(getChannelFromMap, activeChannelId);

        case 12:
          activeChannel = _context4.sent;

          if (!(activeChannel.peer && activeChannel.peer.id === unblockedUsers[0].id)) {
            _context4.next = 16;
            break;
          }

          _context4.next = 16;
          return put(updateChannelDataAC(activeChannelId, {
            peer: unblockedUsers[0]
          }));

        case 16:
          _context4.next = 21;
          break;

        case 18:
          _context4.prev = 18;
          _context4.t0 = _context4["catch"](0);
          console.log('error in unblock users', _context4.t0.message);

        case 21:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4$3, null, [[0, 18]]);
}

function updateProfile(action) {
  var payload, user, firstName, lastName, avatarUrl, metadata, avatarFile, presence, updateUserProfileData, SceytChatClient, fileToUpload, updatedUser;
  return _regeneratorRuntime().wrap(function updateProfile$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.prev = 0;
          payload = action.payload;
          user = payload.user, firstName = payload.firstName, lastName = payload.lastName, avatarUrl = payload.avatarUrl, metadata = payload.metadata, avatarFile = payload.avatarFile, presence = payload.presence;
          updateUserProfileData = {};
          SceytChatClient = getClient();

          if (!avatarFile) {
            _context5.next = 12;
            break;
          }

          fileToUpload = {
            data: avatarFile,
            progress: function progress(progressPercent) {
              console.log('upload percent - ', progressPercent);
            }
          };
          _context5.next = 9;
          return call(SceytChatClient.chatClient.uploadFile, fileToUpload);

        case 9:
          updateUserProfileData.avatarUrl = _context5.sent;
          _context5.next = 13;
          break;

        case 12:
          if (avatarUrl && user.avatarUrl !== avatarUrl) {
            updateUserProfileData.avatarUrl = avatarUrl;
          }

        case 13:
          if (firstName && user.firstName !== firstName) {
            updateUserProfileData.firstName = firstName;
          }

          if (lastName && user.lastName !== lastName) {
            updateUserProfileData.lastName = lastName;
          }

          if (user.metadata !== metadata) {
            updateUserProfileData.metadata = metadata;
          }

          _context5.next = 19;
          return call(SceytChatClient.chatClient.setProfile, updateUserProfileData);

        case 19:
          updatedUser = _context5.sent;
          _context5.next = 22;
          return put(updateUserProfileAC(_extends({}, updatedUser)));

        case 22:
          _context5.next = 27;
          break;

        case 24:
          _context5.prev = 24;
          _context5.t0 = _context5["catch"](0);
          console.log(_context5.t0, 'Error on update user');

        case 27:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5$3, null, [[0, 24]]);
}

function getUsers(action) {
  var payload, params, SceytChatClient, usersQueryBuilder, usersQuery, _yield$call, users;

  return _regeneratorRuntime().wrap(function getUsers$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.prev = 0;
          payload = action.payload;
          params = payload.params;
          SceytChatClient = getClient();
          usersQueryBuilder = new SceytChatClient.chatClient.UserListQueryBuilder();

          if (params.query) {
            usersQueryBuilder.query(params.query);
          }

          if (params.limit) {
            usersQueryBuilder.limit(params.limit);
          }

          if (params.order === 'firstname') {
            usersQueryBuilder.orderByFirstname();
          }

          if (params.order === 'lastname') {
            usersQueryBuilder.orderByLastname();
          }

          if (params.order === 'username') {
            usersQueryBuilder.orderByUsername();
          }

          if (params.filter === 'all') {
            usersQueryBuilder.filterByAll();
          }

          if (params.filter === 'firstname') {
            usersQueryBuilder.filterByFirstname();
          }

          if (params.filter === 'lastname') {
            usersQueryBuilder.filterByLastname();
          }

          if (params.filter === 'username') {
            usersQueryBuilder.filterByUsername();
          }

          _context6.next = 16;
          return call(usersQueryBuilder.build);

        case 16:
          usersQuery = _context6.sent;
          query.usersQuery = usersQuery;
          _context6.next = 20;
          return put(setUsersLoadingStateAC(LOADING_STATE.LOADING));

        case 20:
          _context6.next = 22;
          return call(usersQuery.loadNextPage);

        case 22:
          _yield$call = _context6.sent;
          users = _yield$call.users;
          _context6.next = 26;
          return put(setUsersAC(users));

        case 26:
          _context6.next = 28;
          return put(setUsersLoadingStateAC(LOADING_STATE.LOADED));

        case 28:
          _context6.next = 34;
          break;

        case 30:
          _context6.prev = 30;
          _context6.t0 = _context6["catch"](0);
          console.log('ERROR on get users', _context6.t0.message);

        case 34:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6$3, null, [[0, 30]]);
}

function loadMoreUsers(action) {
  var payload, limit, usersQuery, _yield$call2, users;

  return _regeneratorRuntime().wrap(function loadMoreUsers$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          _context7.prev = 0;
          payload = action.payload;
          limit = payload.limit;
          usersQuery = query.usersQuery;

          if (limit) {
            usersQuery.limit = limit;
          }

          _context7.next = 7;
          return put(setUsersLoadingStateAC(LOADING_STATE.LOADING));

        case 7:
          _context7.next = 9;
          return call(usersQuery.loadNextPage);

        case 9:
          _yield$call2 = _context7.sent;
          users = _yield$call2.users;
          _context7.next = 13;
          return put(addUsersAC(users));

        case 13:
          _context7.next = 15;
          return put(setUsersLoadingStateAC(LOADING_STATE.LOADED));

        case 15:
          _context7.next = 21;
          break;

        case 17:
          _context7.prev = 17;
          _context7.t0 = _context7["catch"](0);
          console.log('ERROR load more users', _context7.t0.message);

        case 21:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked7$3, null, [[0, 17]]);
}

function MembersSaga$1() {
  return _regeneratorRuntime().wrap(function MembersSaga$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _context8.next = 2;
          return takeLatest(GET_CONTACTS, getContacts);

        case 2:
          _context8.next = 4;
          return takeLatest(GET_USERS, getUsers);

        case 4:
          _context8.next = 6;
          return takeLatest(LOAD_MORE_USERS, loadMoreUsers);

        case 6:
          _context8.next = 8;
          return takeLatest(GET_ROLES$1, getRoles$1);

        case 8:
          _context8.next = 10;
          return takeLatest(BLOCK_USERS, blockUser);

        case 10:
          _context8.next = 12;
          return takeLatest(UNBLOCK_USERS, unblockUser);

        case 12:
          _context8.next = 14;
          return takeLatest(UPDATE_PROFILE, updateProfile);

        case 14:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked8$3);
}

var _marked$5 = /*#__PURE__*/_regeneratorRuntime().mark(rootSaga);
function rootSaga() {
  return _regeneratorRuntime().wrap(function rootSaga$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return all([ChannelsSaga(), MessageSaga(), MembersSaga(), MembersSaga$1()]);

        case 2:
        case "end":
          return _context.stop();
      }
    }
  }, _marked$5);
}

var sagaMiddleware = createSagaMiddleware();
var store = configureStore({
  reducer: reducers,
  middleware: function middleware(getDefaultMiddleware) {
    return getDefaultMiddleware({
      thunk: false,
      serializableCheck: false
    }).concat(sagaMiddleware);
  },
  devTools: process.env.NODE_ENV !== 'production'
});
sagaMiddleware.run(rootSaga);

var _templateObject$2, _templateObject2$2, _templateObject3$2;
var Container = styled.div(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  height: 100vh;\n"])));
var ChatContainer = styled.div(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  //height: ", ";\n  height: 100%;\n  min-width: 1200px;\n"])), function (props) {
  return props.withHeader ? 'calc(100vh - 60px)' : '100vh';
});
var Chat = styled.div(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteralLoose(["\n  display: flex;\n"])));

var connectionStatusSelector = function connectionStatusSelector(store) {
  return store.UserReducer.connectionStatus;
};
var contactListSelector = function contactListSelector(store) {
  return store.UserReducer.contactList;
};
var contactsMapSelector = function contactsMapSelector(store) {
  return store.UserReducer.contactsMap;
};
var rolesMapSelector = function rolesMapSelector(store) {
  return store.UserReducer.rolesMap;
};
var userSelector = function userSelector(store) {
  return store.UserReducer.user;
};
var usersListSelector = function usersListSelector(store) {
  return store.UserReducer.usersList;
};
var usersLoadingStateSelector = function usersLoadingStateSelector(store) {
  return store.UserReducer.usersLoadingState;
};
var browserTabIsActiveSelector = function browserTabIsActiveSelector(store) {
  return store.UserReducer.browserTabIsActive;
};

var channelsSelector = function channelsSelector(store) {
  return store.ChannelReducer.channels;
};
var channelsForForwardSelector = function channelsForForwardSelector(store) {
  return store.ChannelReducer.channelsForForward;
};
var deletedChannelSelector = function deletedChannelSelector(store) {
  return store.ChannelReducer.deletedChannel;
};
var addedChannelSelector = function addedChannelSelector(store) {
  return store.ChannelReducer.addedChannel;
};
var addedToChannelSelector = function addedToChannelSelector(store) {
  return store.ChannelReducer.addedToChannel;
};
var hiddenChannelSelector = function hiddenChannelSelector(store) {
  return store.ChannelReducer.hiddenChannel;
};
var visibleChannelSelector = function visibleChannelSelector(store) {
  return store.ChannelReducer.visibleChannel;
};
var activeChannelSelector = function activeChannelSelector(store) {
  return store.ChannelReducer.activeChannel;
};
var channelsLoadingState = function channelsLoadingState(store) {
  return store.ChannelReducer.channelsLoadingState;
};
var channelsHasNextSelector = function channelsHasNextSelector(store) {
  return store.ChannelReducer.channelsHasNext;
};
var channelsForForwardHasNextSelector = function channelsForForwardHasNextSelector(store) {
  return store.ChannelReducer.channelsForForwardHasNext;
};
var channelInfoIsOpenSelector = function channelInfoIsOpenSelector(store) {
  return store.ChannelReducer.channelInfoIsOpen;
};
var channelEditModeSelector = function channelEditModeSelector(store) {
  return store.ChannelReducer.channelEditMode;
};
var typingIndicatorSelector = function typingIndicatorSelector(channelId) {
  return function (store) {
    return store.ChannelReducer.typingIndicator[channelId];
  };
};
var channelListWidthSelector = function channelListWidthSelector(store) {
  return store.ChannelReducer.channelListWidth;
};
var isDraggingSelector = function isDraggingSelector(store) {
  return store.ChannelReducer.isDragging;
};
var draggedAttachmentsSelector = function draggedAttachmentsSelector(store) {
  return store.ChannelReducer.draggedAttachments;
};

var hideUserPresence;
var setHideUserPresence = function setHideUserPresence(callback) {
  hideUserPresence = callback;
};

var SceytChat = function SceytChat(_ref) {
  var client = _ref.client,
      avatarColors = _ref.avatarColors,
      children = _ref.children,
      showOnlyContactUsers = _ref.showOnlyContactUsers,
      logoSrc = _ref.logoSrc,
      CustomUploader = _ref.CustomUploader,
      sendAttachmentsAsSeparateMessages = _ref.sendAttachmentsAsSeparateMessages,
      customColors = _ref.customColors,
      hideUserPresence = _ref.hideUserPresence;
  var dispatch = useDispatch();
  var contactsMap = useSelector(contactsMapSelector);
  var childrenArr = Children.toArray(children);
  var draggingSelector = useSelector(isDraggingSelector, shallowEqual);
  var OtherChildren = childrenArr.filter(function (_ref2) {
    var type = _ref2.type;
    return type.name !== 'SceytChatHeader';
  });
  var SceytChatHeader = childrenArr.find(function (_ref3) {
    var type = _ref3.type;
    return type.name === 'SceytChatHeader';
  });

  var _useState = useState(null),
      SceytChatClient = _useState[0],
      setSceytChatClient = _useState[1];

  var _useState2 = useState(true),
      tabIsActive = _useState2[0],
      setTabIsActive = _useState2[1];

  var hidden = null;
  var visibilityChange = null;

  if (typeof document.hidden !== 'undefined') {
    hidden = 'hidden';
    visibilityChange = 'visibilitychange';
  } else if (typeof document.msHidden !== 'undefined') {
    hidden = 'msHidden';
    visibilityChange = 'msvisibilitychange';
  } else if (typeof document.webkitHidden !== 'undefined') {
    hidden = 'webkitHidden';
    visibilityChange = 'webkitvisibilitychange';
  }

  var handleDropFile = function handleDropFile(e) {
    e.preventDefault();
    e.stopPropagation();
    dispatch(setIsDraggingAC(false));
  };

  var handleDragOver = function handleDragOver(e) {
    e.preventDefault();

    if (!draggingSelector) {
      dispatch(setIsDraggingAC(true));
    }
  };

  var handleVisibilityChange = function handleVisibilityChange() {
    if (document[hidden]) {
      setTabIsActive(false);
      dispatch(browserTabIsActiveAC(false));
    } else {
      setTabIsActive(true);
      dispatch(browserTabIsActiveAC(true));
    }
  };

  useEffect(function () {
    if (client) {
      setClient(client);
      setSceytChatClient(client);
      dispatch(setUserAC(client.chatClient.user));
      dispatch(watchForEventsAC());
      console.log('client.chatClient.connectStatus.. ... ', client.chatClient.connectStatus);
      dispatch(setConnectionStatusAC(client.chatClient.connectStatus));
    } else {
      console.log('destroy session... ');
      clearMessagesMap();
      removeAllMessages();
      setActiveChannelId('');
      destroyChannelsMap();
      dispatch(destroySession());
    }
  }, [client]);
  useEffect(function () {
    if (CustomUploader) {
      setCustomUploader(CustomUploader);
    }

    if (customColors) {
      if (customColors.primaryColor) {
        colors.primary = customColors.primaryColor;
      }

      if (customColors.textColor1) {
        colors.gray6 = customColors.textColor1;
      }

      if (customColors.textColor2) {
        colors.gray8 = customColors.textColor2;
      }

      if (customColors.textColor3) {
        colors.gray9 = customColors.textColor3;
      }

      if (customColors.defaultAvatarBackground) {
        colors.defaultAvatarBackground = customColors.defaultAvatarBackground;
      }

      if (customColors.deletedUserAvatarBackground) {
        colors.deleteUserIconBackground = customColors.deletedUserAvatarBackground;
      }
    }

    if (sendAttachmentsAsSeparateMessages) {
      setSendAttachmentsAsSeparateMessages(sendAttachmentsAsSeparateMessages);
    }

    if (logoSrc) {
      setNotificationLogoSrc(logoSrc);
    }

    if (avatarColors) {
      setAvatarColor(avatarColors);
    }

    if (showOnlyContactUsers) {
      setShowOnlyContactUsers(showOnlyContactUsers);
    }

    try {
      if (window.Notification && Notification.permission === 'default') {
        Promise.resolve(Notification.requestPermission()).then(function (permission) {
          console.log('permission:', permission);
        });
      }
    } catch (e) {
      console.error('safari Notification request permission', e);
    }

    window.sceytTabNotifications = null;
    window.sceytTabUrl = window.location.href;
    document.addEventListener(visibilityChange, handleVisibilityChange, false);
    return function () {
      document.removeEventListener(visibilityChange, handleVisibilityChange);
    };
  }, [customColors]);
  useEffect(function () {
    if (tabIsActive) {
      console.log('tab is active');

      if (window.sceytTabNotifications) {
        window.sceytTabNotifications.close();
      }
    }
  }, [tabIsActive]);
  useEffect(function () {
    if (hideUserPresence) {
      setHideUserPresence(hideUserPresence);
    }

    if (contactsMap) {
      setContactsMap(contactsMap);
    }
  }, [contactsMap]);
  return React__default.createElement(React__default.Fragment, null, SceytChatClient ? React__default.createElement(React__default.Fragment, null, SceytChatHeader, React__default.createElement(ChatContainer, {
    onDrop: handleDropFile,
    onDragOver: handleDragOver,
    className: 'sceyt-chat-container',
    withHeader: SceytChatHeader
  }, OtherChildren)) : '');
};

var SceytChatContainer = function SceytChatContainer(_ref) {
  var client = _ref.client,
      avatarColors = _ref.avatarColors,
      children = _ref.children,
      showOnlyContactUsers = _ref.showOnlyContactUsers,
      sendAttachmentsAsSeparateMessages = _ref.sendAttachmentsAsSeparateMessages,
      logoSrc = _ref.logoSrc,
      CustomUploader = _ref.CustomUploader,
      customColors = _ref.customColors,
      hideUserPresence = _ref.hideUserPresence;
  return React__default.createElement(Provider, {
    store: store
  }, React__default.createElement(SceytChat, {
    client: client,
    avatarColors: avatarColors,
    children: children,
    showOnlyContactUsers: showOnlyContactUsers,
    logoSrc: logoSrc,
    CustomUploader: CustomUploader,
    sendAttachmentsAsSeparateMessages: sendAttachmentsAsSeparateMessages,
    customColors: customColors,
    hideUserPresence: hideUserPresence
  }));
};

var _path$6;

function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$7.apply(this, arguments);
}

function SvgPicture(props) {
  return /*#__PURE__*/createElement("svg", _extends$7({
    width: 18,
    height: 18,
    viewBox: "0 0 18.01 18.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$6 || (_path$6 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M3.614 2.052C4.366 1.65 5.107 1.5 6.798 1.5h4.404c1.691 0 2.432.15 3.184.552.672.36 1.203.89 1.562 1.562.402.752.552 1.493.552 3.184v4.404c0 1.691-.15 2.432-.552 3.184a3.763 3.763 0 01-1.562 1.562c-.752.402-1.493.552-3.184.552H6.798c-1.691 0-2.432-.15-3.184-.552a3.764 3.764 0 01-1.562-1.562c-.402-.752-.552-1.493-.552-3.184V6.798c0-1.691.15-2.432.552-3.184.36-.672.89-1.203 1.562-1.562zm7.16 7.07a.297.297 0 01.482.004l3.04 4.193c.101.139.074.335-.06.44a.297.297 0 01-.183.062h-9.57a.309.309 0 01-.304-.314c0-.07.022-.137.064-.192l2.22-2.954a.297.297 0 01.473-.008l1.528 1.861 2.31-3.092zM5.785 6.857a1.071 1.071 0 100-2.143 1.071 1.071 0 000 2.143z",
    fill: "#818C99"
  })));
}

var _path$7;

function _extends$8() {
  _extends$8 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$8.apply(this, arguments);
}

function SvgVideoCall(props) {
  return /*#__PURE__*/createElement("svg", _extends$8({
    width: 16,
    height: 16,
    viewBox: "0 0 16.01 16.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$7 || (_path$7 = /*#__PURE__*/createElement("path", {
    d: "M.667 4.875C.667 3.839 1.507 3 2.542 3h6.875c1.036 0 1.875.84 1.875 1.875v6.25c0 1.036-.84 1.875-1.875 1.875H2.542a1.875 1.875 0 01-1.875-1.875v-6.25zM12.542 6.125l2.11-1.687a.625.625 0 011.015.488v6.149a.625.625 0 01-1.015.488l-2.11-1.688v-3.75z",
    fill: "CurrentColor"
  })));
}

var _path$8;

function _extends$9() {
  _extends$9 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$9.apply(this, arguments);
}

function SvgChoseFile(props) {
  return /*#__PURE__*/createElement("svg", _extends$9({
    width: 18,
    height: 18,
    viewBox: "0 0 18.01 18.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$8 || (_path$8 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M3 3.75A2.25 2.25 0 015.25 1.5h7.5A2.25 2.25 0 0115 3.75v10.5a2.25 2.25 0 01-2.25 2.25h-7.5A2.25 2.25 0 013 14.25V3.75zm2.25 6.938c0-.311.252-.563.563-.563h6.375a.563.563 0 010 1.125H5.811a.563.563 0 01-.562-.563zm.563 2.062a.563.563 0 000 1.125h3.375a.563.563 0 000-1.125H5.812z",
    fill: "CurrentColor"
  })));
}

var _path$9, _path2;

function _extends$a() {
  _extends$a = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$a.apply(this, arguments);
}

function SvgVoiceIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$a({
    width: 16,
    height: 16,
    viewBox: "0 0 17 17",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$9 || (_path$9 = /*#__PURE__*/createElement("path", {
    d: "M5.5 3.5a2.5 2.5 0 015 0v4a2.5 2.5 0 01-5 0v-4zM7.375 13.125a.625.625 0 111.25 0v1.25a.625.625 0 11-1.25 0v-1.25zM14 7.125a.625.625 0 11-1.25 0 .625.625 0 011.25 0zM3.25 7.125a.625.625 0 11-1.25 0 .625.625 0 011.25 0z",
    fill: "CurrentColor"
  })), _path2 || (_path2 = /*#__PURE__*/createElement("path", {
    d: "M8 13a6 6 0 006-6h-1.25a4.75 4.75 0 11-9.5 0H2a6 6 0 006 6z",
    fill: "CurrentColor"
  })));
}

var _rect, _path$a;

function _extends$b() {
  _extends$b = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$b.apply(this, arguments);
}

function SvgUnreadMention(props) {
  return /*#__PURE__*/createElement("svg", _extends$b({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _rect || (_rect = /*#__PURE__*/createElement("rect", {
    width: 20,
    height: 20,
    rx: 10,
    fill: "CurrentColor"
  })), _path$a || (_path$a = /*#__PURE__*/createElement("path", {
    d: "M10.004 16.087c-1.13 0-2.117-.229-2.96-.686a4.778 4.778 0 01-1.954-1.947c-.46-.84-.69-1.82-.69-2.942v-.405c0-1.116.24-2.106.72-2.972A5.064 5.064 0 017.14 5.12c.867-.48 1.859-.72 2.975-.72h.059c1.042 0 1.975.216 2.798.646a4.839 4.839 0 011.932 1.784c.464.76.696 1.621.696 2.585v.368c0 .66-.108 1.242-.324 1.748-.216.506-.519.9-.907 1.183a2.221 2.221 0 01-1.342.424c-.457 0-.85-.096-1.18-.287-.329-.192-.526-.443-.59-.752h-.073a1.193 1.193 0 01-.325.527c-.162.16-.36.285-.593.376a2.002 2.002 0 01-.734.136c-.403 0-.754-.098-1.054-.295a1.9 1.9 0 01-.693-.84c-.162-.364-.244-.794-.244-1.29v-.738c0-.482.083-.902.247-1.26.165-.36.401-.635.708-.827a1.998 1.998 0 011.08-.287c.364 0 .684.09.959.269.275.18.457.414.546.704h.059v-.192c0-.196.054-.352.162-.468a.577.577 0 01.442-.173c.182 0 .327.058.435.173.108.116.162.272.162.468v2.95c0 .25.077.45.229.6.152.15.351.226.597.226.26 0 .49-.101.686-.303.197-.201.348-.488.453-.859.106-.37.159-.805.159-1.301V9.45c0-.772-.183-1.463-.55-2.072a3.826 3.826 0 00-1.526-1.43c-.651-.345-1.39-.517-2.215-.517h-.06c-.894 0-1.685.197-2.374.59a4.084 4.084 0 00-1.603 1.663c-.381.715-.572 1.537-.572 2.466v.317c0 .924.185 1.734.553 2.43.369.695.891 1.23 1.567 1.607.676.376 1.464.564 2.363.564h.06c.334 0 .749-.037 1.245-.11.26-.035.43-.052.51-.052.142 0 .26.043.353.129.094.086.14.195.14.328a.51.51 0 01-.118.34.646.646 0 01-.339.198c-.477.123-1.086.185-1.829.185h-.066zm-1.18-5.545c0 .496.095.874.284 1.132.19.258.468.387.837.387.364 0 .642-.124.833-.373.192-.248.288-.608.288-1.08v-.597c0-.433-.102-.774-.306-1.025-.204-.25-.48-.376-.83-.376-.349 0-.62.132-.814.395-.195.262-.292.63-.292 1.102v.435z",
    fill: "#fff"
  })));
}

var _path$b, _path2$1, _path3;

function _extends$c() {
  _extends$c = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$c.apply(this, arguments);
}

function SvgDeletedUserAvatar(props) {
  return /*#__PURE__*/createElement("svg", _extends$c({
    width: 51,
    height: 51,
    viewBox: "0 0 51.01 51.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$b || (_path$b = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M25 50c13.807 0 25-11.193 25-25S38.807 0 25 0 0 11.193 0 25s11.193 25 25 25z",
    fill: "CurrentColor"
  })), _path2$1 || (_path2$1 = /*#__PURE__*/createElement("path", {
    d: "M49.75 25c0 13.669-11.081 24.75-24.75 24.75S.25 38.669.25 25 11.331.25 25 .25 49.75 11.331 49.75 25z",
    stroke: "#000",
    strokeOpacity: 0.08,
    strokeWidth: 0.5,
    strokeLinejoin: "round"
  })), _path3 || (_path3 = /*#__PURE__*/createElement("path", {
    d: "M25 11.934c3.294 0 5.896 1.135 8.298 3.331C35.664 17.43 37 20.382 37 23.468l-.02 10.08c-.134 1.801-1.374 3.135-3.176 3.135s-2.279-1.25-3.82-.995c-1.54.256-2.12 2.246-4.984 2.246-2.865 0-3.5-2-4.984-2.245-1.541-.256-2.018.994-3.82.994-1.735 0-3.086-1.253-3.177-3.134L13 23.469c0-3.087 1.336-6.04 3.702-8.204 2.302-2.105 5.003-3.331 8.298-3.331zm4.633 16.439c-.527-.545-1.43-.589-2.017-.099-1.477 1.235-2.95 1.235-4.45.482a4.437 4.437 0 01-.782-.482l-.14-.104c-.583-.376-1.39-.3-1.877.203a1.261 1.261 0 00.106 1.873c.277.232.73.54 1.335.845 2.468 1.237 5.228 1.237 7.72-.845.585-.49.633-1.329.105-1.873zM20 20.933a2 2 0 100 4 2 2 0 000-4zm10 0a2 2 0 100 4 2 2 0 000-4z",
    fill: "#fff"
  })));
}

var _path$c;

function _extends$d() {
  _extends$d = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$d.apply(this, arguments);
}

function SvgDevaultAvatar32(props) {
  return /*#__PURE__*/createElement("svg", _extends$d({
    width: 32,
    height: 32,
    viewBox: "0 0 32.01 32.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$c || (_path$c = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M24.946 29.267A15.926 15.926 0 0116 32c-3.602 0-6.926-1.19-9.6-3.199C2.514 25.882 0 21.235 0 16 0 7.163 7.163 0 16 0s16 7.163 16 16c0 5.523-2.798 10.392-7.054 13.267zM16 16.8c2.651 0 4.8-2.328 4.8-5.2 0-2.872-2.149-5.2-4.8-5.2s-4.8 2.328-4.8 5.2c0 2.872 2.149 5.2 4.8 5.2zm0 12c3.46 0 6.598-1.372 8.901-3.602A9.603 9.603 0 0016 19.2a9.603 9.603 0 00-8.901 5.998A12.758 12.758 0 0016 28.8z",
    fill: "CurrentColor"
  })));
}

var _templateObject$3, _templateObject2$3, _templateObject3$3, _templateObject4$2;

var Avatar = function Avatar(_ref) {
  var image = _ref.image,
      size = _ref.size,
      name = _ref.name,
      textSize = _ref.textSize,
      DeletedIcon = _ref.DeletedIcon,
      marginAuto = _ref.marginAuto,
      setDefaultAvatar = _ref.setDefaultAvatar;
  var isDeletedUserAvatar = !image && !name;
  var avatarText = '';

  if (!image && name) {
    var trimedName = name.trim();
    var splittedName = trimedName.split(' ');

    if (splittedName.length > 1 && splittedName[1]) {
      var firstWord = splittedName[0];
      var secondWord = splittedName[1];
      var firstCharOfFirstWord = firstWord.codePointAt(0);
      var firstCharOfSecondWord = secondWord.codePointAt(0);
      avatarText = (firstCharOfFirstWord ? String.fromCodePoint(firstCharOfFirstWord) : '') + "\n                    " + (firstCharOfSecondWord ? String.fromCodePoint(firstCharOfSecondWord) : '');
    } else {
      var _firstCharOfFirstWord = trimedName.codePointAt(0);

      avatarText = _firstCharOfFirstWord ? String.fromCodePoint(_firstCharOfFirstWord) : '';
    }
  }

  return React__default.createElement(Container$1, {
    marginAuto: marginAuto,
    size: size,
    isImage: !!(image || setDefaultAvatar),
    avatarName: name,
    textSize: textSize
  }, isDeletedUserAvatar ? DeletedIcon || React__default.createElement(DeletedAvatarWrapper, {
    color: colors.deleteUserIconBackground
  }) : !image ? setDefaultAvatar ? React__default.createElement(DefaultAvatarWrapper, {
    color: colors.defaultAvatarBackground
  }) : React__default.createElement("span", null, avatarText) : React__default.createElement(AvatarImage, {
    draggable: false,
    showImage: true,
    src: image,
    size: size,
    alt: ''
  }));
};
var Container$1 = styled.div(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteralLoose(["\n    display: flex;\n    align-items: center;\n    flex: 0 0 auto;\n    text-transform: uppercase;\n    justify-content: center;\n    width: ", ";\n    height: ", ";\n    border-radius: 50%;\n    color: #fff;\n    overflow: hidden;\n    margin: ", ";\n    ", ";\n  span {\n    text-transform: uppercase;\n    font-style: normal;\n    white-space: nowrap;\n    font-weight: 500;\n    font-size: ", "};\n  }\n  & > svg {\n    height: ", ";\n    width: ", ";\n  }\n\n"])), function (props) {
  return props.size ? props.size + "px" : '38px';
}, function (props) {
  return props.size ? props.size + "px" : '38px';
}, function (props) {
  return props.marginAuto ? 'auto' : '';
}, function (props) {
  return !props.isImage ? "background-color:" + generateAvatarColor(props.avatarName) + ";" : '';
}, function (props) {
  return props.textSize ? props.textSize + "px" : '14px';
}, function (props) {
  return props.size && props.size + "px";
}, function (props) {
  return props.size && props.size + "px";
});
var AvatarImage = styled.img(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteralLoose(["\n  visibility: ", ";\n  width: ", ";\n  height: ", ";\n"])), function (props) {
  return props.showImage ? 'visible' : 'hidden';
}, function (props) {
  return props.size + "px";
}, function (props) {
  return props.size + "px";
});
var DefaultAvatarWrapper = styled(SvgDevaultAvatar32)(_templateObject3$3 || (_templateObject3$3 = _taggedTemplateLiteralLoose(["\n  color: ", ";\n"])), function (props) {
  return props.color || colors.defaultAvatarBackground;
});
var DeletedAvatarWrapper = styled(SvgDeletedUserAvatar)(_templateObject4$2 || (_templateObject4$2 = _taggedTemplateLiteralLoose(["\n  color: ", ";\n"])), function (props) {
  return props.color || colors.deleteUserIconBackground;
});

var usersMap = {};
var updateInterval;
function useUpdatePresence(channel, isVisible) {
  var dispatch = useDispatch();
  var connectionStatus = useSelector(connectionStatusSelector);
  var userId = channel.peer && channel.peer.id;

  if (usersMap[userId] && !isVisible) {
    delete usersMap[userId];
  }

  if (!usersMap[userId] && isVisible) {
    usersMap[userId] = channel.peer && channel.peer.presence;
  }

  if (Object.keys(usersMap).length && connectionStatus === CONNECTION_STATUS.CONNECTED) {
    clearInterval(updateInterval);
    updateInterval = setInterval(function () {
      dispatch(checkUserStatusAC(usersMap));
    }, 4000);
  } else if (!Object.keys(usersMap).length && updateInterval) {
    clearInterval(updateInterval);
    updateInterval = undefined;
  }

  useEffect(function () {
    clearInterval(updateInterval);
  }, [usersMap]);
  useEffect(function () {
    if (connectionStatus !== CONNECTION_STATUS.CONNECTED) {
      clearInterval(updateInterval);
    }
  }, [connectionStatus]);
  useEffect(function () {
    if (channel.peer && usersMap[channel.peer.id] && channel.peer.presence && (channel.peer.presence.state !== usersMap[channel.peer.id].state || channel.peer.presence.lastActiveAt && new Date(channel.peer.presence.lastActiveAt).getTime() !== new Date(usersMap[channel.peer.id].lastActiveAt).getTime())) {
      var _updateUserStatusOnCh;

      dispatch(updateUserStatusOnChannelAC((_updateUserStatusOnCh = {}, _updateUserStatusOnCh[channel.peer.id] = channel.peer, _updateUserStatusOnCh)));
      usersMap[channel.peer.id] = channel.peer.presence;
    }
  }, [channel]);
}

var _g;

function _extends$e() {
  _extends$e = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$e.apply(this, arguments);
}

function SvgNotificationsOff3(props) {
  return /*#__PURE__*/createElement("svg", _extends$e({
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16,
    viewBox: "0 0 20 20"
  }, props), _g || (_g = /*#__PURE__*/createElement("g", {
    fill: "none",
    strokeWidth: 1.4,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    stroke: "#676a7c"
  }, /*#__PURE__*/createElement("path", {
    d: "M11.574 17.875a1.815 1.815 0 01-1.574.906 1.8 1.8 0 01-.906-.242 1.776 1.776 0 01-.664-.664M16.027 11.258a16.217 16.217 0 01-.574-4.543M4.781 5.133a5.406 5.406 0 00-.234 1.582c0 6.363-2.727 8.18-2.727 8.18h12.727M15.457 6.71a5.453 5.453 0 00-5.719-5.452 5.431 5.431 0 00-2.765.91M1.25 1.25l17.5 17.5",
    strokeWidth: 1.75
  }))));
}

var _templateObject$4, _templateObject2$4, _templateObject3$4, _templateObject4$3, _templateObject5$1, _templateObject6$1, _templateObject7$1, _templateObject8$1, _templateObject9$1, _templateObject10$1, _templateObject11$1, _templateObject12$1, _templateObject13$1, _templateObject14$1, _templateObject15$1;

var Channel = function Channel(_ref) {
  var channel = _ref.channel,
      avatar = _ref.avatar,
      notificationsIsMutedIcon = _ref.notificationsIsMutedIcon,
      notificationsIsMutedIconColor = _ref.notificationsIsMutedIconColor,
      contactsMap = _ref.contactsMap;
  var dispatch = useDispatch();
  var ChatClient = getClient();
  var getFromContacts = getShowOnlyContactUsers();
  var user = ChatClient.user;
  var activeChannel = useSelector(activeChannelSelector) || {};
  var isDirectChannel = channel.type === CHANNEL_TYPE.DIRECT;
  var withAvatar = avatar === undefined ? true : avatar;
  var typingIndicator = useSelector(typingIndicatorSelector(channel.id));
  var lastMessage = channel.lastMessage;

  var _useState = useState(0),
      statusWidth = _useState[0],
      setStatusWidth = _useState[1];

  var handleChangeActiveChannel = function handleChangeActiveChannel(chan) {
    if (activeChannel.id !== chan.id) {
      dispatch(sendTypingAC(false));
      dispatch(clearMessagesAC());
      dispatch(switchChannelActionAC(chan));
    }
  };

  var messageAuthorRef = useRef(null);
  var messageTimeAndStatusRef = useRef(null);
  useUpdatePresence(channel, true);
  useEffect(function () {
    if (messageTimeAndStatusRef.current) {
      setStatusWidth(messageTimeAndStatusRef.current.offsetWidth);
    }
  }, [messageTimeAndStatusRef]);
  return React__default.createElement(Container$2, {
    selectedChannel: channel.id === activeChannel.id,
    selectedBorderColor: customColors && customColors.selectedChannelLeftBorder,
    selectedBackgroundColor: customColors && customColors.selectedChannelBackground,
    onClick: function onClick() {
      return handleChangeActiveChannel(channel);
    }
  }, withAvatar && React__default.createElement(AvatarWrapper, null, React__default.createElement(Avatar, {
    name: channel.subject || (isDirectChannel ? channel.peer.firstName || channel.peer.id : ''),
    image: channel.avatarUrl || (isDirectChannel ? channel.peer.avatarUrl : ''),
    size: 50,
    textSize: 16,
    setDefaultAvatar: isDirectChannel
  }), isDirectChannel && (hideUserPresence(channel.peer) ? '' : channel.peer.presence && channel.peer.presence.state === PRESENCE_STATUS.ONLINE) && React__default.createElement(UserStatus, {
    backgroundColor: colors.primary
  })), React__default.createElement(ChannelInfo, {
    avatar: withAvatar,
    isMuted: channel.muted,
    statusWidth: statusWidth
  }, React__default.createElement("h3", null, channel.subject || (isDirectChannel ? makeUserName(contactsMap[channel.peer.id], channel.peer, getFromContacts) : '')), channel.muted && React__default.createElement(MutedIcon, {
    color: notificationsIsMutedIconColor
  }, notificationsIsMutedIcon || React__default.createElement(SvgNotificationsOff3, null)), (lastMessage || !!typingIndicator) && React__default.createElement(LastMessage, {
    markedAsUnread: !!(channel.markedAsUnread || channel.unreadMessageCount && channel.unreadMessageCount > 0),
    unreadMentions: !!(channel.unreadMentionsCount && channel.unreadMentionsCount > 0)
  }, typingIndicator ? !isDirectChannel ? React__default.createElement(LastMessageAuthor, {
    typing: typingIndicator,
    minWidth: messageAuthorRef.current && messageAuthorRef.current.offsetWidth
  }, React__default.createElement("span", {
    ref: messageAuthorRef
  }, typingIndicator ? contactsMap[typingIndicator.from.id] && contactsMap[typingIndicator.from.id].firstName ? contactsMap[typingIndicator.from.id].firstName.split(' ')[0] : typingIndicator.from.id : '')) : null : lastMessage.user && lastMessage.state !== MESSAGE_STATUS.DELETE && (lastMessage.user && lastMessage.user.id === user.id || !isDirectChannel) && lastMessage.type !== 'system' && React__default.createElement(LastMessageAuthor, {
    minWidth: messageAuthorRef.current && messageAuthorRef.current.offsetWidth
  }, React__default.createElement("span", {
    ref: messageAuthorRef
  }, lastMessage.user.id === user.id ? 'You' : contactsMap[lastMessage.user.id] ? contactsMap[lastMessage.user.id].firstName : lastMessage.user.id || 'Deleted')), (typingIndicator ? !isDirectChannel : lastMessage && lastMessage.user && lastMessage.state !== MESSAGE_STATUS.DELETE && (lastMessage.user.id === user.id || !isDirectChannel) && lastMessage.type !== 'system') && React__default.createElement(Points, null, ": "), React__default.createElement(LastMessageText, {
    withAttachments: !!(lastMessage && lastMessage.attachments && lastMessage.attachments.length && lastMessage.attachments[0].type !== attachmentTypes.link) && !typingIndicator,
    noBody: lastMessage && !lastMessage.body,
    deletedMessage: lastMessage && lastMessage.state === MESSAGE_STATUS.DELETE
  }, typingIndicator ? React__default.createElement(TypingIndicator, null, "typing...") : lastMessage.state === MESSAGE_STATUS.DELETE ? 'Message was deleted.' : lastMessage.type === 'system' ? (lastMessage.user && (lastMessage.user.id === user.id ? 'You ' : contactsMap[lastMessage.user.id] ? contactsMap[lastMessage.user.id].firstName : lastMessage.user.id)) + " " + (lastMessage.body === 'CC' ? 'Created this channel' : lastMessage.body === 'CG' ? 'Created this group' : lastMessage.body === 'AM' ? " added " + (lastMessage.metadata && lastMessage.metadata.m && lastMessage.metadata.m.slice(0, 5).map(function (mem) {
    return mem === user.id ? ' You' : " " + systemMessageUserName(contactsMap[mem], mem);
  })) + " " + (lastMessage.metadata && lastMessage.metadata.m && lastMessage.metadata.m.length > 5 ? "and " + (lastMessage.metadata.m.length - 5) + " more" : '') : lastMessage.body === 'RM' ? " removed " + (lastMessage.metadata && lastMessage.metadata.m && lastMessage.metadata.m.slice(0, 5).map(function (mem) {
    return mem === user.id ? ' You' : " " + systemMessageUserName(contactsMap[mem], mem);
  })) + " " + (lastMessage.metadata && lastMessage.metadata.m && lastMessage.metadata.m.length > 5 ? "and " + (lastMessage.metadata.m.length - 5) + " more" : '') : lastMessage.body === 'LG' ? 'Left this group' : '') : React__default.createElement(React__default.Fragment, null, !!(lastMessage.attachments && lastMessage.attachments.length) && (lastMessage.attachments[0].type === attachmentTypes.image ? React__default.createElement(React__default.Fragment, null, React__default.createElement(SvgPicture, null), lastMessage.body ? '' : 'Photo') : lastMessage.attachments[0].type === attachmentTypes.video ? React__default.createElement(React__default.Fragment, null, React__default.createElement(SvgVideoCall, null), lastMessage.body ? '' : 'Video') : lastMessage.attachments[0].type === attachmentTypes.file ? React__default.createElement(React__default.Fragment, null, React__default.createElement(SvgChoseFile, null), lastMessage.body ? '' : 'File') : lastMessage.attachments[0].type === attachmentTypes.voice ? React__default.createElement(React__default.Fragment, null, React__default.createElement(SvgVoiceIcon, null), lastMessage.body ? '' : 'Voice') : null), lastMessage.body)))), React__default.createElement(ChannelStatus, {
    ref: messageTimeAndStatusRef
  }, React__default.createElement(DeliveryIconCont, null, lastMessage && lastMessage.user && lastMessage.user.id === user.id && lastMessage.type !== 'system' && messageStatusIcon(lastMessage.deliveryStatus, undefined, colors.primary)), React__default.createElement(LastMessageDate, null, lastMessage && lastMessage.createdAt && lastMessageDateFormat(lastMessage.createdAt))), React__default.createElement(UnreadInfo, null, !!(channel.unreadMentionsCount && channel.unreadMentionsCount > 0) && React__default.createElement(UnreadMentionIconWrapper, {
    iconColor: colors.primary,
    rightMargin: !!(channel.unreadMessageCount || channel.markedAsUnread)
  }, React__default.createElement(SvgUnreadMention, null)), !!(channel.unreadMessageCount || channel.markedAsUnread) && React__default.createElement(UnreadCount, {
    backgroundColor: colors.primary,
    isMuted: channel.muted
  }, channel.unreadMessageCount ? channel.unreadMessageCount > 99 ? '99+' : channel.unreadMessageCount : '')));
};
var Container$2 = styled.div({
  position: 'relative',
  padding: '2px 0',
  display: 'flex',
  alignItems: 'center',
  cursor: 'pointer',
  height: '48px'
}, function (_ref2) {
  var selectedChannel = _ref2.selectedChannel,
      selectedBorderColor = _ref2.selectedBorderColor,
      selectedBackgroundColor = _ref2.selectedBackgroundColor;
  return {
    backgroundColor: selectedChannel ? selectedBackgroundColor || colors.gray0 : 'inherit',
    borderLeft: selectedChannel ? "3px solid " + (selectedBorderColor || colors.cobalt1) : 'none',
    padding: selectedChannel ? '8px 16px 8px 13px' : '8px 16px'
  };
});
var ChannelInfo = styled.div(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteralLoose(["\n  text-align: left;\n  margin-left: ", ";\n  width: 100%;\n  max-width: calc(100% - 62px);\n\n  h3 {\n    display: inline-block;\n    margin: 0;\n    font-size: 15px;\n    font-weight: 500;\n    text-overflow: ellipsis;\n    line-height: 18px;\n    letter-spacing: -0.2px;%;\n    max-width: ", ";\n    overflow: hidden;\n    white-space: nowrap;\n    color: ", ";\n  }\n"])), function (props) {
  return props.avatar && '12px';
}, function (props) {
  return "calc(100% - " + (props.statusWidth + (props.isMuted ? 20 : 0)) + "px)";
}, colors.gray6);
var MutedIcon = styled.span(_templateObject2$4 || (_templateObject2$4 = _taggedTemplateLiteralLoose(["\n  & > svg {\n    height: 16px;\n    width: 16px;\n    margin-left: 5px;\n    color: ", ";\n  }\n"])), function (props) {
  return props.color || '#818C99';
});
var LastMessage = styled.div(_templateObject3$4 || (_templateObject3$4 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  font-size: 14px;\n  color: ", ";\n  max-width: ", ";\n"])), colors.gray6, function (props) {
  return props.markedAsUnread || props.unreadMentions ? "calc(100% - " + (props.markedAsUnread && props.unreadMentions ? 48 : 24) + "px)" : '100%';
});
var AvatarWrapper = styled.div(_templateObject4$3 || (_templateObject4$3 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  position: relative;\n"])));
var UserStatus = styled.span(_templateObject5$1 || (_templateObject5$1 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  width: 14px;\n  height: 14px;\n  right: 0;\n  bottom: 0;\n  border-radius: 50%;\n  background-color: ", ";\n  border: 2.5px solid #ffffff;\n  box-sizing: border-box;\n"])), function (props) {
  return props.backgroundColor || '#56E464';
});
var LastMessageAuthor = styled.div(_templateObject6$1 || (_templateObject6$1 = _taggedTemplateLiteralLoose(["\n  max-width: 120px;\n  font-weight: 500;\n  font-style: ", ";\n  color: ", ";\n\n  & > span {\n    display: block;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    max-width: 100%;\n  }\n"])), function (props) {
  return props.typing && 'italic';
}, colors.gray8);
var Points = styled.span(_templateObject7$1 || (_templateObject7$1 = _taggedTemplateLiteralLoose(["\n  margin-right: 2px;\n"])));
var LastMessageText = styled.span(_templateObject8$1 || (_templateObject8$1 = _taggedTemplateLiteralLoose(["\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  color: ", ";\n  font-style: ", ";\n  transform: ", ";\n\n  > svg {\n    width: 16px;\n    height: 16px;\n    margin-right: 4px;\n    color: ", ";\n    transform: ", ";\n  }\n"])), colors.gray9, function (props) {
  return props.deletedMessage && 'italic';
}, function (props) {
  return props.withAttachments && 'translate(0px, -1.5px)';
}, colors.gray4, function (props) {
  return props.withAttachments ? 'translate(0px, 3px)' : 'translate(0px, 2px)';
});
var ChannelStatus = styled.div(_templateObject9$1 || (_templateObject9$1 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  right: 16px;\n  top: 15px;\n  display: flex;\n  flex-wrap: wrap;\n  height: 42px;\n  margin-left: auto;\n"])));
var LastMessageDate = styled.span(_templateObject10$1 || (_templateObject10$1 = _taggedTemplateLiteralLoose(["\n  color: ", ";\n  font-size: 12px;\n  line-height: 16px;\n"])), colors.gray9);
var DeliveryIconCont = styled.span(_templateObject11$1 || (_templateObject11$1 = _taggedTemplateLiteralLoose(["\n  margin-right: 6px;\n  line-height: 13px;\n"])));
var UnreadMentionIconWrapper = styled.span(_templateObject12$1 || (_templateObject12$1 = _taggedTemplateLiteralLoose(["\n  margin-right: ", ";\n  line-height: 13px;\n\n  & > svg {\n    color: ", ";\n  }\n"])), function (props) {
  return props.rightMargin && '8px';
}, function (props) {
  return props.iconColor || colors.primary;
});
var TypingIndicator = styled.span(_templateObject13$1 || (_templateObject13$1 = _taggedTemplateLiteralLoose(["\n  font-style: italic;\n"])));
var UnreadInfo = styled.span(_templateObject14$1 || (_templateObject14$1 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  bottom: 11px;\n  right: 16px;\n  display: flex;\n  margin-top: 7px;\n  align-items: center;\n  flex: 0 0 auto;\n  margin-left: auto;\n"])));
var UnreadCount = styled.span(_templateObject15$1 || (_templateObject15$1 = _taggedTemplateLiteralLoose(["\n  display: inline-block;\n  background-color: ", ";\n  padding: 0 4px;\n  font-size: ", ";\n  line-height: 20px;\n  min-width: ", ";\n  height: ", ";\n  text-align: center;\n  font-weight: 500;\n  color: ", ";\n  border-radius: 10px;\n  box-sizing: border-box;\n\n  /*", "*/\n"])), function (props) {
  return props.backgroundColor || colors.cobalt1;
}, function (props) {
  return props.fontSize || '13px';
}, function (props) {
  return props.width || '20px';
}, function (props) {
  return props.height || '20px';
}, function (props) {
  return props.textColor || '#fff';
}, function (props) {
  return props.isMuted && 'background-color: #BEBFC7;';
});

var _templateObject$5, _templateObject2$5;
var SearchInputContainer = styled.div(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  width: 100%;\n"])));
var SearchInput = styled.input(_templateObject2$5 || (_templateObject2$5 = _taggedTemplateLiteralLoose(["\n  padding: 0 32px 0 34px;\n  background: #ebedf0;\n  border-radius: 30px;\n  width: 100%;\n  border: none;\n  height: 36px;\n  outline: none;\n  box-sizing: border-box;\n  font-size: 15px;\n\n  &::placeholder {\n    font-style: normal;\n    font-weight: normal;\n    font-size: 15px;\n    //line-height: 22px;\n    color: #818c99;\n    opacity: 1;\n  }\n"])));

var ChannelSearch = function ChannelSearch(_ref) {
  var searchValue = _ref.searchValue,
      handleSearchValueChange = _ref.handleSearchValueChange,
      getMyChannels = _ref.getMyChannels;
  return React__default.createElement(SearchInputContainer, null, React__default.createElement(StyledSearchSvg, null), React__default.createElement(SearchInput, {
    type: 'text',
    onChange: handleSearchValueChange,
    value: searchValue,
    placeholder: 'Search for channels'
  }), searchValue && React__default.createElement(ClearTypedText, {
    onClick: getMyChannels
  }));
};

var useDidUpdate = function useDidUpdate(callback, deps) {
  var hasMount = useRef(false);
  useEffect(function () {
    if (hasMount.current) {
      callback();
    } else {
      hasMount.current = true;
    }
  }, deps);
};

var useEventListener = function useEventListener(eventName, handler, element, options) {
  if (element === void 0) {
    element = global;
  }

  if (options === void 0) {
    options = {};
  }

  var savedHandler = useRef();
  var _options = options,
      capture = _options.capture,
      passive = _options.passive,
      once = _options.once;
  useLayoutEffect(function () {
    savedHandler.current = handler;
  }, [handler]);
  useLayoutEffect(function () {
    var isSupported = element && element.addEventListener;

    if (!isSupported) {
      return;
    }

    var eventListener = function eventListener(event) {
      return savedHandler.current(event);
    };

    var opts = {
      capture: capture,
      passive: passive,
      once: once
    };
    element.addEventListener(eventName, eventListener, opts);
    return function () {
      return element.removeEventListener(eventName, eventListener, opts);
    };
  }, [eventName, element, capture, passive, once]);
};

var useStateComplex = function useStateComplex(initialState) {
  var _useState = useState(initialState),
      state = _useState[0],
      setState = _useState[1];

  return [state, function (value) {
    setState(function (prevState) {
      return _extends({}, prevState, value);
    });
  }];
};

var _templateObject$6, _templateObject2$6, _templateObject3$5;
var DropDownContainer = styled.div(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  height: ", ";\n  order: ", ";\n  ", ";\n"])), function (props) {
  return props.height ? props.height : '100%';
}, function (props) {
  return props.order;
}, function (props) {
  return props.center && " display: flex;\n      justify-content: center;\n    ";
});
var DropDownTriggerContainer = styled.div(_templateObject2$6 || (_templateObject2$6 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  cursor: pointer;\n  height: 100%;\n  width: 100%;\n  user-select: none;\n  background-color: transparent;\n  box-shadow: none;\n  border: none;\n  padding: 0;\n  outline: none !important;\n  ", " ", ";\n"])), function (props) {
  return props.withIcon && "\n        // padding-right: 20px;\n\n        &::after {\n            content: \"\";\n            position: absolute;\n            width: 7px;\n            height: 7px;\n            border-width: 1px 1px 0 0;\n            //border-color: " + colors.gray2 + ";\n            border-color: " + (props.iconColor || 'white') + ";\n            border-style: solid;\n            //border-radius: 2px;\n            top: calc(50% - 2px);\n            right: 14px;\n            transform: translateY(-50%) rotate(135deg);\n            transition: all 0.2s;\n        }\n    ";
}, function (props) {
  return props.isOpen && "\n        &::after {\n            transform: translateY(-50%) rotate(-45deg);\n            top: calc(50% + 2px);\n        }\n        ";
});
var DropDownBody = styled.div(_templateObject3$5 || (_templateObject3$5 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  z-index: 300;\n  min-width: 200px;\n  right: 0;\n  top: 100%;\n  display: flex;\n  direction: initial;\n  flex-direction: column;\n  background: #ffffff;\n  border-radius: 8px;\n  max-height: 220px;\n  overflow-y: auto;\n  box-shadow: 0.8px 0.8px 0 rgba(31, 35, 60, 0.06), 0 0 2px rgba(31, 35, 60, 0.08), 0 2px 6px rgba(31, 35, 60, 0.16);\n\n  & > * {\n    &:first-child {\n      margin-top: 5px;\n    }\n\n    &:first-child {\n      margin-bottom: 5px;\n    }\n  }\n\n  ", "\n"])), function (props) {
  return props.position === 'top' ? "top: inherit;\n         bottom: 100%;" : props.position === 'topRight' ? "top: inherit;\n         right: inherit;\n         bottom: 100%" : props.position === 'right' || props.position === 'center' ? "right: inherit;" : props.position === 'left' ? "right: inherit;\n          left: 0;" : '';
});

var DropDown = function DropDown(_ref) {
  var trigger = _ref.trigger,
      position = _ref.position,
      withIcon = _ref.withIcon,
      iconColor = _ref.iconColor,
      isStatic = _ref.isStatic,
      forceClose = _ref.forceClose,
      isSelect = _ref.isSelect,
      dropDownState = _ref.dropDownState,
      watchToggleState = _ref.watchToggleState,
      height = _ref.height,
      children = _ref.children,
      order = _ref.order;

  var _useState = useState(false),
      isOpen = _useState[0],
      setIsOpen = _useState[1];

  var dropDownRef = useRef(null);
  var dropDownBodyRef = useRef(null);

  var toggleDropdown = function toggleDropdown() {
    setIsOpen(!isOpen);

    if (watchToggleState) {
      watchToggleState(!isOpen);
    }
  };

  var handleDropdownClicks = function handleDropdownClicks(e) {
    e.stopPropagation();

    if (isOpen) {
      if (!isStatic) {
        var dropDownElem = dropDownRef.current;
        var dropDownBodyElem = dropDownBodyRef.current;

        if (dropDownElem && !dropDownElem.contains(e.target)) {
          console.log('call toggle dropdown. .. ');
          toggleDropdown();
        }

        if (isSelect && dropDownBodyElem && dropDownBodyElem.contains(e.target)) {
          var listElement = dropDownBodyElem.getElementsByTagName('ul')[0];

          if (listElement && listElement.contains(e.target)) {
            console.log('call toggle dropdown. .. !!');
            toggleDropdown();
          }
        }
      }
    }
  };

  var handleScrolling = function handleScrolling(event) {
    event.stopPropagation();
  };

  useEventListener('click', handleDropdownClicks);
  useDidUpdate(function () {
    if (forceClose) {
      setIsOpen(false);
    }
  }, [forceClose]);
  useEffect(function () {
    if (dropDownState !== undefined) {
      setIsOpen(dropDownState);
    }
  }, [dropDownState]);
  return React__default.createElement(DropDownContainer, {
    order: order,
    className: 'dropdown-wrapper',
    center: position === 'center',
    ref: dropDownRef,
    height: height
  }, React__default.createElement(DropDownTriggerContainer, {
    onClick: function onClick(e) {
      e.stopPropagation();
      toggleDropdown();
    },
    withIcon: React__default.isValidElement(trigger) ? withIcon : true,
    isOpen: isOpen,
    className: "dropdown-trigger " + (isOpen ? 'open' : ''),
    iconColor: iconColor
  }, React__default.isValidElement(trigger) ? trigger : React__default.createElement("span", null, trigger)), isOpen && React__default.createElement(DropDownBody, {
    onScroll: handleScrolling,
    className: 'dropdown-body',
    ref: dropDownBodyRef,
    position: position
  }, children));
};

var _path$d;

function _extends$f() {
  _extends$f = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$f.apply(this, arguments);
}

function SvgCreateChannel(props) {
  return /*#__PURE__*/createElement("svg", _extends$f({
    width: 18,
    height: 18,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$d || (_path$d = /*#__PURE__*/createElement("path", {
    d: "M4.5 11.245a3 3 0 010-6h4.77c.166 0 .227.017.288.05a.34.34 0 01.142.141c.033.061.05.122.05.29v5.038c0 .167-.017.228-.05.289a.34.34 0 01-.142.141c-.061.033-.122.05-.289.05H7.5c0 .588.227 1.216.49 1.53a1.125 1.125 0 11-1.73 1.44c-.599-.719-1.01-1.857-1.01-2.97H4.5zm11.104-7.857a.87.87 0 01.146.482v8.749a.87.87 0 01-1.353.724l-2.91-1.94a.628.628 0 01-.155-.127.33.33 0 01-.063-.118.48.48 0 01-.018-.138l-.001-5.49c0-.115.006-.155.02-.2a.331.331 0 01.062-.117.627.627 0 01.155-.126l2.91-1.94a.87.87 0 011.207.24z",
    fill: "#818C99"
  })));
}

var _path$e;

function _extends$g() {
  _extends$g = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$g.apply(this, arguments);
}

function SvgCreateGroup(props) {
  return /*#__PURE__*/createElement("svg", _extends$g({
    width: 18,
    height: 18,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$e || (_path$e = /*#__PURE__*/createElement("path", {
    d: "M12.75 9.375c1.72 0 4.875.643 4.875 3.214 0 1.125-.287 1.286-.86 1.286h-4.568a4.2 4.2 0 00.178-1.286c0-1.292-.473-2.3-1.254-3.046a8.303 8.303 0 011.629-.168zm-6.75 0c1.72 0 4.875.643 4.875 3.214 0 1.125-.287 1.286-.86 1.286h-8.03c-.573 0-.86-.16-.86-1.286 0-2.571 3.154-3.214 4.875-3.214zM6 3.75a2.25 2.25 0 11.001 4.499A2.25 2.25 0 016 3.75zm6.75 0a2.25 2.25 0 11.001 4.499 2.25 2.25 0 01-.001-4.499z",
    fill: "#818C99"
  })));
}

var _path$f, _g$1;

function _extends$h() {
  _extends$h = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$h.apply(this, arguments);
}

function SvgCreateChat(props) {
  return /*#__PURE__*/createElement("svg", _extends$h({
    width: 18,
    height: 18,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), /*#__PURE__*/createElement("mask", {
    id: "createChat_svg__a",
    style: {
      maskType: "alpha"
    },
    maskUnits: "userSpaceOnUse",
    x: 1,
    y: 1,
    width: 16,
    height: 16
  }, _path$f || (_path$f = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M13.193 15.22A7.466 7.466 0 019 16.5 7.466 7.466 0 014.5 15a7.5 7.5 0 118.693.219zM9 9.374c1.243 0 2.25-1.091 2.25-2.438C11.25 5.591 10.243 4.5 9 4.5S6.75 5.591 6.75 6.938c0 1.346 1.007 2.437 2.25 2.437zM9 15a5.98 5.98 0 004.173-1.688 4.502 4.502 0 00-8.346 0A5.98 5.98 0 009 15z",
    fill: "#fff"
  }))), _g$1 || (_g$1 = /*#__PURE__*/createElement("g", {
    mask: "url(#createChat_svg__a)"
  }, /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M13.193 15.22A7.466 7.466 0 019 16.5 7.466 7.466 0 014.5 15a7.5 7.5 0 118.693.219zM9 9.374c1.243 0 2.25-1.091 2.25-2.438C11.25 5.591 10.243 4.5 9 4.5S6.75 5.591 6.75 6.938c0 1.346 1.007 2.437 2.25 2.437zM9 15a5.98 5.98 0 004.173-1.688 4.502 4.502 0 00-8.346 0A5.98 5.98 0 009 15z",
    fill: "#818C99"
  }))));
}

var _path$g, _path2$2, _path3$1;

function _extends$i() {
  _extends$i = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$i.apply(this, arguments);
}

function SvgAddChat(props) {
  return /*#__PURE__*/createElement("svg", _extends$i({
    width: 24,
    height: 24,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$g || (_path$g = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M4.128 2.179c.989-.529 1.962-.713 4.109-.713h7.66a1 1 0 110 2h-7.66c-2.041 0-2.615.182-3.165.476a2.86 2.86 0 00-1.196 1.196c-.294.55-.476 1.124-.476 3.165v7.66c0 2.041.182 2.615.476 3.165a2.86 2.86 0 001.196 1.196c.55.294 1.124.476 3.165.476h7.66c2.04 0 2.614-.182 3.165-.476a2.86 2.86 0 001.195-1.196c.295-.55.476-1.124.476-3.165v-7.66a1 1 0 012 0v7.66c0 2.147-.184 3.12-.712 4.108a4.86 4.86 0 01-2.016 2.016c-.989.53-1.962.713-4.109.713h-7.66c-2.146 0-3.12-.184-4.108-.713a4.86 4.86 0 01-2.016-2.016c-.528-.988-.712-1.961-.712-4.108v-7.66c0-2.147.184-3.12.712-4.108a4.86 4.86 0 012.016-2.016z",
    fill: "CurrentColor"
  })), _path2$2 || (_path2$2 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M20.769 3.43c.397.398.397 1.042 0 1.439l-8.475 8.475c-.376.376-1.492.981-2.333 1.409a.38.38 0 01-.514-.514c.427-.84 1.033-1.957 1.409-2.333l8.475-8.475a1.017 1.017 0 011.438 0z",
    fill: "CurrentColor"
  })), _path3$1 || (_path3$1 = /*#__PURE__*/createElement("path", {
    d: "M23.4 1.8a1 1 0 11-2 0 1 1 0 012 0z",
    fill: "CurrentColor"
  })));
}

var _path$h;

function _extends$j() {
  _extends$j = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$j.apply(this, arguments);
}

function SvgCross(props) {
  return /*#__PURE__*/createElement("svg", _extends$j({
    width: 16,
    height: 16,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$h || (_path$h = /*#__PURE__*/createElement("path", {
    d: "M7.114 8L4.85 5.736a.626.626 0 11.886-.886L8 7.114l2.264-2.264a.626.626 0 11.886.886L8.886 8l2.264 2.264a.626.626 0 01-.886.886L8 8.886 5.736 11.15a.626.626 0 01-.886-.886L7.114 8z",
    fill: "#818C99"
  })));
}

var _path$i;

function _extends$k() {
  _extends$k = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$k.apply(this, arguments);
}

function SvgTick(props) {
  return /*#__PURE__*/createElement("svg", _extends$k({
    width: 11,
    height: 9,
    viewBox: "0 0 10 10",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$i || (_path$i = /*#__PURE__*/createElement("path", {
    d: "M1.28 4.775a.75.75 0 00-1.06 1.06l2.722 2.723a.75.75 0 001.06 0l6.445-6.445a.75.75 0 10-1.06-1.06L3.471 6.967 1.28 4.775z",
    fill: "#fff"
  })));
}

var _templateObject$7, _templateObject2$7;

var CustomCheckbox = function CustomCheckbox(_ref) {
  var index = _ref.index,
      state = _ref.state,
      _onChange = _ref.onChange,
      checkedBackgroundColor = _ref.checkedBackgroundColor,
      backgroundColor = _ref.backgroundColor,
      tickColor = _ref.tickColor,
      borderRadius = _ref.borderRadius,
      size = _ref.size;
  return React__default.createElement(React__default.Fragment, null, React__default.createElement(CustomLabel, {
    isChecked: state,
    size: size,
    checkedBackgroundColor: checkedBackgroundColor,
    backgroundColor: backgroundColor,
    tickColor: tickColor,
    borderRadius: borderRadius,
    htmlFor: "checkbox-" + index
  }, state && React__default.createElement(SvgTick, null)), React__default.createElement(Checkbox, {
    type: 'checkbox',
    id: "checkbox-" + index,
    checked: state,
    onChange: function onChange(e) {
      return _onChange(e);
    }
  }));
};
var CustomLabel = styled.label(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: ", ";\n  min-width: ", ";\n  height: ", ";\n  cursor: pointer;\n  border: ", ";\n  border-radius: ", ";\n  background-color: ", ";\n\n  & > svg {\n    width: calc(100% - 4px);\n    height: calc(100% - 8px);\n  }\n"])), function (props) {
  return props.size || '12px';
}, function (props) {
  return props.size || '12px';
}, function (props) {
  return props.size || '12px';
}, function (props) {
  return props.isChecked ? 'none' : '1px solid #818C99';
}, function (props) {
  return props.borderRadius || '4px';
}, function (props) {
  return props.isChecked ? props.checkedBackgroundColor || colors.primary : props.backgroundColor || '#fff';
});
var Checkbox = styled.input(_templateObject2$7 || (_templateObject2$7 = _taggedTemplateLiteralLoose(["\n  display: none;\n"])));

var _templateObject$8, _templateObject2$8, _templateObject3$6, _templateObject4$4, _templateObject5$2, _templateObject6$2, _templateObject7$2, _templateObject8$2, _templateObject9$2, _templateObject10$2, _templateObject11$2;

var UsersPopup = function UsersPopup(_ref) {
  var channel = _ref.channel,
      toggleCreatePopup = _ref.toggleCreatePopup,
      actionType = _ref.actionType,
      getSelectedUsers = _ref.getSelectedUsers,
      memberIds = _ref.memberIds,
      creatChannelSelectedMembers = _ref.creatChannelSelectedMembers,
      popupHeight = _ref.popupHeight,
      selectIsRequired = _ref.selectIsRequired,
      popupWidth = _ref.popupWidth;
  var dispatch = useDispatch();
  var contactList = useSelector(contactListSelector);
  var contactsMap = useSelector(contactsMapSelector);
  var usersList = useSelector(usersListSelector);
  var getFromContacts = getShowOnlyContactUsers();
  var usersLoadingState = useSelector(usersLoadingStateSelector);
  var selectedMembersCont = useRef('');

  var _useState = useState(''),
      userSearchValue = _useState[0],
      setUserSearchValue = _useState[1];

  var _useState2 = useState(creatChannelSelectedMembers || []),
      selectedMembers = _useState2[0],
      setSelectedMembers = _useState2[1];

  var _useState3 = useState(0),
      usersContHeight = _useState3[0],
      setUsersContHeight = _useState3[1];

  var _useState4 = useState([]),
      filteredUsers = _useState4[0],
      setFilteredUsers = _useState4[1];

  var handleMembersListScroll = function handleMembersListScroll(event) {
    if (event.target.scrollHeight - event.target.scrollTop <= event.target.offsetHeight + 300) {
      if (!getFromContacts && usersLoadingState === LOADING_STATE.LOADED) {
        dispatch(loadMoreUsersAC(20));
      }
    }
  };

  var handleTypeSearchUser = function handleTypeSearchUser(event) {
    setUserSearchValue(event.currentTarget.value);
  };

  var handleUserSelect = function handleUserSelect(event, contact) {
    var newSelectedMembers = [].concat(selectedMembers);

    if (event.target.checked) {
      newSelectedMembers.push({
        id: contact.id,
        displayName: contact.displayName,
        role: (channel === null || channel === void 0 ? void 0 : channel.type) === CHANNEL_TYPE.PUBLIC ? 'subscriber' : 'participant'
      });
    } else {
      var itemToDeleteIndex = newSelectedMembers.findIndex(function (member) {
        return member.id === contact.id;
      });

      if (itemToDeleteIndex >= 0) {
        newSelectedMembers.splice(itemToDeleteIndex, 1);
      }
    }

    setUserSearchValue('');
    setSelectedMembers(newSelectedMembers);
  };

  var removeMember = function removeMember(member) {
    var newSelectedMembers = [].concat(selectedMembers);
    var itemToDeleteIndex = newSelectedMembers.findIndex(function (m) {
      return m.id === member.id;
    });

    if (itemToDeleteIndex >= 0) {
      newSelectedMembers.splice(itemToDeleteIndex, 1);
    }

    setSelectedMembers(newSelectedMembers);
  };

  var handleCreateChannel = function handleCreateChannel(selectedUser) {
    if (actionType === 'createChat') {
      var channelData = {
        metadata: '',
        label: '',
        type: CHANNEL_TYPE.DIRECT,
        userId: selectedUser && selectedUser.id
      };
      dispatch(createChannelAC(channelData));
    } else {
      var selectedMembersList = selectedMembers.map(function (member) {
        return {
          id: member.id,
          role: member.role
        };
      });

      if (actionType === 'selectUsers' && getSelectedUsers) {
        getSelectedUsers(selectedMembersList, 'create');
      } else {
        dispatch(addMembersAC(channel.id, selectedMembersList));
      }
    }

    toggleCreatePopup();
  };

  var handleAddMember = function handleAddMember(user) {
    handleCreateChannel(user);
  };

  var handleGoBack = function handleGoBack() {
    if (getSelectedUsers) {
      getSelectedUsers(selectedMembers, 'back');
    }

    handleClosePopup();
  };

  var handleClosePopup = function handleClosePopup() {
    toggleCreatePopup();
  };

  useEffect(function () {
    if (getFromContacts) {
      if (!userSearchValue) {
        setFilteredUsers(contactList.map(function (cont) {
          return cont.user;
        }));
      }
    } else {
      setFilteredUsers(usersList);
    }
  }, [contactList, usersList]);
  useDidUpdate(function () {
    if (getFromContacts) {
      if (userSearchValue) {
        var filteredContacts = contactList.filter(function (contact) {
          return contact.firstName && contact.firstName.toLowerCase().includes(userSearchValue.toLowerCase()) || contact.lastName && contact.lastName.toLowerCase().includes(userSearchValue.toLowerCase()) || contact.id.toLowerCase().includes(userSearchValue.toLowerCase());
        });
        setFilteredUsers(filteredContacts.map(function (cont) {
          return cont.user;
        }));
      } else {
        setFilteredUsers(contactList.map(function (cont) {
          return cont.user;
        }));
      }
    } else {
      dispatch(getUsersAC({
        query: userSearchValue,
        filter: 'all',
        limit: 50
      }));
    }
  }, [userSearchValue]);
  useEffect(function () {
    if (selectedMembersCont.current) {
      setUsersContHeight(selectedMembersCont.current.offsetHeight);
    } else {
      setUsersContHeight(0);
    }
  }, [selectedMembers]);
  useEffect(function () {
    if (getFromContacts) {
      dispatch(getContactsAC());
    } else {
      dispatch(getUsersAC({
        query: userSearchValue,
        filter: 'all',
        limit: 50
      }));
    }
  }, []);
  return React__default.createElement(PopupContainer, null, React__default.createElement(Popup, {
    maxHeight: popupHeight || '721px',
    width: popupWidth || '433px',
    maxWidth: popupWidth || '433px',
    height: popupHeight,
    padding: '0',
    display: 'flex'
  }, React__default.createElement(PopupBody, {
    padding: 24,
    withFooter: actionType !== 'createChat'
  }, React__default.createElement(CloseIcon, {
    onClick: handleClosePopup
  }), React__default.createElement(PopupName, null, actionType === 'createChat' ? 'Creat a new chat' : (channel === null || channel === void 0 ? void 0 : channel.type) === CHANNEL_TYPE.PUBLIC ? 'Add subscribers' : 'Add members'), React__default.createElement(SearchUserCont, {
    className: 'p-relative'
  }, React__default.createElement(StyledSearchSvg, null), React__default.createElement(SearchUsersInput, {
    height: '40px',
    onChange: handleTypeSearchUser,
    value: userSearchValue,
    placeholder: 'Search for users',
    type: 'text'
  }), userSearchValue && React__default.createElement(ClearTypedText, {
    onClick: function onClick() {
      return setUserSearchValue('');
    }
  })), actionType !== 'createChat' && selectedMembers.length !== 0 && React__default.createElement(SelectedMembersContainer, {
    ref: selectedMembersCont
  }, selectedMembers.map(function (member) {
    return React__default.createElement(SelectedMemberBuble, {
      key: "selected-" + member.id
    }, React__default.createElement(SelectedMemberName, null, member.displayName), React__default.createElement(StyledSubtractSvg, {
      onClick: function onClick() {
        return removeMember(member);
      }
    }));
  })), React__default.createElement(MembersContainer, {
    isAdd: actionType !== 'createChat',
    selectedMembersHeight: usersContHeight,
    onScroll: handleMembersListScroll
  }, filteredUsers.map(function (user) {
    if (actionType === 'addMembers' && memberIds && memberIds.includes(user.id)) {
      return null;
    }

    var isSelected = selectedMembers.findIndex(function (member) {
      return member.id === user.id;
    }) >= 0;
    var memberDisplayName = makeUserName(contactsMap[user.id], user, getFromContacts);
    return React__default.createElement(ListRow, {
      isAdd: actionType !== 'createChat',
      key: user.id,
      onClick: function onClick() {
        return actionType === 'createChat' && handleAddMember(user);
      }
    }, React__default.createElement(Avatar, {
      image: user.avatarUrl,
      name: user.firstName || user.id,
      size: 40,
      textSize: 16,
      setDefaultAvatar: true
    }), React__default.createElement(UserNamePresence, null, React__default.createElement(MemberName, null, memberDisplayName), React__default.createElement(SubTitle, null, user.presence && user.presence.state === PRESENCE_STATUS.ONLINE ? 'Online' : user.presence && user.presence.lastActiveAt && userLastActiveDateFormat(user.presence.lastActiveAt))), actionType !== 'createChat' && React__default.createElement(CustomCheckbox, {
      index: user.id,
      state: isSelected,
      onChange: function onChange(e) {
        return handleUserSelect(e, {
          id: user.id,
          displayName: memberDisplayName
        });
      },
      size: '18px'
    }));
  }))), actionType !== 'createChat' && React__default.createElement(PopupFooter, {
    backgroundColor: colors.gray5,
    marginTop: 'auto'
  }, actionType === 'selectUsers' ? React__default.createElement(Button, {
    type: 'button',
    color: colors.gray6,
    backgroundColor: 'transparent',
    onClick: handleGoBack
  }, "Back") : React__default.createElement(Button, {
    type: 'button',
    color: colors.gray6,
    backgroundColor: 'transparent',
    onClick: toggleCreatePopup
  }, "Cancel"), React__default.createElement(Button, {
    type: 'button',
    color: colors.white,
    backgroundColor: colors.primary,
    borderRadius: '8px',
    disabled: selectIsRequired && selectedMembers.length === 0,
    onClick: function onClick() {
      return handleCreateChannel();
    }
  }, actionType === 'selectUsers' ? 'Create' : 'Add'))));
};
var List = styled.div(_templateObject$8 || (_templateObject$8 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  overflow-x: hidden;\n  margin-top: 12px;\n  min-height: 150px;\n  box-sizing: border-box;\n"])));
var MembersContainer = styled(List)(_templateObject2$8 || (_templateObject2$8 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  flex-direction: column;\n  //margin-top: 24px;\n  position: relative;\n  max-height: ", ";\n  overflow-y: auto;\n\n  width: calc(100% + 16px);\n  padding-right: 16px;\n"])), function (props) {
  return "calc(100% - (" + ((props.isAdd ? 75 : 70) + props.selectedMembersHeight) + "px))";
});
var SearchUserCont = styled.div(_templateObject3$6 || (_templateObject3$6 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  width: 100%;\n  margin-top: 24px;\n\n  ", " {\n    top: 10px;\n    right: 11px;\n  }\n"])), ClearTypedText);
var SearchUsersInput = styled.input(_templateObject4$4 || (_templateObject4$4 = _taggedTemplateLiteralLoose(["\n  height: 40px;\n  width: 100%;\n  font-size: 14px;\n  background: #ffffff;\n  border: 1px solid rgb(225, 226, 229);\n  box-sizing: border-box;\n  border-radius: 8px;\n  padding-left: 36px;\n  &::placeholder {\n    color: ", ";\n    font-size: 14px;\n    opacity: 1;\n  }\n  &:focus {\n    outline: none;\n  }\n"])), colors.gray4);
var ListRow = styled.div(_templateObject5$2 || (_templateObject5$2 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  justify-content: space-between;\n  flex-direction: row;\n  align-items: center;\n  min-height: 40px;\n  padding: 7px 0;\n  cursor: ", ";\n  transition: all 0.2s;\n\n  &:hover {\n    background-color: ", ";\n  }\n\n  & ", " {\n    width: 10px;\n    height: 10px;\n  }\n"])), function (props) {
  return !props.isAdd && 'pointer';
}, function (props) {
  return !props.isAdd && colors.gray0;
}, UserStatus);
var UserNamePresence = styled.div(_templateObject6$2 || (_templateObject6$2 = _taggedTemplateLiteralLoose(["\n  width: 100%;\n  max-width: calc(100% - 70px);\n  margin: 0 auto 0 8px;\n  line-height: 10px;\n"])));
var MemberName = styled.h4(_templateObject7$2 || (_templateObject7$2 = _taggedTemplateLiteralLoose(["\n  font-style: normal;\n  font-weight: normal;\n  font-size: 15px;\n  line-height: 16px;\n  color: ", ";\n  margin: 0;\n  max-width: calc(100% - 10px);\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n"])), colors.blue6);
var SelectedMembersContainer = styled.div(_templateObject8$2 || (_templateObject8$2 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  justify-content: flex-start;\n  flex-wrap: wrap;\n  width: 100%;\n  max-height: 85px;\n  overflow-x: hidden;\n  padding-top: 2px;\n  box-sizing: border-box;\n  //flex: 0 0 auto;\n"])));
var SelectedMemberBuble = styled.div(_templateObject9$2 || (_templateObject9$2 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  justify-content: space-between;\n  background: ", ";\n  border-radius: 16px;\n  align-items: center;\n  padding: 4px 10px;\n  height: 26px;\n  margin: 8px 8px 0 0;\n  box-sizing: border-box;\n"])), colors.gray5);
var SelectedMemberName = styled.span(_templateObject10$2 || (_templateObject10$2 = _taggedTemplateLiteralLoose(["\n  font-style: normal;\n  font-weight: 500;\n  font-size: 14px;\n  line-height: 16px;\n  color: ", ";\n"])), colors.blue6);
var StyledSubtractSvg = styled(SvgCross)(_templateObject11$2 || (_templateObject11$2 = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n  margin-left: 4px;\n  transform: translate(2px, 0);\n"])));

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}var AsyncMode=l;var ConcurrentMode=m;var ContextConsumer=k;var ContextProvider=h;var Element=c;var ForwardRef=n;var Fragment=e;var Lazy=t;var Memo=r;var Portal=d;
var Profiler=g;var StrictMode=f;var Suspense=p;var isAsyncMode=function(a){return A(a)||z(a)===l};var isConcurrentMode=A;var isContextConsumer=function(a){return z(a)===k};var isContextProvider=function(a){return z(a)===h};var isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};var isForwardRef=function(a){return z(a)===n};var isFragment=function(a){return z(a)===e};var isLazy=function(a){return z(a)===t};
var isMemo=function(a){return z(a)===r};var isPortal=function(a){return z(a)===d};var isProfiler=function(a){return z(a)===g};var isStrictMode=function(a){return z(a)===f};var isSuspense=function(a){return z(a)===p};
var isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};var typeOf=z;

var reactIs_production_min = {
	AsyncMode: AsyncMode,
	ConcurrentMode: ConcurrentMode,
	ContextConsumer: ContextConsumer,
	ContextProvider: ContextProvider,
	Element: Element,
	ForwardRef: ForwardRef,
	Fragment: Fragment,
	Lazy: Lazy,
	Memo: Memo,
	Portal: Portal,
	Profiler: Profiler,
	StrictMode: StrictMode,
	Suspense: Suspense,
	isAsyncMode: isAsyncMode,
	isConcurrentMode: isConcurrentMode,
	isContextConsumer: isContextConsumer,
	isContextProvider: isContextProvider,
	isElement: isElement,
	isForwardRef: isForwardRef,
	isFragment: isFragment,
	isLazy: isLazy,
	isMemo: isMemo,
	isPortal: isPortal,
	isProfiler: isProfiler,
	isStrictMode: isStrictMode,
	isSuspense: isSuspense,
	isValidElementType: isValidElementType,
	typeOf: typeOf
};

var reactIs_development = createCommonjsModule(function (module, exports) {



if (process.env.NODE_ENV !== "production") {
  (function() {

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}
});

var reactIs = createCommonjsModule(function (module) {

if (process.env.NODE_ENV === 'production') {
  module.exports = reactIs_production_min;
} else {
  module.exports = reactIs_development;
}
});

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

var ReactPropTypesSecret_1 = ReactPropTypesSecret;

var has = Function.call.bind(Object.prototype.hasOwnProperty);

var printWarning = function() {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
  var loggedTypeFailures = {};
  var has$1 = has;

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) { /**/ }
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (has$1(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (process.env.NODE_ENV !== 'production') {
    loggedTypeFailures = {};
  }
};

var checkPropTypes_1 = checkPropTypes;

var printWarning$1 = function() {};

if (process.env.NODE_ENV !== 'production') {
  printWarning$1 = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bigint: createPrimitiveTypeChecker('bigint'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message, data) {
    this.message = message;
    this.data = data && typeof data === 'object' ? data: {};
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret_1) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning$1(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError(
          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
          {expectedType: expectedType}
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!reactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (process.env.NODE_ENV !== 'production') {
        if (arguments.length > 1) {
          printWarning$1(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning$1('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? printWarning$1('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning$1(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      var expectedTypes = [];
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1);
        if (checkerResult == null) {
          return null;
        }
        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
          expectedTypes.push(checkerResult.data.expectedType);
        }
      }
      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function invalidValidatorError(componentName, location, propFullName, key, type) {
    return new PropTypeError(
      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
    );
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from props.
      var allKeys = objectAssign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (has(shapeTypes, key) && typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes_1;
  ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret_1) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  }  shim.isRequired = shim;
  function getShim() {
    return shim;
  }  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

var propTypes = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var ReactIs = reactIs;

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = factoryWithThrowingShims();
}
});

var _path$j;

function _extends$l() {
  _extends$l = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$l.apply(this, arguments);
}

function SvgChosePicture(props) {
  return /*#__PURE__*/createElement("svg", _extends$l({
    width: 36,
    height: 36,
    viewBox: "0 0 37 37",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$j || (_path$j = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M7.228 4.104C8.732 3.3 10.214 3 13.596 3h8.808c3.382 0 4.864.3 6.368 1.104a7.529 7.529 0 013.124 3.124C32.7 8.732 33 10.214 33 13.596v8.808c0 3.382-.3 4.864-1.104 6.368a7.53 7.53 0 01-3.124 3.124C27.268 32.7 25.786 33 22.404 33h-8.808c-3.382 0-4.864-.3-6.368-1.104a7.529 7.529 0 01-3.124-3.124C3.3 27.268 3 25.786 3 22.404v-8.808c0-3.382.3-4.864 1.104-6.368a7.529 7.529 0 013.124-3.124zm14.319 14.14a.594.594 0 01.965.007l6.08 8.387a.643.643 0 01-.12.88.594.594 0 01-.365.125H8.964a.618.618 0 01-.607-.628c0-.14.045-.276.128-.386l4.442-5.907a.594.594 0 01.946-.016l3.056 3.723 4.618-6.186zm-9.976-4.53a2.143 2.143 0 100-4.285 2.143 2.143 0 000 4.285z",
    fill: "#B2B6BE"
  })));
}

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var getCroppedImg = function getCroppedImg(imageSrc, pixelCrop, rotation, fileName) {
  try {
    if (rotation === void 0) {
      rotation = 0;
    }

    return Promise.resolve(createImage(imageSrc)).then(function (image) {
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      var maxSize = Math.max(image.width, image.height);
      var safeArea = 2 * (maxSize / 2 * Math.sqrt(2));
      canvas.width = safeArea;
      canvas.height = safeArea;
      ctx.translate(safeArea / 2, safeArea / 2);
      ctx.rotate(getRadianAngle(rotation));
      ctx.translate(-safeArea / 2, -safeArea / 2);
      ctx.drawImage(image, safeArea / 2 - image.width * 0.5, safeArea / 2 - image.height * 0.5);
      var data = ctx.getImageData(0, 0, safeArea, safeArea);
      canvas.width = pixelCrop.width;
      canvas.height = pixelCrop.height;
      ctx.putImageData(data, Math.round(0 - safeArea / 2 + image.width * 0.5 - pixelCrop.x), Math.round(0 - safeArea / 2 + image.height * 0.5 - pixelCrop.y));
      return new Promise(function (resolve) {
        canvas.toBlob(function (file) {
          var newFile = new File([file], fileName);
          resolve(newFile);
        }, 'image/jpeg');
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createImage = function createImage(url) {
  return new Promise(function (resolve, reject) {
    var image = new Image();
    image.addEventListener('load', function () {
      return resolve(image);
    });
    image.addEventListener('error', function (error) {
      return reject(error);
    });
    image.setAttribute('crossOrigin', 'anonymous');
    image.src = url;
  });
};

function getRadianAngle(degreeValue) {
  return degreeValue * Math.PI / 180;
}

var _templateObject$9, _templateObject2$9;

var ImageCrop = function ImageCrop(_ref) {
  var image = _ref.image,
      onAccept = _ref.onAccept,
      handleClosePopup = _ref.handleClosePopup;

  var _useState = useState(null),
      area = _useState[0],
      setArea = _useState[1];

  var _useStateComplex = useStateComplex({
    image: image.url,
    crop: {
      x: 0,
      y: 0
    },
    zoom: 1,
    aspect: 1
  }),
      state = _useStateComplex[0],
      setState = _useStateComplex[1];

  var onCropChange = function onCropChange(crop) {
    setState({
      crop: crop
    });
  };

  var onZoomChange = function onZoomChange(zoom) {
    setState({
      zoom: zoom
    });
  };

  var onCropComplete = useCallback(function (_croppedArea, croppedAreaPixels) {
    setArea(croppedAreaPixels);
  }, []);
  var returnCroppedImage = useCallback(function () {
    try {
      var _temp2 = _catch(function () {
        return Promise.resolve(getCroppedImg(state.image, area, 0, image.name)).then(function (imageFile) {
          onAccept(imageFile);
          handleClosePopup(true);
        });
      }, function (e) {
        console.error(e);
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  }, [area]);
  return React__default.createElement(PopupContainer, null, React__default.createElement(Popup, {
    minWidth: '500px',
    maxWidth: '600px',
    padding: '0'
  }, React__default.createElement(PopupBody, {
    padding: 24
  }, React__default.createElement(CloseIcon, {
    onClick: handleClosePopup
  }), React__default.createElement(Row, {
    align: 'center'
  }, React__default.createElement(PopupName, null, "Crop image")), React__default.createElement("div", {
    className: 'crop-container'
  }, React__default.createElement(CropperWrapper, null, React__default.createElement(Cropper, {
    image: state.image,
    crop: state.crop,
    zoom: state.zoom,
    aspect: state.aspect,
    onCropChange: onCropChange,
    onZoomChange: onZoomChange,
    onCropComplete: onCropComplete,
    cropShape: 'round',
    showGrid: false
  })), React__default.createElement(Controls, {
    className: 'controls'
  }, React__default.createElement("input", {
    type: 'range',
    value: state.zoom,
    min: 1,
    max: 3,
    step: 0.1,
    "aria-labelledby": 'Zoom',
    onChange: function onChange(e) {
      onZoomChange(e.target.value);
    },
    className: 'zoom-range'
  })))), React__default.createElement(PopupFooter, {
    backgroundColor: colors.gray5
  }, React__default.createElement(Button, {
    type: 'button',
    color: colors.gray6,
    backgroundColor: 'transparent',
    onClick: function onClick() {
      return handleClosePopup();
    }
  }, "Cancel"), React__default.createElement(Button, {
    type: 'button',
    backgroundColor: colors.primary,
    borderRadius: '8px',
    onClick: returnCroppedImage
  }, "Save"))));
};
var CropperWrapper = styled.div(_templateObject$9 || (_templateObject$9 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  width: 100%;\n  height: 300px;\n  margin: 14px 0;\n"])));
var Controls = styled.div(_templateObject2$9 || (_templateObject2$9 = _taggedTemplateLiteralLoose(["\n  & > input {\n    width: 100%;\n    -webkit-appearance: none;\n    background-color: rgba(178, 182, 190, 0.4);\n    border-radius: 3px;\n\n    &::-webkit-slider-runnable-track {\n      height: 6px;\n      -webkit-appearance: none;\n      color: ", ";\n      margin-top: -1px;\n      border-radius: 3px;\n    }\n    &::-webkit-slider-thumb {\n      width: 16px;\n      -webkit-appearance: none;\n      height: 16px;\n      cursor: ew-resize;\n      background: ", ";\n      border-radius: 50%;\n      transform: translate(0, -5px);\n    }\n  }\n"])), colors.primary, colors.primary);

var _templateObject$a, _templateObject2$a, _templateObject3$7, _templateObject4$5, _templateObject5$3, _templateObject6$3, _templateObject7$3, _templateObject8$3, _templateObject9$3, _templateObject10$3;
function CreateChannel(_ref) {
  var handleClose = _ref.handleClose,
      channelType = _ref.channelType,
      uriPrefixOnCreateChannel = _ref.uriPrefixOnCreateChannel;
  var dispatch = useDispatch();
  var uriRegexp = new RegExp('^[A-Za-z0-9_]*$');
  var fileUploader = useRef(null);

  var _useState = useState(false),
      usersPopupVisible = _useState[0],
      setUsersPopupVisible = _useState[1];

  var _useState2 = useState(true),
      createGroupChannelPopupVisible = _useState2[0],
      setCreateGroupChannelPopupVisible = _useState2[1];

  var _useState3 = useState([]),
      selectedMembers = _useState3[0],
      setSelectedMembers = _useState3[1];

  var _useState4 = useState(''),
      subjectValue = _useState4[0],
      setSubjectValue = _useState4[1];

  var _useState5 = useState(''),
      URIValue = _useState5[0],
      setURIValue = _useState5[1];

  var _useState6 = useState(''),
      wrongUri = _useState6[0],
      setWrongUri = _useState6[1];

  var _useState7 = useState(''),
      metadataValue = _useState7[0],
      setMetadataValue = _useState7[1];

  var _useState8 = useState(false),
      cropPopup = _useState8[0],
      setCropPopup = _useState8[1];

  var _useStateComplex = useStateComplex({
    src: {},
    url: ''
  }),
      newAvatar = _useStateComplex[0],
      setNewAvatar = _useStateComplex[1];

  var createPrivateChannel = channelType === 'private';

  var toggleCreatePopup = function toggleCreatePopup() {
    setUsersPopupVisible(!usersPopupVisible);
  };

  var handleAddMembersForCreateChannel = function handleAddMembersForCreateChannel(members, action) {
    setSelectedMembers(members);
    setCreateGroupChannelPopupVisible(true);

    if (action === 'create') {
      handleCreateChannel(members);
    }
  };

  var toggleCreateGroupChannelPopup = function toggleCreateGroupChannelPopup() {
    if (createGroupChannelPopupVisible) {
      setSubjectValue('');
      setURIValue('');
      setMetadataValue('');
      setSelectedMembers([]);
      setCropPopup(false);
      setNewAvatar({
        src: {},
        url: ''
      });
    }

    handleClose();
    setCreateGroupChannelPopupVisible(!createGroupChannelPopupVisible);
  };

  var GoToAddMember = function GoToAddMember() {
    if (subjectValue && (createPrivateChannel || URIValue && uriRegexp.test(URIValue))) {
      setUsersPopupVisible(true);
      setCreateGroupChannelPopupVisible(false);
    }
  };

  var handleCreateChannel = function handleCreateChannel(members) {
    var createChannelParams = {
      subject: subjectValue,
      metadata: {
        d: metadataValue
      },
      uri: URIValue,
      members: members,
      type: channelType === 'private' ? CHANNEL_TYPE.PRIVATE : CHANNEL_TYPE.PUBLIC,
      avatarFile: newAvatar.src.file
    };

    if (createPrivateChannel && members.length > 0) {
      dispatch(createChannelAC(createChannelParams));
      toggleCreateGroupChannelPopup();
    } else if (!createPrivateChannel) {
      var subscribers = members.map(function (mem) {
        return _extends({}, mem, {
          role: 'subscriber'
        });
      });
      dispatch(createChannelAC(_extends({}, createChannelParams, {
        members: subscribers
      })));
      toggleCreateGroupChannelPopup();
    }
  };

  var handleTypeSubject = function handleTypeSubject(e) {
    setSubjectValue(e.currentTarget.value);
  };

  var handleTypeURI = function handleTypeURI(e) {
    checkURIRegexp(e);
    setURIValue(e.currentTarget.value);
  };

  var checkURIRegexp = function checkURIRegexp(e) {
    if (uriRegexp.test(e.currentTarget.value)) {
      if (e.currentTarget.value.length >= 5 && e.currentTarget.value.length <= 50) {
        setWrongUri('');
      } else {
        setWrongUri('short');
      }
    } else {
      setWrongUri('dontMatch');
    }
  };

  var handleTypeMetadata = function handleTypeMetadata(e) {
    setMetadataValue(e.currentTarget.value);
  };

  var handleSelectImage = function handleSelectImage() {
    var image = fileUploader.current.files[0];
    resizeImage(image).then(function (resizedFile) {
      setNewAvatar({
        url: URL.createObjectURL(resizedFile.blob),
        name: image.name
      });
      setCropPopup(true);
    });
  };

  var handleImageCrop = function handleImageCrop(image) {
    setNewAvatar({
      src: {
        file: image
      },
      url: URL.createObjectURL(image)
    });
    fileUploader.current.value = null;
  };

  var handleCloseCropPopup = function handleCloseCropPopup(cropped) {
    if (!cropped) {
      setNewAvatar({
        src: {},
        url: ''
      });
    }

    fileUploader.current.value = null;
    setCropPopup(false);
  };

  return React__default.createElement(Container$3, null, usersPopupVisible && React__default.createElement(UsersPopup, {
    toggleCreatePopup: toggleCreatePopup,
    getSelectedUsers: handleAddMembersForCreateChannel,
    creatChannelSelectedMembers: selectedMembers,
    actionType: 'selectUsers',
    selectIsRequired: createPrivateChannel,
    popupHeight: '540px',
    popupWidth: '520px'
  }), createGroupChannelPopupVisible && React__default.createElement(PopupContainer, null, React__default.createElement(Popup, {
    maxHeight: '600px',
    width: '520px',
    maxWidth: '520px',
    padding: '0'
  }, React__default.createElement(PopupBody, {
    padding: 24
  }, React__default.createElement(CloseIcon, {
    onClick: toggleCreateGroupChannelPopup
  }), React__default.createElement(PopupName, {
    marginBottom: '20px'
  }, "Create ", createPrivateChannel ? 'Group' : 'Channel'), !createPrivateChannel && React__default.createElement(CrateChannelTitle, null, "Create a Channel to post your content to a large audience."), React__default.createElement(UploadChannelAvatar, null, newAvatar.url ? React__default.createElement(AvatarWrapper, null, React__default.createElement(Avatar, {
    image: newAvatar.url,
    size: 90,
    name: subjectValue
  }), React__default.createElement(RemoveSelectedAvatar, {
    onClick: function onClick() {
      return setNewAvatar({
        src: {},
        url: ''
      });
    }
  }, "Remove")) : React__default.createElement(UploadAvatarLabel, {
    htmlFor: 'uploadImage'
  }, React__default.createElement(SvgChosePicture, null)), React__default.createElement(FileUploaderInput, {
    ref: fileUploader,
    type: 'file',
    accept: '.png,.jpeg,.jpg',
    id: 'uploadImage',
    onChange: handleSelectImage
  })), React__default.createElement(Label, null, " ", createPrivateChannel ? 'Group' : 'Channel', " name"), React__default.createElement(CustomInput, {
    type: 'text',
    value: subjectValue,
    onChange: handleTypeSubject,
    placeholder: "Enter " + (createPrivateChannel ? 'group' : 'channel') + " name"
  }), React__default.createElement(Label, null, "Description"), React__default.createElement(CustomInput, {
    type: 'text',
    value: metadataValue,
    onChange: handleTypeMetadata,
    placeholder: "Enter " + (createPrivateChannel ? 'group' : 'channel') + " description"
  }), !createPrivateChannel && React__default.createElement(React__default.Fragment, null, React__default.createElement(Label, null, "URL"), React__default.createElement(UriInputWrapper, null, React__default.createElement(UriPrefix, null, uriPrefixOnCreateChannel), React__default.createElement(CustomInput, {
    type: 'text',
    value: URIValue,
    onChange: handleTypeURI,
    onBlur: checkURIRegexp,
    placeholder: 'chan12',
    error: !!wrongUri
  }), !!wrongUri && React__default.createElement(InputErrorMessage, null, wrongUri === 'short' ? 'The name should be 5-50 characters long' : 'The name is invalid. Please provide na name from the allowed range of characters')), React__default.createElement(ChannelUriDescription, null, "Give a URL to your channel so you can share it with others inviting them to join. Choose a name from the allowed range: a-z, 0-9, and _(underscores) between 5-50 characters."))), React__default.createElement(PopupFooter, {
    backgroundColor: colors.gray5
  }, React__default.createElement(Button, {
    type: 'button',
    color: colors.gray6,
    backgroundColor: 'transparent',
    onClick: function onClick() {
      return handleClose();
    }
  }, "Cancel"), React__default.createElement(Button, {
    type: 'button',
    backgroundColor: colors.primary,
    borderRadius: '8px',
    onClick: function onClick() {
      return GoToAddMember();
    },
    disabled: !subjectValue || !createPrivateChannel && (!URIValue || !!wrongUri)
  }, "Next"))), cropPopup && React__default.createElement(ImageCrop, {
    image: newAvatar,
    onAccept: handleImageCrop,
    handleClosePopup: function handleClosePopup(cropped) {
      return handleCloseCropPopup(cropped);
    }
  })));
}
CreateChannel.propTypes = {
  isButton: propTypes.bool
};
CreateChannel.defaultProps = {
  isButton: false
};
var Container$3 = styled.div(_templateObject$a || (_templateObject$a = _taggedTemplateLiteralLoose([""])));
var CrateChannelTitle = styled.h3(_templateObject2$a || (_templateObject2$a = _taggedTemplateLiteralLoose(["\n  font-size: 15px;\n  font-weight: 400;\n  line-height: 150%;\n  margin: 0 0 20px;\n  color: ", ";\n"])), colors.gray8);
var UploadAvatarLabel = styled.label(_templateObject3$7 || (_templateObject3$7 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  width: 90px;\n  height: 90px;\n  align-items: center;\n  justify-content: center;\n  background-color: ", ";\n  border-radius: 50%;\n  cursor: pointer;\n"])), colors.gray5);
var URILabel = styled.label(_templateObject4$5 || (_templateObject4$5 = _taggedTemplateLiteralLoose(["\n  display: inline-block;\n  font-weight: 500;\n  font-size: 14px;\n  line-height: 15px;\n  margin-top: 18px;\n  margin-bottom: 5px;\n"])));
var UploadChannelAvatar = styled.div(_templateObject5$3 || (_templateObject5$3 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n"])));
var FileUploaderInput = styled.input(_templateObject6$3 || (_templateObject6$3 = _taggedTemplateLiteralLoose(["\n  display: none;\n"])));
var RemoveSelectedAvatar = styled.span(_templateObject7$3 || (_templateObject7$3 = _taggedTemplateLiteralLoose(["\n  display: inline-block;\n  margin-left: 16px;\n  cursor: pointer;\n  font-weight: 400;\n  font-size: 15px;\n  line-height: 20px;\n  color: ", ";\n"])), colors.red1);
var ChannelUriDescription = styled.p(_templateObject8$3 || (_templateObject8$3 = _taggedTemplateLiteralLoose(["\n  margin-bottom: 8px;\n  font-weight: 400;\n  font-size: 13px;\n  line-height: 16px;\n  letter-spacing: -0.078px;\n  color: ", ";\n"])), colors.gray9);
var UriInputWrapper = styled.div(_templateObject9$3 || (_templateObject9$3 = _taggedTemplateLiteralLoose(["\n  position: relative;\n\n  & > input {\n    padding-left: 93px;\n  }\n"])));
var UriPrefix = styled.span(_templateObject10$3 || (_templateObject10$3 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  left: 15px;\n  top: 11px;\n  font-style: normal;\n  font-weight: normal;\n  font-size: 15px;\n"])));

var _templateObject$b, _templateObject2$b;

var CreateChannelButton = function CreateChannelButton(_ref) {
  var showSearch = _ref.showSearch,
      uriPrefixOnCreateChannel = _ref.uriPrefixOnCreateChannel,
      createChannelIcon = _ref.createChannelIcon,
      createChannelIconHoverBackground = _ref.createChannelIconHoverBackground;

  var _useState = useState(false),
      showAddMemberPopup = _useState[0],
      setShowAddMemberPopup = _useState[1];

  var _useState2 = useState(''),
      showCreateChannel = _useState2[0],
      setShowCreateChannel = _useState2[1];

  var handleOpenCreateChannel = function handleOpenCreateChannel(channelType) {
    if (channelType === 'direct') {
      setShowAddMemberPopup(true);
    } else {
      setShowCreateChannel(channelType);
    }
  };

  return React__default.createElement(React__default.Fragment, null, React__default.createElement(DropDown, {
    forceClose: showAddMemberPopup || !!showCreateChannel,
    position: 'center',
    trigger: React__default.createElement(CreateDropdownButton, {
      hoverBackground: createChannelIconHoverBackground,
      leftAuto: !showSearch
    }, React__default.createElement(IconWrapper, null), createChannelIcon || React__default.createElement(SvgAddChat, null))
  }, React__default.createElement(DropdownOptionsUl, null, React__default.createElement(DropdownOptionLi, {
    key: 1,
    textColor: colors.gray6,
    hoverBackground: colors.gray5,
    onClick: function onClick() {
      return handleOpenCreateChannel('public');
    },
    iconWidth: '20px'
  }, React__default.createElement(SvgCreateChannel, null), "New channel"), React__default.createElement(DropdownOptionLi, {
    key: 2,
    textColor: colors.gray6,
    hoverBackground: colors.gray5,
    onClick: function onClick() {
      return handleOpenCreateChannel('private');
    },
    iconWidth: '20px'
  }, React__default.createElement(SvgCreateGroup, null), "New group"), React__default.createElement(DropdownOptionLi, {
    key: 3,
    textColor: colors.gray6,
    hoverBackground: colors.gray5,
    onClick: function onClick() {
      return handleOpenCreateChannel('direct');
    },
    iconWidth: '20px'
  }, React__default.createElement(SvgCreateChat, null), "New chat"))), showAddMemberPopup && React__default.createElement(UsersPopup, {
    popupHeight: '540px',
    popupWidth: '520px',
    toggleCreatePopup: function toggleCreatePopup() {
      return setShowAddMemberPopup(false);
    },
    actionType: 'createChat'
  }), showCreateChannel && React__default.createElement(CreateChannel, {
    handleClose: function handleClose() {
      return setShowCreateChannel('');
    },
    channelType: showCreateChannel,
    uriPrefixOnCreateChannel: uriPrefixOnCreateChannel
  }));
};
var IconWrapper = styled.span(_templateObject$b || (_templateObject$b = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  width: 40px;\n  height: 40px;\n  border-radius: 50%;\n  opacity: 0.2;\n"])));
var CreateDropdownButton = styled.div(_templateObject2$b || (_templateObject2$b = _taggedTemplateLiteralLoose(["\n  //margin-left: 12px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  overflow: hidden;\n  line-height: 55px;\n  margin-left: ", ";\n  width: 40px;\n  height: 40px;\n  border-radius: 50%;\n  &:hover {\n    & ", " {\n      background-color: ", ";\n    }\n  }\n  & > svg {\n    color: ", ";\n  }\n"])), function (props) {
  return props.leftAuto ? 'auto' : '12px';
}, IconWrapper, function (props) {
  return props.iconColor || colors.primary;
}, function (props) {
  return props.iconColor || colors.primary;
});

var _path$k;

function _extends$m() {
  _extends$m = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$m.apply(this, arguments);
}

function SvgArrowLeft(props) {
  return /*#__PURE__*/createElement("svg", _extends$m({
    width: 24,
    height: 24,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$k || (_path$k = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M11.566 6.435a.8.8 0 010 1.13L7.93 11.2H18a.8.8 0 010 1.6H7.931l3.635 3.634a.8.8 0 01-1.132 1.132l-5-5a.8.8 0 010-1.132l5-5a.8.8 0 011.132 0z",
    fill: "#818C99"
  })));
}

var _path$l;

function _extends$n() {
  _extends$n = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$n.apply(this, arguments);
}

function SvgDevaultAvatar50(props) {
  return /*#__PURE__*/createElement("svg", _extends$n({
    width: 48,
    height: 48,
    viewBox: "0 0 50 50",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$l || (_path$l = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M38.978 45.73A24.885 24.885 0 0125 50a24.89 24.89 0 01-15-4.998C3.928 40.44 0 33.179 0 25 0 11.193 11.193 0 25 0s25 11.193 25 25c0 8.63-4.372 16.238-11.022 20.73zM25 26.25c4.142 0 7.5-3.638 7.5-8.125S29.142 10 25 10c-4.142 0-7.5 3.638-7.5 8.125s3.358 8.125 7.5 8.125zM25 45a19.934 19.934 0 0013.908-5.628C36.682 33.877 31.294 30 25 30s-11.682 3.877-13.908 9.372A19.933 19.933 0 0025 45z",
    fill: "CurrentColor"
  })));
}

var _g$2;

function _extends$o() {
  _extends$o = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$o.apply(this, arguments);
}

function SvgNotifications(props) {
  return /*#__PURE__*/createElement("svg", _extends$o({
    xmlns: "http://www.w3.org/2000/svg",
    width: 20,
    height: 20
  }, props), _g$2 || (_g$2 = /*#__PURE__*/createElement("g", {
    fill: "CurrentColor"
  }, /*#__PURE__*/createElement("path", {
    d: "M8.531 15.953a1.304 1.304 0 00-.094.496c0 .824.7 1.488 1.563 1.488s1.563-.664 1.563-1.488c0-.18-.043-.34-.094-.496zm0 0M16.344 13.223c-.625-.348-1.137-.93-1.137-1.836V8.016c0-2.739-2.457-4.961-5.207-4.961s-5.207 2.222-5.207 4.96v3.372c0 .894-.523 1.488-1.137 1.836-.418.238-.949.566-.949.964 0 .454.305.762.93.762h12.726c.625 0 .93-.316.93-.761 0-.399-.523-.727-.95-.965zm0 0",
    fillRule: "evenodd"
  }), /*#__PURE__*/createElement("path", {
    d: "M10 4.047c.574 0 1.043-.442 1.043-.992 0-.547-.469-.993-1.043-.993s-1.043.446-1.043.993c0 .55.469.992 1.043.992zm0 0"
  }))));
}

var _path$m;

function _extends$p() {
  _extends$p = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$p.apply(this, arguments);
}

function SvgLock(props) {
  return /*#__PURE__*/createElement("svg", _extends$p({
    width: 20,
    height: 20,
    viewBox: "0 0 21 21",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$m || (_path$m = /*#__PURE__*/createElement("path", {
    d: "M10 2.5a4.167 4.167 0 014.166 4.167v1.666h.364c.743 0 1.012.078 1.284.223.271.145.485.358.63.63.145.272.222.541.222 1.284v4.893c0 .743-.077 1.013-.222 1.284a1.514 1.514 0 01-.63.63c-.272.146-.541.223-1.284.223H5.47c-.743 0-1.013-.077-1.284-.223a1.515 1.515 0 01-.63-.63c-.146-.271-.223-.54-.223-1.284V10.47c0-.743.077-1.012.223-1.284.145-.272.358-.485.63-.63.271-.145.54-.223 1.284-.223h.362l.001-1.666A4.167 4.167 0 0110 2.5zm0 1.667a2.5 2.5 0 00-2.5 2.5l-.001 1.666h5V6.667a2.5 2.5 0 00-2.5-2.5z",
    fill: "CurrentColor"
  })));
}

var _path$n;

function _extends$q() {
  _extends$q = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$q.apply(this, arguments);
}

function SvgLeave(props) {
  return /*#__PURE__*/createElement("svg", _extends$q({
    width: 20,
    height: 20,
    viewBox: "0 0 20.01 20.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$n || (_path$n = /*#__PURE__*/createElement("path", {
    d: "M9.457 9.68h-7.03c-.47 0-.86.362-.86.82 0 .458.39.82.86.82h7.03l-1.56 1.477a.793.793 0 000 1.163.89.89 0 001.213 0l3.038-2.878h0l.006-.006h0a.799.799 0 00.248-.573v-.005a.784.784 0 00-.066-.313M9.457 9.68l2.88.505m-2.88-.505l-1.56-1.477a.793.793 0 010-1.163.89.89 0 011.213 0l3.038 2.878m-2.69-.238l2.69.238m.188.267s0 0 0 0l-.091.04.091-.04zm-.188-.267l-.069.073.069-.073h0zm-1.365 8.599h2.011c.82 0 1.488 0 2.03-.042.559-.043 1.06-.135 1.525-.36a3.805 3.805 0 001.705-1.616c.238-.443.336-.919.381-1.45.045-.514.045-1.146.045-1.923V7.874c0-.776 0-1.409-.045-1.923-.045-.53-.143-1.007-.381-1.45a3.805 3.805 0 00-1.705-1.615c-.466-.225-.966-.317-1.526-.36-.541-.043-1.208-.043-2.029-.042h-.003 0-2.008c-.47 0-.86.361-.86.82 0 .457.39.819.86.819h1.975c.865 0 1.462 0 1.926.036.454.036.704.1.888.19.41.197.744.513.952.9.093.173.16.408.198.837.038.438.038 1.003.038 1.823v5.182c0 .82 0 1.385-.038 1.824-.037.429-.105.664-.198.836-.208.387-.541.703-.952.901-.184.089-.434.154-.888.189-.464.036-1.061.036-1.926.036h-1.975c-.47 0-.86.362-.86.82 0 .458.39.82.86.82z",
    fill: "CurrentColor",
    stroke: "CurrentColor",
    strokeWidth: 0.2
  })));
}

var _templateObject$c, _templateObject2$c, _templateObject3$8;

var EditProfile = function EditProfile(_ref) {
  var handleCloseEditProfile = _ref.handleCloseEditProfile,
      user = _ref.user;
  var dispatch = useDispatch();

  var _useState = useState(user.firstName),
      firstName = _useState[0],
      setFirstName = _useState[1];

  var _useState2 = useState(user.lastName),
      lastName = _useState2[0],
      setLastName = _useState2[1];

  var handleTypeFirstName = function handleTypeFirstName(e) {
    setFirstName(e.target.value);
  };

  var handleTypeLastName = function handleTypeLastName(e) {
    setLastName(e.target.value);
  };

  var handleEditProfile = function handleEditProfile() {
    dispatch(updateProfileAC(user, firstName, lastName, '', '', undefined));
    handleCloseEditProfile();
  };

  return React__default.createElement(Container$4, null, React__default.createElement(EditAvatarCont, null, React__default.createElement(Avatar, {
    name: user.firstName || user.id,
    size: 144,
    image: user.avatarUrl,
    setDefaultAvatar: true
  })), React__default.createElement(EditProfileBody, null, React__default.createElement(Label, null, "Firstname"), React__default.createElement(CustomInput, {
    type: 'text',
    value: firstName,
    onChange: handleTypeFirstName,
    placeholder: 'Firstname'
  }), React__default.createElement(Label, null, "Lastname"), React__default.createElement(CustomInput, {
    type: 'text',
    value: lastName,
    onChange: handleTypeLastName,
    placeholder: 'Lastname'
  })), React__default.createElement(PopupFooter, null, React__default.createElement(Button, {
    onClick: handleCloseEditProfile,
    backgroundColor: colors.gray0,
    color: colors.gray6,
    borderRadius: '8px'
  }, "Cancel"), React__default.createElement(Button, {
    onClick: handleEditProfile,
    backgroundColor: colors.primary,
    borderRadius: '8px',
    margin: '0 0 0 12px'
  }, "Save")));
};
var Container$4 = styled.div(_templateObject$c || (_templateObject$c = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 64px;\n  left: 0;\n  background-color: ", ";\n"])), colors.white);
var EditAvatarCont = styled.div(_templateObject2$c || (_templateObject2$c = _taggedTemplateLiteralLoose(["\n  display: flex;\n  justify-content: center;\n  margin: 20px 0 24px;\n"])));
var EditProfileBody = styled.div(_templateObject3$8 || (_templateObject3$8 = _taggedTemplateLiteralLoose(["\n  padding: 0 16px;\n  margin-bottom: 16px;\n"])));

var _templateObject$d, _templateObject2$d, _templateObject3$9, _templateObject4$6, _templateObject5$4, _templateObject6$4;
var settingsPages = {
  profile: 'Profile',
  notifications: 'Notifications',
  about: 'About'
};

var ProfileSettings = function ProfileSettings(_ref) {
  var handleCloseProfile = _ref.handleCloseProfile;

  var _useState = useState(false),
      editProfileIsOpen = _useState[0],
      setEditProfileIsOpen = _useState[1];

  var _useState2 = useState(''),
      activeSettingPage = _useState2[0],
      setActiveSettingPage = _useState2[1];

  var user = useSelector(userSelector);

  var handleOpenEditProfile = function handleOpenEditProfile() {
    setActiveSettingPage(editProfileIsOpen ? '' : settingsPages.profile);
    setEditProfileIsOpen(!editProfileIsOpen);
  };

  return React__default.createElement(Container$5, null, React__default.createElement(SettingsHeader, null, React__default.createElement(ArrowLeftWrapper, {
    onClick: activeSettingPage === settingsPages.profile ? handleOpenEditProfile : handleCloseProfile
  }, React__default.createElement(SvgArrowLeft, null)), React__default.createElement(SectionHeader, null, activeSettingPage === settingsPages.profile ? 'Edit profile' : 'Settings')), React__default.createElement(ProfileInfo, null, React__default.createElement(Avatar, {
    name: user.firstName || user.id,
    size: 144,
    image: user.avatarUrl,
    setDefaultAvatar: true
  }), React__default.createElement(Username, null, user.firstName + " " + user.lastName), React__default.createElement(UserNumber, null, "+" + user.id)), React__default.createElement(DropdownOptionsUl, null, React__default.createElement(DropdownOptionLi, {
    hoverBackground: 'none',
    iconWidth: '20px',
    textColor: colors.gray6,
    iconColor: colors.gray4,
    margin: '0 0 24px',
    onClick: handleOpenEditProfile
  }, React__default.createElement(SvgDevaultAvatar50, null), " Profile"), React__default.createElement(DropdownOptionLi, {
    hoverBackground: 'none',
    iconWidth: '20px',
    textColor: colors.gray6,
    iconColor: colors.gray4,
    margin: '0 0 24px'
  }, React__default.createElement(SvgNotifications, null), " Notifications"), React__default.createElement(DropdownOptionLi, {
    hoverBackground: 'none',
    iconWidth: '20px',
    textColor: colors.gray6,
    iconColor: colors.gray4,
    margin: '0 0 24px'
  }, React__default.createElement(SvgLock, null), " About"), React__default.createElement(DropdownOptionLi, {
    hoverBackground: 'none',
    iconWidth: '20px',
    textColor: colors.red1,
    iconColor: colors.red1,
    margin: '0 0 24px'
  }, React__default.createElement(SvgLeave, null), " Log Out")), editProfileIsOpen && React__default.createElement(EditProfile, {
    user: user,
    handleCloseEditProfile: handleOpenEditProfile
  }));
};
var Container$5 = styled.div(_templateObject$d || (_templateObject$d = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  background-color: ", ";\n  border-right: 1px solid ", ";\n"])), colors.white, colors.gray1);
var SettingsHeader = styled.div(_templateObject2$d || (_templateObject2$d = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  padding: 16px;\n  height: 64px;\n  border-bottom: 1px solid ", ";\n  box-sizing: border-box;\n"])), colors.gray1);
var ArrowLeftWrapper = styled.span(_templateObject3$9 || (_templateObject3$9 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  cursor: pointer;\n  margin-right: 12px;\n"])));
var ProfileInfo = styled.div(_templateObject4$6 || (_templateObject4$6 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  margin: 20px 0 24px;\n"])));
var Username = styled.h3(_templateObject5$4 || (_templateObject5$4 = _taggedTemplateLiteralLoose(["\n  margin: 16px 0 0;\n  font-weight: 500;\n  font-size: 15px;\n  line-height: 18px;\n  letter-spacing: -0.2px;\n  color: ", ";\n"])), colors.gray6);
var UserNumber = styled.h4(_templateObject6$4 || (_templateObject6$4 = _taggedTemplateLiteralLoose(["\n  margin: 0;\n  font-weight: 400;\n  font-size: 13px;\n  line-height: 16px;\n  letter-spacing: -0.078px;\n  color: ", ";\n"])), colors.gray9);

var _templateObject$e, _templateObject2$e, _templateObject3$a, _templateObject4$7, _templateObject5$5, _templateObject6$5, _templateObject7$4;

var ChannelList = function ChannelList(_ref) {
  var selectedChannelBackground = _ref.selectedChannelBackground,
      selectedChannelLeftBorder = _ref.selectedChannelLeftBorder,
      List = _ref.List,
      ListItem = _ref.ListItem,
      getActiveChannel = _ref.getActiveChannel,
      Profile = _ref.Profile,
      filter = _ref.filter,
      limit = _ref.limit,
      sort = _ref.sort,
      avatar = _ref.avatar,
      _ref$showSearch = _ref.showSearch,
      showSearch = _ref$showSearch === void 0 ? true : _ref$showSearch,
      _ref$searchOption = _ref.searchOption,
      searchOption = _ref$searchOption === void 0 ? 'default' : _ref$searchOption,
      _ref$showCreateChanne = _ref.showCreateChannelIcon,
      showCreateChannelIcon = _ref$showCreateChanne === void 0 ? true : _ref$showCreateChanne,
      uriPrefixOnCreateChannel = _ref.uriPrefixOnCreateChannel,
      onChannelDeleted = _ref.onChannelDeleted,
      onChannelCreated = _ref.onChannelCreated,
      onChannelHidden = _ref.onChannelHidden,
      onChannelVisible = _ref.onChannelVisible,
      onAddedToChannel = _ref.onAddedToChannel,
      notificationsIsMutedIcon = _ref.notificationsIsMutedIcon,
      notificationsIsMutedIconColor = _ref.notificationsIsMutedIconColor,
      createChannelIcon = _ref.createChannelIcon,
      createChannelIconHoverBackground = _ref.createChannelIconHoverBackground;
  var dispatch = useDispatch();
  var getFromContacts = getShowOnlyContactUsers();
  var channelListRef = useRef(null);

  var _useState = useState(''),
      searchValue = _useState[0],
      setSearchValue = _useState[1];

  var connectionStatus = useSelector(connectionStatusSelector);
  var channels = useSelector(channelsSelector, shallowEqual) || [];
  var contactsMap = useSelector(contactsMapSelector);
  var addedChannel = useSelector(addedChannelSelector);
  var addedToChannel = useSelector(addedToChannelSelector);
  var deletedChannel = useSelector(deletedChannelSelector);
  var hiddenChannel = useSelector(hiddenChannelSelector);
  var visibleChannel = useSelector(visibleChannelSelector);
  var channelsHasNext = useSelector(channelsHasNextSelector) || false;
  var directChannels = searchValue ? channels.filter(function (channel) {
    return channel.type === 'Direct';
  }) : [];
  var groupChannels = searchValue ? channels.filter(function (channel) {
    return channel.type !== 'Direct';
  }) : [];
  var channelsLoading = useSelector(channelsLoadingState) || {};
  var activeChannel = useSelector(activeChannelSelector) || {};

  var _useState2 = useState(false),
      profileIsOpen = _useState2[0],
      setProfileIsOpen = _useState2[1];

  var _useState3 = useState(),
      channelGroupsList = _useState3[0],
      setChannelGroupsList = _useState3[1];

  var handleSetChannelList = function handleSetChannelList(updatedChannels, isRemove) {
    if (isRemove) {
      var channelsMap = {};
      var makeMapFrom = isRemove ? updatedChannels : channels;
      var findIn = isRemove ? channels : updatedChannels;

      for (var i = 0; i < makeMapFrom.length; i++) {
        channelsMap[makeMapFrom[i].id] = true;
      }

      var channelsForAction = [];

      for (var j = 0; j < findIn.length; j++) {
        if (!channelsMap[findIn[j].id]) {
          channelsForAction.push(findIn[j]);
        }
      }

      channelsForAction.forEach(function (channelToDelete) {
        return removeChannelFromMap(channelToDelete.id);
      });
    }

    dispatch(setChannelsAC(updatedChannels));
  };

  var handleSetChannelListWithGroups = function handleSetChannelListWithGroups(channelGroupsList) {
    setChannelGroupsList(channelGroupsList);
  };

  var handleLoadMoreChannels = function handleLoadMoreChannels(count) {
    if (channelsLoading === LOADING_STATE.LOADED && !searchValue) {
      dispatch(loadMoreChannels(count));
    }
  };

  var handleAllChannelsListScroll = function handleAllChannelsListScroll(e) {
    if (!searchValue && channelsHasNext && e.target.scrollTop >= e.target.scrollHeight - e.target.offsetHeight - 200) {
      handleLoadMoreChannels();
    }
  };

  var handleChangeActiveChannel = function handleChangeActiveChannel(chan) {
    if (activeChannel.id !== chan.id) {
      dispatch(switchChannelActionAC(chan));
    }
  };

  var handleSearchValueChange = function handleSearchValueChange(e) {
    setSearchValue(e.target.value);
  };

  var getMyChannels = function getMyChannels() {
    setSearchValue('');
  };

  var handleOpenProfile = function handleOpenProfile() {
    setProfileIsOpen(!profileIsOpen);
  };

  useEffect(function () {
    if (deletedChannel) {
      if (onChannelDeleted) {
        onChannelDeleted(function (updatedChannels) {
          return handleSetChannelList(updatedChannels, true);
        }, deletedChannel);
      } else {
        removeChannelFromMap(deletedChannel.id);
        dispatch(removeChannelAC(deletedChannel.id));
      }

      dispatch(setChannelToRemoveAC(null));
    }
  }, [deletedChannel]);
  useDidUpdate(function () {
    console.log('connectionStatus.. .. ', connectionStatus);

    if (connectionStatus === CONNECTION_STATUS.CONNECTED) {
      dispatch(getChannelsAC({
        filter: filter,
        limit: limit,
        sort: sort,
        search: ''
      }, false));

      if (activeChannel.id) {
        dispatch(getMessagesAC(activeChannel));
      }

      clearMessagesMap();
      removeAllMessages();
    }
  }, [connectionStatus]);
  useEffect(function () {
    if (addedChannel) {
      if (onChannelCreated) {
        onChannelCreated(function (updatedChannels) {
          return handleSetChannelList(updatedChannels, false);
        }, addedChannel);
      } else {
        console.log('addedChannel add channel from comp ... ', addedToChannel);
        dispatch(addChannelAC(addedChannel));
      }

      dispatch(setChannelToAddAC(null));
    }
  }, [addedChannel]);
  useEffect(function () {
    if (addedToChannel) {
      if (onAddedToChannel) {
        onAddedToChannel(function (updatedChannels) {
          return handleSetChannelList(updatedChannels, false);
        }, addedToChannel);
      } else {
        dispatch(addChannelAC(addedToChannel));
      }

      dispatch(setChannelToAddAC(null));
    }
  }, [addedToChannel]);
  useEffect(function () {
    if (hiddenChannel) {
      if (onChannelHidden) {
        onChannelHidden(function (updatedChannels) {
          return handleSetChannelList(updatedChannels, true);
        }, hiddenChannel);
      } else {
        dispatch(removeChannelAC(hiddenChannel.id));
      }

      dispatch(setChannelToHideAC(null));
    }
  }, [hiddenChannel]);
  useEffect(function () {
    if (visibleChannel) {
      if (onChannelVisible) {
        onChannelVisible(function (updatedChannels) {
          return handleSetChannelList(updatedChannels, true);
        }, visibleChannel);
      } else {
        dispatch(addChannelAC(hiddenChannel));
      }

      dispatch(setChannelToUnHideAC(null));
    }
  }, [visibleChannel]);
  useDidUpdate(function () {
    if (searchOption === 'default') {
      dispatch(getChannelsAC({
        filter: filter,
        limit: limit,
        sort: sort,
        search: searchValue
      }));
    }
  }, [searchValue]);
  useDidUpdate(function () {
    if (getActiveChannel) {
      getActiveChannel(activeChannel);
    }
  }, [activeChannel.id]);
  useEffect(function () {
    dispatch(getChannelsAC({
      filter: filter,
      limit: limit,
      sort: sort,
      search: ''
    }, false));

    if (getFromContacts) {
      dispatch(getContactsAC());
    }

    if (selectedChannelBackground || selectedChannelLeftBorder) {
      setCustomColors(_extends({}, selectedChannelBackground && {
        selectedChannelBackground: selectedChannelBackground
      }, selectedChannelLeftBorder && {
        selectedChannelLeftBorder: selectedChannelLeftBorder
      }));
    }

    dispatch(setChannelListWithAC(channelListRef.current && channelListRef.current.clientWidth || 0));
  }, []);
  return React__default.createElement(React__default.Fragment, null, React__default.createElement(Container$6, {
    isCustomContainer: !!List,
    ref: channelListRef
  }, React__default.createElement(ChannelListHeader, {
    maxWidth: channelListRef.current && channelListRef.current.clientWidth || 0
  }, Profile, showSearch && React__default.createElement(ChannelSearch, {
    searchValue: searchValue,
    handleSearchValueChange: handleSearchValueChange,
    getMyChannels: getMyChannels
  }), showCreateChannelIcon && React__default.createElement(CreateChannelButton, {
    createChannelIcon: createChannelIcon,
    createChannelIconHoverBackground: createChannelIconHoverBackground,
    showSearch: showSearch,
    uriPrefixOnCreateChannel: uriPrefixOnCreateChannel
  })), List ? React__default.createElement(List, {
    channels: channels,
    loadMoreChannels: handleLoadMoreChannels,
    searchValue: searchValue,
    handleSetChannelListWithGroups: handleSetChannelListWithGroups
  }, !directChannels.length && !searchValue ? React__default.createElement(React__default.Fragment, null, channels.map(function (channel) {
    return ListItem ? React__default.createElement(ListItem, {
      channel: channel,
      setActiveChannel: handleChangeActiveChannel,
      key: channel.id
    }) : React__default.createElement(Channel, {
      notificationsIsMutedIcon: notificationsIsMutedIcon,
      notificationsIsMutedIconColor: notificationsIsMutedIconColor,
      avatar: avatar,
      channel: channel,
      key: channel.id,
      contactsMap: contactsMap
    });
  })) : channelsLoading === LOADING_STATE.LOADED && searchValue && (searchOption === 'custom' ? React__default.createElement("div", null, channelGroupsList ? channelGroupsList.map(function (channelGroup) {
    return React__default.createElement(React__default.Fragment, null, React__default.createElement(SearchedChannelsHeader, null, channelGroup.groupName), channelGroup.channelList.map(function (channel) {
      return React__default.createElement(Channel, {
        notificationsIsMutedIcon: notificationsIsMutedIcon,
        notificationsIsMutedIconColor: notificationsIsMutedIconColor,
        avatar: avatar,
        channel: channel,
        key: channel.id,
        contactsMap: contactsMap
      });
    }));
  }) : '') : React__default.createElement(React__default.Fragment, null, !!directChannels.length && React__default.createElement(DirectChannels, null, React__default.createElement(SearchedChannelsHeader, null, "DIRECT"), directChannels.map(function (channel) {
    return ListItem ? React__default.createElement(ListItem, {
      channel: channel,
      setActiveChannel: handleChangeActiveChannel,
      key: channel.id
    }) : React__default.createElement(Channel, {
      notificationsIsMutedIcon: notificationsIsMutedIcon,
      notificationsIsMutedIconColor: notificationsIsMutedIconColor,
      avatar: avatar,
      channel: channel,
      key: channel.id,
      contactsMap: contactsMap
    });
  })), !!groupChannels.length && React__default.createElement(GroupChannels, null, React__default.createElement(SearchedChannelsHeader, null, "GROUP"), groupChannels.map(function (channel) {
    return ListItem ? React__default.createElement(ListItem, {
      channel: channel,
      setActiveChannel: handleChangeActiveChannel,
      key: channel.id
    }) : React__default.createElement(Channel, {
      notificationsIsMutedIcon: notificationsIsMutedIcon,
      notificationsIsMutedIconColor: notificationsIsMutedIconColor,
      avatar: avatar,
      channel: channel,
      key: channel.id,
      contactsMap: contactsMap
    });
  }))))) : React__default.createElement(React__default.Fragment, null, !directChannels.length && !searchValue && React__default.createElement(ChannelsList, {
    onScroll: handleAllChannelsListScroll
  }, channels.map(function (channel) {
    return ListItem ? React__default.createElement(ListItem, {
      channel: channel,
      setActiveChannel: handleChangeActiveChannel,
      key: channel.id
    }) : React__default.createElement(Channel, {
      notificationsIsMutedIcon: notificationsIsMutedIcon,
      notificationsIsMutedIconColor: notificationsIsMutedIconColor,
      avatar: avatar,
      channel: channel,
      key: channel.id,
      contactsMap: contactsMap
    });
  })), channelsLoading === LOADING_STATE.LOADED && searchValue && React__default.createElement(SearchedChannels, null, !!directChannels.length && React__default.createElement(DirectChannels, null, React__default.createElement(SearchedChannelsHeader, null, "DIRECT"), directChannels.map(function (channel) {
    return ListItem ? React__default.createElement(ListItem, {
      channel: channel,
      setActiveChannel: handleChangeActiveChannel,
      key: channel.id
    }) : React__default.createElement(Channel, {
      notificationsIsMutedIcon: notificationsIsMutedIcon,
      notificationsIsMutedIconColor: notificationsIsMutedIconColor,
      avatar: avatar,
      channel: channel,
      contactsMap: contactsMap,
      key: channel.id
    });
  })), !!groupChannels.length && React__default.createElement(GroupChannels, null, React__default.createElement(SearchedChannelsHeader, null, "GROUP"), groupChannels.map(function (channel) {
    return ListItem ? React__default.createElement(ListItem, {
      channel: channel,
      setActiveChannel: handleChangeActiveChannel,
      key: channel.id
    }) : React__default.createElement(Channel, {
      notificationsIsMutedIcon: notificationsIsMutedIcon,
      notificationsIsMutedIconColor: notificationsIsMutedIconColor,
      avatar: avatar,
      channel: channel,
      key: channel.id,
      contactsMap: contactsMap
    });
  })))), profileIsOpen && React__default.createElement(ProfileSettings, {
    handleCloseProfile: handleOpenProfile
  })));
};
var Container$6 = styled.div(_templateObject$e || (_templateObject$e = _taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  width: ", ";\n  min-width: ", ";\n  //border-right: ", ";\n\n  ", ";\n"])), function (props) {
  return props.isCustomContainer ? '' : '360px';
}, function (props) {
  return props.isCustomContainer ? '' : '360px';
}, function (props) {
  return props.isCustomContainer ? '' : '1px solid #DFE0EB';
}, function (props) {
  return props.isCustomContainer ? '' : "\n    @media  " + device.laptopL + " {\n      width: 310px;\n      min-width: auto;\n    }\n ";
});
var ChannelsList = styled.div(_templateObject2$e || (_templateObject2$e = _taggedTemplateLiteralLoose(["\n  border-right: 1px solid ", ";\n  overflow-y: auto;\n  width: 360px;\n  height: 100%;\n"])), colors.gray1);
var SearchedChannels = styled.div(_templateObject3$a || (_templateObject3$a = _taggedTemplateLiteralLoose(["\n  height: calc(100vh - 123px);\n  overflow-x: hidden;\n"])));
var SearchedChannelsHeader = styled.p(_templateObject4$7 || (_templateObject4$7 = _taggedTemplateLiteralLoose(["\n  padding-left: 16px;\n  font-weight: 500;\n  font-size: 15px;\n  line-height: 14px;\n  color: #676a7c;\n"])));
var DirectChannels = styled.div(_templateObject5$5 || (_templateObject5$5 = _taggedTemplateLiteralLoose([""])));
var GroupChannels = styled.div(_templateObject6$5 || (_templateObject6$5 = _taggedTemplateLiteralLoose([""])));
var ChannelListHeader = styled.div(_templateObject7$4 || (_templateObject7$4 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  flex-direction: row;\n  justify-content: space-between;\n  //justify-content: flex-end;\n  padding: 12px;\n  border-right: 1px solid ", ";\n  border-bottom: 1px solid ", ";\n  min-height: 64px;\n  box-sizing: border-box;\n  max-width: ", ";\n"])), colors.gray1, colors.gray1, function (props) {
  return props.maxWidth && props.maxWidth + "px";
});

var _templateObject$f;
function Chat$1(_ref) {
  var children = _ref.children;
  var channelListWidth = useSelector(channelListWidthSelector, shallowEqual);
  var channelDetailsIsOpen = useSelector(channelInfoIsOpenSelector, shallowEqual);
  useEffect(function () {});
  return React__default.createElement(Container$7, {
    widthOffset: channelListWidth,
    channelDetailsIsOpen: channelDetailsIsOpen
  }, children);
}
var Container$7 = styled.div(_templateObject$f || (_templateObject$f = _taggedTemplateLiteralLoose(["\n  position: relative;\n  width: 100%;\n  max-width: ", ";\n  display: flex;\n  flex-direction: column;\n"])), function (props) {
  return props.widthOffset || props.channelDetailsIsOpen ? "calc(100% - " + (props.widthOffset + (props.channelDetailsIsOpen ? 362 : 0)) + "px)" : '';
});

var _path$o;

function _extends$r() {
  _extends$r = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$r.apply(this, arguments);
}

function SvgInfo(props) {
  return /*#__PURE__*/createElement("svg", _extends$r({
    width: 22,
    height: 22,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$o || (_path$o = /*#__PURE__*/createElement("path", {
    d: "M11 20.167a9.167 9.167 0 100-18.333 9.167 9.167 0 000 18.333zM11 14.667V11M11 7.334h.01",
    stroke: "CurrentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })));
}

var _templateObject$g, _templateObject2$f, _templateObject3$b, _templateObject4$8;
var Container$8 = styled.div(_templateObject$g || (_templateObject$g = _taggedTemplateLiteralLoose(["\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 16px;\n  height: 64px;\n  box-sizing: border-box;\n  border-bottom: 1px solid ", ";\n"])), colors.gray1);
var ChannelInfo$1 = styled.div(_templateObject2$f || (_templateObject2$f = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n\n  & ", " {\n    width: 10px;\n    height: 10px;\n  }\n"])), UserStatus);
var ChannelName = styled.div(_templateObject3$b || (_templateObject3$b = _taggedTemplateLiteralLoose(["\n  margin-left: 7px;\n"])));
var ChanelInfo = styled.span(_templateObject4$8 || (_templateObject4$8 = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n\n  > svg {\n    color: ", ";\n  }\n"])), function (props) {
  return props.infoIconColor;
});
function ChatHeader(_ref) {
  var infoIcon = _ref.infoIcon;
  var dispatch = useDispatch();
  var getFromContacts = getShowOnlyContactUsers();

  var _useState = useState(false),
      infoButtonVisible = _useState[0],
      setInfoButtonVisible = _useState[1];

  var activeChannel = useSelector(activeChannelSelector);
  var channelDetailsIsOpen = useSelector(channelInfoIsOpenSelector, shallowEqual);
  var isDirectChannel = activeChannel.type === CHANNEL_TYPE.DIRECT;
  var contactsMap = useSelector(contactsMapSelector);

  var channelDetailsOnOpen = function channelDetailsOnOpen() {
    dispatch(switchChannelInfoAC(!channelDetailsIsOpen));
  };

  var channelDetailsOpen = false;
  useEffect(function () {
    {
      setTimeout(function () {
        setInfoButtonVisible(!channelDetailsOpen);
      }, 90);
    }
  }, [channelDetailsOpen]);
  return React__default.createElement(Container$8, null, React__default.createElement(ChannelInfo$1, null, React__default.createElement(AvatarWrapper, null, (activeChannel.subject || isDirectChannel && activeChannel.peer) && React__default.createElement(Avatar, {
    name: activeChannel.subject || (isDirectChannel ? activeChannel.peer.firstName || activeChannel.peer.id : ''),
    image: activeChannel.avatarUrl || (isDirectChannel ? activeChannel.peer.avatarUrl : ''),
    size: 36,
    textSize: 13,
    setDefaultAvatar: isDirectChannel
  })), React__default.createElement(ChannelName, null, React__default.createElement(SectionHeader, null, activeChannel.subject || (isDirectChannel ? makeUserName(contactsMap[activeChannel.peer.id], activeChannel.peer, getFromContacts) : '')), isDirectChannel ? React__default.createElement(SubTitle, null, hideUserPresence(activeChannel.peer) ? '' : activeChannel.peer.presence && (activeChannel.peer.presence.state === PRESENCE_STATUS.ONLINE ? 'Online' : activeChannel.peer.presence.lastActiveAt && userLastActiveDateFormat(activeChannel.peer.presence.lastActiveAt))) : React__default.createElement(SubTitle, null, !activeChannel.subject && !isDirectChannel ? '' : activeChannel.memberCount + " " + (activeChannel.type === CHANNEL_TYPE.PUBLIC ? activeChannel.memberCount > 1 ? 'subscribers' : 'subscriber' : activeChannel.memberCount > 1 ? 'members' : 'member') + " "))), React__default.createElement(ChanelInfo, {
    onClick: function onClick() {
      return channelDetailsOnOpen();
    },
    infoIconColor: channelDetailsIsOpen ? colors.primary : colors.gray4
  }, infoButtonVisible && (infoIcon || React__default.createElement(SvgInfo, null))));
}

var _templateObject$h;
var Container$9 = styled.div(_templateObject$h || (_templateObject$h = _taggedTemplateLiteralLoose(["\n  text-align: center;\n  margin: ", ";\n  display: ", ";\n  align-items: center;\n  width: ", ";\n  height: 26px;\n  z-index: 5;\n  top: 0;\n  background: transparent;\n  div {\n    position: relative;\n    border-bottom: ", ";\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    background: transparent;\n    span {\n      position: absolute;\n      top: -13px;\n      font-style: normal;\n      font-weight: normal;\n      font-size: ", ";\n      color: ", ";\n      background: ", ";\n      //border: ", ";\n      box-sizing: border-box;\n      border-radius: ", ";\n      padding: 5px 16px;\n\n      &::before {\n        content: '';\n        position: absolute;\n        left: ", ";\n        top: 0;\n        height: 100%;\n        width: ", ";\n        background-color: #fff;\n      }\n\n      &::after {\n        content: '';\n        position: absolute;\n        right: ", ";\n        top: 0;\n        height: 100%;\n        width: ", ";\n        background-color: #fff;\n      }\n    }\n  }\n"])), function (props) {
  return props.noMargin ? '0 auto' : '16px auto 0';
}, function (props) {
  return props.dividerVisibility ? 'flex' : 'none';
}, function (props) {
  return props.width || '100%';
}, function (props) {
  return props.dateDividerBorder || "1px solid " + colors.gray1;
}, function (props) {
  return props.dateDividerFontSize || '14px';
}, function (props) {
  return props.dateDividerTextColor || colors.blue6;
}, function (props) {
  return props.dateDividerBackgroundColor || '#ffffff';
}, function (props) {
  return props.dateDividerBorder || "1px solid " + colors.gray1;
}, function (props) {
  return props.dateDividerBorderRadius || '14px';
}, function (props) {
  return props.newMessagesSeparatorLeftRightSpaceWidth ? "-" + props.newMessagesSeparatorLeftRightSpaceWidth : '-12px';
}, function (props) {
  return props.newMessagesSeparatorLeftRightSpaceWidth ? "" + props.newMessagesSeparatorLeftRightSpaceWidth : '12px';
}, function (props) {
  return props.newMessagesSeparatorLeftRightSpaceWidth ? "-" + props.newMessagesSeparatorLeftRightSpaceWidth : '-12px';
}, function (props) {
  return props.newMessagesSeparatorLeftRightSpaceWidth ? "" + props.newMessagesSeparatorLeftRightSpaceWidth : '12px';
});
function MessageDivider(_ref) {
  var dividerText = _ref.dividerText,
      visibility = _ref.visibility,
      unread = _ref.unread,
      dateDividerFontSize = _ref.dateDividerFontSize,
      dateDividerTextColor = _ref.dateDividerTextColor,
      dateDividerBorder = _ref.dateDividerBorder,
      dateDividerBackgroundColor = _ref.dateDividerBackgroundColor,
      dateDividerBorderRadius = _ref.dateDividerBorderRadius,
      systemMessage = _ref.systemMessage,
      newMessagesSeparatorTextColor = _ref.newMessagesSeparatorTextColor,
      newMessagesSeparatorFontSize = _ref.newMessagesSeparatorFontSize,
      newMessagesSeparatorWidth = _ref.newMessagesSeparatorWidth,
      newMessagesSeparatorBorder = _ref.newMessagesSeparatorBorder,
      newMessagesSeparatorBorderRadius = _ref.newMessagesSeparatorBorderRadius,
      newMessagesSeparatorBackground = _ref.newMessagesSeparatorBackground,
      newMessagesSeparatorLeftRightSpaceWidth = _ref.newMessagesSeparatorLeftRightSpaceWidth,
      noMargin = _ref.noMargin;
  return React__default.createElement(Container$9, {
    className: unread ? 'unread' : 'divider',
    systemMessage: systemMessage,
    dividerVisibility: !visibility || unread,
    dateDividerFontSize: dateDividerFontSize || newMessagesSeparatorFontSize,
    dateDividerTextColor: dateDividerTextColor || newMessagesSeparatorTextColor,
    dateDividerBorder: dateDividerBorder || newMessagesSeparatorBorder,
    dateDividerBackgroundColor: dateDividerBackgroundColor || newMessagesSeparatorBackground,
    dateDividerBorderRadius: dateDividerBorderRadius || newMessagesSeparatorBorderRadius,
    width: newMessagesSeparatorWidth,
    newMessagesSeparatorLeftRightSpaceWidth: newMessagesSeparatorLeftRightSpaceWidth,
    noMargin: noMargin
  }, React__default.createElement("div", null, React__default.createElement("span", null, dividerText)));
}

var _path$p, _path2$3;

function _extends$s() {
  _extends$s = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$s.apply(this, arguments);
}

function SvgForward(props) {
  return /*#__PURE__*/createElement("svg", _extends$s({
    width: 18,
    height: 18,
    viewBox: "0 0 18.01 18.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$p || (_path$p = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M14.764 7.12a.86.86 0 00-.86-.86h-7.63C3.77 6.26 1.8 8.36 1.8 10.88c0 2.519 1.97 4.62 4.473 4.62H7.96a.86.86 0 000-1.72H6.273c-1.49 0-2.754-1.266-2.754-2.9 0-1.635 1.265-2.901 2.754-2.901h7.631a.86.86 0 00.86-.86z",
    fill: "CurrentColor"
  })), _path2$3 || (_path2$3 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M11.16 2.75a.86.86 0 00-.003 1.216l3.182 3.192-3.182 3.192a.86.86 0 001.218 1.214l3.786-3.799a.86.86 0 000-1.214l-3.786-3.798a.86.86 0 00-1.216-.002z",
    fill: "CurrentColor"
  })));
}

var _path$q;

function _extends$t() {
  _extends$t = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$t.apply(this, arguments);
}

function SvgTrash(props) {
  return /*#__PURE__*/createElement("svg", _extends$t({
    width: 16,
    height: 16,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$q || (_path$q = /*#__PURE__*/createElement("path", {
    d: "M1.5 3.89h13M5.111 3.889V2.444A1.444 1.444 0 016.556 1h2.888a1.444 1.444 0 011.445 1.444V3.89m2.167 0V14a1.444 1.444 0 01-1.445 1.444H4.39A1.444 1.444 0 012.944 14V3.889h10.112zM6.556 7.5v4.333M9.444 7.5v4.333",
    stroke: "currentColor",
    strokeWidth: 1.4,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })));
}

var _path$r;

function _extends$u() {
  _extends$u = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$u.apply(this, arguments);
}

function SvgReportIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$u({
    width: 18,
    height: 18,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$r || (_path$r = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M6.623 1.5h4.754c.51-.001.908.16 1.274.528l3.321 3.32c.362.361.53.756.528 1.275v4.754c.001.519-.166.914-.528 1.274l-3.32 3.321c-.36.362-.756.53-1.275.528H6.623a1.675 1.675 0 01-1.274-.528l-3.321-3.32a1.675 1.675 0 01-.528-1.275V6.623a1.675 1.675 0 01.528-1.274l3.32-3.321A1.675 1.675 0 016.624 1.5zm-.337 1.52L3.02 6.285c-.136.136-.155.183-.155.375v4.678c0 .19.019.239.155.375l3.267 3.267c.136.136.183.155.375.155h4.678c.192 0 .239-.019.375-.155l3.267-3.267c.136-.136.155-.186.155-.375V6.66c0-.192-.02-.24-.155-.375L11.714 3.02c-.137-.136-.184-.155-.375-.155H6.66c-.192 0-.241.021-.375.155zm3.472 9.01a.758.758 0 11-1.516 0 .758.758 0 011.516 0zm-.076-6.136a.682.682 0 00-1.364 0v3.94a.682.682 0 001.364 0v-3.94z",
    fill: "currentColor"
  })));
}

var _path$s;

function _extends$v() {
  _extends$v = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$v.apply(this, arguments);
}

function SvgEditSquare(props) {
  return /*#__PURE__*/createElement("svg", _extends$v({
    width: 15,
    height: 14,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$s || (_path$s = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10.78.56a1.91 1.91 0 112.703 2.702L7.539 9.206a.67.67 0 01-.267.164l-1.3.422-.516.168a1.09 1.09 0 01-1.374-1.374l.168-.516.423-1.3a.67.67 0 01.164-.267L10.78.56zM5.51 8.532l.048-.015 1.146-.373 4.257-4.258-.805-.805L5.9 7.339l-.373 1.146-.015.047zm5.536-6.34l.805.805.683-.684a.569.569 0 000-.804.57.57 0 00-.805 0l-.683.683zm-4.03-.418H2.349A2.348 2.348 0 000 4.122v7.53A2.348 2.348 0 002.348 14H9.9a2.348 2.348 0 002.348-2.348V7.004l-1.341 1.342v3.307a1.006 1.006 0 01-1.006 1.006H2.348a1.006 1.006 0 01-1.006-1.006v-7.53a1.006 1.006 0 011.006-1.006h3.327l1.342-1.342z",
    fill: "currentColor"
  })));
}

var _path$t;

function _extends$w() {
  _extends$w = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$w.apply(this, arguments);
}

function SvgResend(props) {
  return /*#__PURE__*/createElement("svg", _extends$w({
    width: 17,
    height: 15,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$t || (_path$t = /*#__PURE__*/createElement("path", {
    d: "M15.913 7.425l-7.23-6.281a.1.1 0 00-.165.075v3.585a.101.101 0 01-.095.101c-.616.037-4.069.305-5.627 1.728C.894 8.371.966 12.608 1.02 13.726c.005.093.123.126.179.05.49-.66 2.003-2.597 3.359-3.243 1.268-.604 3.411-.476 3.872-.44a.097.097 0 01.089.098v3.59a.1.1 0 00.166.075l7.23-6.28a.1.1 0 000-.151z",
    stroke: "currentColor",
    strokeWidth: 1.4
  })));
}

var _path$u, _path2$4, _path3$2;

function _extends$x() {
  _extends$x = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$x.apply(this, arguments);
}

function SvgReact(props) {
  return /*#__PURE__*/createElement("svg", _extends$x({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$u || (_path$u = /*#__PURE__*/createElement("path", {
    d: "M15.913 3v4.174M13.826 5.088H18M6.174 11.348s1.043 1.739 2.782 1.739c1.74 0 2.783-1.74 2.783-1.74",
    stroke: "currentColor",
    strokeWidth: 1.3,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), _path2$4 || (_path2$4 = /*#__PURE__*/createElement("path", {
    d: "M6.87 7.87h.006M11.043 7.87h.007",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), _path3$2 || (_path3$2 = /*#__PURE__*/createElement("path", {
    d: "M15.913 9.957a6.957 6.957 0 11-4.708-6.584",
    stroke: "currentColor",
    strokeWidth: 1.3,
    strokeLinecap: "round"
  })));
}

var _path$v;

function _extends$y() {
  _extends$y = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$y.apply(this, arguments);
}

function SvgReplyIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$y({
    width: 24,
    height: 24,
    viewBox: "0 0 24.01 24.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$v || (_path$v = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M19.78 12l-6.958-6.045v2.83c0 .452-.346.87-.847.899-.318.018-1.494.102-2.809.388-1.35.294-2.693.768-3.47 1.479-.94.857-1.459 2.44-1.706 4.128-.095.652-.146 1.29-.17 1.86.133-.152.272-.306.416-.46.753-.806 1.716-1.698 2.688-2.161.917-.437 2.086-.584 3.02-.63a16.68 16.68 0 012.052.027.897.897 0 01.826.896v2.834L19.78 12zm1.658-.68a.9.9 0 010 1.36l-8.726 7.58a.9.9 0 01-1.49-.68v-3.705a14.97 14.97 0 00-1.197.01c-.885.044-1.791.181-2.413.477-.686.327-1.479 1.03-2.206 1.808-.71.76-1.291 1.52-1.557 1.88-.483.655-1.577.39-1.622-.485a22.078 22.078 0 01.18-4.117c.256-1.751.835-3.823 2.21-5.079 1.11-1.014 2.814-1.557 4.21-1.86a21.08 21.08 0 012.395-.37v-3.72a.9.9 0 011.49-.68l8.726 7.582z",
    fill: "currentColor"
  })));
}

var _path$w;

function _extends$z() {
  _extends$z = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$z.apply(this, arguments);
}

function SvgCopy(props) {
  return /*#__PURE__*/createElement("svg", _extends$z({
    width: 18,
    height: 18,
    viewBox: "0 0 18.01 18.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$w || (_path$w = /*#__PURE__*/createElement("path", {
    d: "M3 13.5a1.508 1.508 0 01-1.5-1.508V4.138A2.638 2.638 0 014.138 1.5h7.854c.83 0 1.504.67 1.508 1.5H5.073A2.073 2.073 0 003 5.073V13.5zm3.008-9h8.985c.832 0 1.507.675 1.507 1.508v8.985c0 .832-.675 1.507-1.508 1.507H6.008A1.507 1.507 0 014.5 14.992V6.008c0-.832.675-1.507 1.508-1.507zM6.75 6a.75.75 0 00-.75.75v7.5c0 .414.336.75.75.75h7.5a.75.75 0 00.75-.75v-7.5a.75.75 0 00-.75-.75h-7.5z",
    fill: "CurrentColor"
  })));
}

var _path$x;

function _extends$A() {
  _extends$A = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$A.apply(this, arguments);
}

function SvgThreadReply(props) {
  return /*#__PURE__*/createElement("svg", _extends$A({
    width: 20,
    height: 20,
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$x || (_path$x = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M19.072 10.206c.26.255.283.66.068.942l-.06.068-4.901 5a.714.714 0 01-.95.061l-.068-.06-2.955-2.991a.714.714 0 01.95-1.064l.066.06 2.446 2.475 4.394-4.483a.714.714 0 011.01-.008zM6.786 12.144a.714.714 0 010 1.428H3.214a.714.714 0 010-1.428h3.572zm8.571-4.286a.714.714 0 110 1.429H3.214a.714.714 0 110-1.429h12.143zm0-4.286a.714.714 0 110 1.429H3.214a.714.714 0 010-1.429h12.143z"
  })));
}

var _path$y, _path2$5;

function _extends$B() {
  _extends$B = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$B.apply(this, arguments);
}

function SvgEmojiSmileIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$B({
    width: 24,
    height: 24,
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$y || (_path$y = /*#__PURE__*/createElement("path", {
    d: "M8.438 14.297a.9.9 0 011.273.149 2.77 2.77 0 00.516.415c.383.24.97.489 1.773.489.803 0 1.39-.25 1.773-.489a2.773 2.773 0 00.516-.415l.012-.013.002-.003a.9.9 0 011.4 1.132L15 15l.703.562-.001.001-.002.002-.002.003-.007.008-.018.022a3.487 3.487 0 01-.245.254c-.16.15-.394.344-.7.536A5.094 5.094 0 0112 17.15a5.094 5.094 0 01-2.727-.762 4.567 4.567 0 01-.7-.537 3.501 3.501 0 01-.246-.253l-.018-.022-.007-.008-.002-.003-.002-.002L9 15l-.703.562a.9.9 0 01.14-1.265zM10.25 10.25a1.25 1.25 0 11-2.5 0 1.25 1.25 0 012.5 0zM15 11.5A1.25 1.25 0 1015 9a1.25 1.25 0 000 2.5z"
  })), _path2$5 || (_path2$5 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12 2.1c-5.468 0-9.9 4.432-9.9 9.9 0 5.467 4.432 9.9 9.9 9.9s9.9-4.433 9.9-9.9c0-5.468-4.432-9.9-9.9-9.9zM3.9 12a8.1 8.1 0 1116.2 0 8.1 8.1 0 01-16.2 0z"
  })));
}

var _path$z;

function _extends$C() {
  _extends$C = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$C.apply(this, arguments);
}

function SvgEmojiAnimalIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$C({
    width: 24,
    height: 24,
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$z || (_path$z = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M14.068 3.405c.559-.56 1.345-.95 2.212-.804.873.147 1.481.776 1.81 1.496.33.723.424 1.61.26 2.5-.165.89-.57 1.689-1.133 2.254-.558.56-1.344.95-2.212.804-.872-.147-1.48-.776-1.81-1.497-.33-.722-.423-1.61-.258-2.5.164-.89.569-1.688 1.131-2.253zm1.215 1.21c-.291.292-.552.765-.66 1.355-.11.59-.034 1.114.132 1.476.166.364.378.492.535.518.161.027.418-.027.713-.323.291-.292.551-.765.66-1.355.11-.59.033-1.115-.132-1.476-.166-.364-.378-.492-.535-.518-.162-.027-.418.027-.713.323zM9.264 11.68c.632-.78 1.499-1.395 2.736-1.395 1.24 0 2.106.621 2.737 1.4.523.646.937 1.468 1.304 2.198l.151.299c.3.588.588 1.046.857 1.474.1.159.197.313.291.469.322.53.66 1.148.66 1.871 0 .587-.143 1.1-.44 1.517-.295.413-.69.661-1.073.809-.66.255-1.413.251-1.82.25l-.095-.001c-.464 0-.833-.065-1.16-.122l-.11-.02A7.038 7.038 0 0012 20.315c-.576 0-.953.056-1.302.116l-.11.02a6.337 6.337 0 01-1.16.12H9.24c-.447-.003-1.216-.025-1.889-.341a2.298 2.298 0 01-.964-.82C6.127 19.01 6 18.534 6 17.996c0-.695.344-1.316.658-1.839.09-.15.182-.3.277-.454.273-.441.568-.917.871-1.519l.14-.277c.37-.742.788-1.575 1.318-2.227zm.211 3.002l-.138.275c-.341.675-.691 1.24-.97 1.692-.088.14-.168.27-.239.389-.33.55-.414.794-.414.958 0 .264.06.401.108.475.05.075.127.145.258.206.298.14.723.175 1.171.179h.178c.308 0 .537-.04.87-.097l.11-.019c.4-.068.881-.14 1.591-.14s1.19.072 1.591.14l.11.02c.334.057.562.096.87.096h.034c.47 0 .918 0 1.265-.133.153-.06.24-.13.293-.205.052-.072.123-.219.123-.522 0-.2-.09-.452-.412-.983-.072-.119-.154-.25-.245-.393-.277-.441-.627-.997-.964-1.66l-.157-.31c-.381-.754-.705-1.394-1.103-1.886C12.988 12.25 12.57 12 12 12c-.57 0-.99.25-1.406.761-.403.497-.73 1.15-1.119 1.922zM11.063 5.659c-.164-.891-.569-1.69-1.131-2.254-.559-.56-1.345-.95-2.212-.804-.873.147-1.481.776-1.81 1.496-.33.723-.424 1.61-.26 2.5.165.89.57 1.689 1.132 2.254.56.56 1.345.95 2.213.804.872-.147 1.48-.776 1.81-1.497.33-.722.423-1.61.258-2.5zM8.004 4.292c.162-.027.418.027.713.323.291.292.552.765.66 1.355.11.59.034 1.114-.132 1.476-.166.364-.378.492-.535.518-.161.027-.418-.027-.713-.323-.291-.292-.551-.765-.66-1.355-.11-.59-.033-1.115.132-1.476.166-.364.378-.492.535-.518zM4.83 8.949c.648.367 1.214.975 1.588 1.723.374.746.518 1.558.398 2.285-.12.73-.526 1.445-1.298 1.78-.757.33-1.565.162-2.205-.201-.648-.367-1.214-.976-1.588-1.723-.374-.747-.518-1.558-.398-2.286.12-.73.526-1.445 1.297-1.78.757-.33 1.566-.161 2.206.202zm-.846 1.49c-.331-.187-.56-.17-.676-.12-.102.044-.237.167-.29.485-.052.32.003.768.24 1.242.236.472.576.815.9.998.332.188.561.172.677.121.101-.044.237-.167.29-.485.052-.32-.003-.768-.24-1.241-.236-.473-.576-.815-.9-1zM21.407 8.773c-.787-.38-1.627-.18-2.271.225-.65.41-1.206 1.08-1.57 1.886-.363.808-.497 1.672-.384 2.437.11.752.49 1.529 1.269 1.905.787.38 1.626.18 2.27-.226.65-.41 1.206-1.079 1.57-1.886.363-.807.497-1.671.384-2.436-.11-.753-.49-1.53-1.268-1.905zm-2.277 2.815c.247-.55.598-.936.92-1.139.327-.206.526-.174.611-.133.094.046.258.2.319.612.059.4-.006.934-.253 1.482-.247.55-.597.937-.92 1.14-.327.206-.525.173-.61.132-.095-.045-.259-.2-.32-.612-.058-.4.006-.934.253-1.482z"
  })));
}

var _path$A;

function _extends$D() {
  _extends$D = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$D.apply(this, arguments);
}

function SvgEmojiFoodIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$D({
    width: 24,
    height: 24,
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$A || (_path$A = /*#__PURE__*/createElement("path", {
    d: "M16.375 5.336c-1.608 0-2.517.346-3.22.817.449-1.026 1.547-2.567 4.095-2.567a.875.875 0 100-1.75c-2.556 0-4.05 1.194-4.854 2.198-.056.068-.104.141-.157.213C11.764 2.588 10.949 1 9.556 1c-.55 0-1.187.248-1.931.836-1.726 1.366-1.462 2.558-.444 3.518C4.658 5.549 1.5 7.413 1.5 12.328c0 4.009 4.34 9.633 7.875 9.633 1.728 0 2.075-.426 2.625-.875.55.45.897.875 2.625.875 3.534 0 7.875-5.616 7.875-9.625 0-5.21-3.548-7-6.125-7zM8.712 3.208c.56-.445.825-.458.844-.458.373.148.853 1.23 1.188 2.673-1.337-.55-2.399-1.183-2.608-1.615.052-.098.21-.312.576-.6zm5.913 17.003c-.945 0-1.059-.096-1.364-.352l-.154-.128a1.739 1.739 0 00-1.108-.395 1.74 1.74 0 00-1.108.395l-.154.128c-.303.255-.417.352-1.362.352-2.461 0-6.125-4.716-6.125-7.883 0-5.095 3.927-5.242 4.375-5.242 1.697 0 2.174.412 2.964 1.094l.282.242a1.745 1.745 0 002.258 0l.282-.242c.79-.682 1.267-1.094 2.964-1.094.448 0 4.375.147 4.375 5.25 0 3.165-3.664 7.875-6.125 7.875z"
  })));
}

var _path$B;

function _extends$E() {
  _extends$E = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$E.apply(this, arguments);
}

function SvgEmojiTravelIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$E({
    width: 24,
    height: 24,
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$B || (_path$B = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M9.61 3.6H14.39c1.117 0 1.89-.001 2.59.24a4.4 4.4 0 011.643 1.016c.529.518.874 1.209 1.374 2.209l.067.134.84 1.68h1.216a.88.88 0 01.88.88v.312c0 .82-.59 1.462-1.32 1.607v7.148c0 .093 0 .209-.008.312a1.28 1.28 0 01-.131.485c-.122.24-.318.435-.558.558-.187.095-.364.12-.485.13-.103.009-.219.009-.313.009h-.531c-.093 0-.21 0-.312-.009a1.284 1.284 0 01-.485-.13 1.275 1.275 0 01-.558-.558 1.284 1.284 0 01-.13-.485c-.01-.103-.009-.22-.009-.313v-.265H5.84v.266c0 .093 0 .209-.008.312-.01.12-.036.298-.131.485-.122.24-.318.435-.558.558-.187.095-.364.12-.485.13-.103.009-.219.009-.312.009h-.532c-.093 0-.21 0-.312-.009a1.284 1.284 0 01-.485-.13 1.276 1.276 0 01-.558-.558 1.282 1.282 0 01-.13-.485 3.969 3.969 0 01-.009-.313v-7.147A1.637 1.637 0 011 10.071V9.76a.88.88 0 01.88-.88h1.216l.84-1.68.067-.135c.5-1 .845-1.691 1.374-2.209A4.4 4.4 0 017.02 3.84c.7-.241 1.472-.24 2.59-.24zM4.095 16.363a9.285 9.285 0 01-.015-.682v-4.143c.063.011.14.025.234.04.283.044.715.102 1.336.158 1.243.113 3.25.224 6.35.224 3.1 0 5.107-.111 6.35-.224a20.77 20.77 0 001.336-.158c.094-.015.171-.029.234-.04v4.03c0 .384 0 .619-.015.795a1.126 1.126 0 01-.03.19.44.44 0 01-.199.2l-.003.002a1.126 1.126 0 01-.19.03c-.176.014-.41.015-.795.015H5.312c-.384 0-.62-.001-.795-.015a1.127 1.127 0 01-.19-.03.44.44 0 01-.202-.202 1.126 1.126 0 01-.03-.19zm15.32-6.524l-.925-1.852c-.594-1.188-.807-1.588-1.098-1.873a2.64 2.64 0 00-.987-.61c-.385-.133-.839-.144-2.166-.144H9.761c-1.328 0-1.781.011-2.166.144a2.64 2.64 0 00-.987.61c-.29.285-.504.685-1.098 1.873l-.926 1.852h.004c.24.038.633.09 1.222.144 1.177.107 3.13.217 6.19.217 3.06 0 5.013-.11 6.19-.217a19.01 19.01 0 001.226-.144zm-1.146 5.194a.88.88 0 10-.218-1.746l-1.76.22a.88.88 0 00.218 1.746l1.76-.22zM4.967 14.05a.88.88 0 00.764.982l1.76.22a.88.88 0 10.218-1.746l-1.76-.22a.88.88 0 00-.982.763z"
  })));
}

var _path$C;

function _extends$F() {
  _extends$F = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$F.apply(this, arguments);
}

function SvgEmojiObjectIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$F({
    width: 24,
    height: 24,
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$C || (_path$C = /*#__PURE__*/createElement("path", {
    d: "M10 16h1.19v-2.06a1.007 1.007 0 01-.16-.12L9.32 12.1a1 1 0 111.41-1.41l1.25 1.25 1.32-1.32a.97.97 0 011.38 0c.4.4.4 1.05 0 1.46L13 13.74a.998.998 0 01-.19.15V16H14v-.15a1.002 1.002 0 01.3-.73c2.71-2.58 3.71-4.17 3.71-6.27a5.93 5.93 0 00-6-5.85C8.69 3 6 5.63 6 8.85c0 2.1.98 3.66 3.7 6.26.19.18.3.45.3.72V16zm0 2v1a1 1 0 001 1h2a1 1 0 001-1v-1h-4zm-2-1.75c-2.85-2.77-4-4.7-4-7.4C4 4.51 7.6 1 12 1c4.42 0 8.01 3.51 8.01 7.85 0 2.7-1.17 4.66-4.01 7.42V19a3 3 0 01-3 3h-2a3 3 0 01-3-3v-2.75z"
  })));
}

var _path$D;

function _extends$G() {
  _extends$G = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$G.apply(this, arguments);
}

function SvgEmojiSymbolsIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$G({
    width: 24,
    height: 24,
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$D || (_path$D = /*#__PURE__*/createElement("path", {
    d: "M19.1 4a4.6 4.6 0 011.37.28A4.01 4.01 0 0123 7.9c.03 2.73.03 5.47 0 8.2a4.15 4.15 0 01-.98 2.52A4.02 4.02 0 0119.1 20c-4.73.06-9.47.06-14.2 0a4.572 4.572 0 01-1.37-.28A4.02 4.02 0 011 16.1c-.03-2.73-.03-5.47 0-8.2A4.01 4.01 0 014.9 4c4.73-.06 9.47-.06 14.2 0zM5 6a2.02 2.02 0 00-2 1.95c-.034 2.7-.034 5.4 0 8.1A2.02 2.02 0 004.95 18c4.7.06 9.4.06 14.1 0A2.02 2.02 0 0021 16.05c.034-2.7.034-5.4 0-8.1A2.02 2.02 0 0019.05 6C14.37 5.94 9.68 6 5 6zm2 7.88a1.12 1.12 0 110 2.24 1.12 1.12 0 010-2.24zm4 .03a1.1 1.1 0 110 2.19 1.1 1.1 0 010-2.2v.01zm6.44-3.8l.23-1.18c.06-.3.1-.46.27-.62.1-.1.25-.15.42-.15.18 0 .37.07.5.2.23.22.18.53.12.83l-.19.92h.2c.32 0 .45.01.58.08.19.1.31.3.31.56 0 .27-.12.46-.3.56-.14.07-.27.08-.59.08h-.45l-.26 1.27h.33c.32 0 .44.02.58.09.18.1.3.29.3.55 0 .27-.12.47-.3.56-.14.07-.26.08-.58.08h-.58l-.27 1.33c-.06.3-.1.46-.26.62a.6.6 0 01-.42.15.74.74 0 01-.5-.2c-.23-.22-.18-.53-.12-.83l.21-1.07h-1.3l-.27 1.33c-.06.3-.1.46-.27.62-.1.1-.25.15-.42.15a.74.74 0 01-.49-.2c-.24-.22-.18-.53-.12-.83l.2-1.07h-.2c-.31 0-.44 0-.57-.08-.19-.1-.31-.29-.31-.56 0-.26.12-.46.3-.55.14-.07.27-.09.59-.09h.45l.26-1.27h-.33c-.32 0-.44-.01-.58-.08-.18-.1-.3-.3-.3-.56 0-.27.12-.46.3-.56.14-.07.26-.08.58-.08h.58l.24-1.18c.06-.3.1-.46.27-.62.1-.1.25-.15.41-.15.18 0 .37.07.5.2.24.22.18.53.12.83l-.18.92h1.31zm-8.14-.2c0-1.33-1.05-2.18-2.36-2.18-.68 0-1.35.23-1.78.6-.45.4-.64 1-.64 1.34 0 .23.1.42.22.53.12.12.3.2.5.2.21 0 .36-.07.5-.18.34-.25.42-.63.55-.77a.85.85 0 01.66-.27c.55 0 .76.27.76.75 0 .3-.24.67-.43.89l-.65.83c-.28.4-.4.7-.38 1.03.02.36.28.67.57.7.24.02.6 0 .79-.38.13-.25.53-.73.73-1.07l.47-.62c.34-.43.49-.8.49-1.4zm2.54-1.17c0-.36-.01-.49-.11-.68-.13-.22-.4-.37-.73-.37-.33 0-.6.15-.73.37-.1.19-.11.32-.11.68v3.45c0 .36 0 .5.11.68.13.22.4.37.73.37.33 0 .6-.15.73-.37.1-.19.11-.32.11-.68V8.74zm5.09 3.92l.25-1.27h-1.3l-.26 1.27h1.31z"
  })));
}

var _path$E;

function _extends$H() {
  _extends$H = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$H.apply(this, arguments);
}

function SvgEmojiFlagicon(props) {
  return /*#__PURE__*/createElement("svg", _extends$H({
    width: 24,
    height: 24,
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$E || (_path$E = /*#__PURE__*/createElement("path", {
    d: "M6.63 3.23c2.13 1.12 3.18.99 5.4-.13l.03-.03c2.8-1.4 4.52-1.57 7.43.08a1 1 0 01.51.87v9.23a1 1 0 01-1.5.87c-2.69-1.52-4.13-1.43-6.62-.22-.33.158-.66.315-.99.47-1.4.62-2.6.81-3.89.43V20a1 1 0 11-2 0V4a1 1 0 011.63-.77zM7 12.66c1.05.5 1.87.42 3.08-.12.314-.137.624-.283.93-.44 2.56-1.24 4.46-1.53 6.99-.46V4.62c-1.9-.98-2.96-.81-5.03.24l-.04.02c-2.3 1.16-3.85 1.5-5.93.71v7.07z"
  })));
}

var EMOJIS = [{
  key: 'People',
  array: [{
    key: 'face-smiling',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'face-affection',
    array: ['', '', '', '', '', '', '']
  }, {
    key: 'face-tongue',
    array: ['', '', '', '', '', '']
  }, {
    key: 'face-hand',
    array: ['', '', '', '']
  }, {
    key: 'face-neutral-skeptical',
    array: ['', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'face-sleepy',
    array: ['', '', '', '', '']
  }, {
    key: 'face-unwell',
    array: ['', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'face-hat',
    array: ['', '']
  }, {
    key: 'face-glasses',
    array: ['', '', '']
  }, {
    key: 'face-concerned',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'face-negative',
    array: ['', '', '', '', '', '', '', '']
  }, {
    key: 'face-costume',
    array: ['', '', '', '', '', '', '', '']
  }, {
    key: 'cat-face',
    array: ['', '', '', '', '', '', '', '', '']
  }, {
    key: 'monkey-face',
    array: ['', '', '']
  }, {
    key: 'emotion',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'hand-fingers-open',
    array: ['', '', '', '', '']
  }, {
    key: 'hand-fingers-partial',
    array: ['', '', '', '', '', '', '']
  }, {
    key: 'hand-single-finger',
    array: ['', '', '', '', '', '']
  }, {
    key: 'hand-fingers-closed',
    array: ['', '', '', '', '', '']
  }, {
    key: 'hands',
    array: ['', '', '', '', '', '']
  }, {
    key: 'hand-prop',
    array: ['', '', '']
  }, {
    key: 'body-parts',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'person',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'person-fantasy',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'person-activity',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }]
}, {
  key: 'Animals',
  array: [{
    key: 'animal-mammal',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'animal-bird',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'animal-amphibian',
    array: ['']
  }, {
    key: 'animal-reptile',
    array: ['', '', '', '', '', '', '', '']
  }, {
    key: 'animal-marine',
    array: ['', '', '', '', '', '', '', '', '']
  }, {
    key: 'animal-bug',
    array: ['', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'plant-flower',
    array: ['', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'plant-other',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '']
  }]
}, {
  key: 'Food',
  array: [{
    key: 'food-fruit',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'food-vegetable',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'food-prepared',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'food-asian',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'food-marine',
    array: ['', '', '', '', '']
  }, {
    key: 'food-sweet',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'drink',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'dishware',
    array: ['', '', '', '', '', '', '']
  }]
}, {
  key: 'Travel',
  array: [{
    key: 'place-map',
    array: ['', '', '', '', '', '', '']
  }, {
    key: 'place-geographic',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'place-building',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'place-religious',
    array: ['', '', '', '', '', '']
  }, {
    key: 'place-other',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'transport-ground',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'transport-water',
    array: ['', '', '', '', '', '', '', '']
  }, {
    key: 'transport-air',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'hotel',
    array: ['', '']
  }, {
    key: 'time',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'sky weather',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }]
}, {
  key: 'Objects',
  array: [{
    key: 'event',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'award-medal',
    array: ['', '', '', '', '', '']
  }, {
    key: 'sport',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'game',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'arts crafts',
    array: ['', '', '', '', '']
  }, {
    key: 'clothing',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'sound',
    array: ['', '', '', '', '', '', '', '', '']
  }, {
    key: 'music',
    array: ['', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'musical-instrument',
    array: ['', '', '', '', '', '', '']
  }, {
    key: 'phone',
    array: ['', '', '', '', '', '', '']
  }, {
    key: 'computer',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'light video',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'book-paper',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'money',
    array: ['', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'mail',
    array: ['', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'writing',
    array: ['', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'office',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'lock',
    array: ['', '', '', '', '', '']
  }, {
    key: 'tool',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'science',
    array: ['', '', '', '', '', '', '', '']
  }, {
    key: 'medical',
    array: ['', '', '', '', '']
  }, {
    key: 'household',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'other-object',
    array: ['', '', '', '']
  }]
}, {
  key: 'Symbols',
  array: [{
    key: 'transport-sign',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'warning',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'arrow',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'religion',
    array: ['', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'zodiac',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'other-symbol',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }]
}, {
  key: 'Flags',
  array: [{
    key: 'country-flag',
    array: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
  }, {
    key: 'subdivision-flag',
    array: ['', '', '']
  }]
}];

var _templateObject$i, _templateObject2$g, _templateObject3$c, _templateObject4$9, _templateObject5$6, _templateObject6$6, _templateObject7$5, _templateObject8$4;

var EmojiIcon = function EmojiIcon(_ref) {
  var collectionName = _ref.collectionName;

  switch (collectionName) {
    case 'People':
      return React__default.createElement(SvgEmojiSmileIcon, null);

    case 'Animals':
      return React__default.createElement(SvgEmojiAnimalIcon, null);

    case 'Food':
      return React__default.createElement(SvgEmojiFoodIcon, null);

    case 'Travel':
      return React__default.createElement(SvgEmojiTravelIcon, null);

    case 'Objects':
      return React__default.createElement(SvgEmojiObjectIcon, null);

    case 'Symbols':
      return React__default.createElement(SvgEmojiSymbolsIcon, null);

    case 'Flags':
      return React__default.createElement(SvgEmojiFlagicon, null);

    default:
      return null;
  }
};

function EmojisPopup(_ref2) {
  var handleAddEmoji = _ref2.handleAddEmoji,
      handleEmojiPopupToggle = _ref2.handleEmojiPopupToggle,
      rtlDirection = _ref2.rtlDirection,
      rightSide = _ref2.rightSide;

  var _useState = useState('People'),
      activeCollection = _useState[0],
      setActiveCollection = _useState[1];

  var _useState2 = useState([]),
      collectionHeights = _useState2[0],
      setCollectionHeights = _useState2[1];

  var emojiContainerRef = useRef(null);
  var collectionsRef = useRef(EMOJIS.map(function (col) {
    return {
      collectionName: col.key,
      elem: createRef()
    };
  }));

  var handleEmojiListScroll = function handleEmojiListScroll() {
    var scrollPos = emojiContainerRef.current.scrollTop;

    if (collectionHeights[6] < scrollPos) {
      setActiveCollection('Flags');
    } else if (collectionHeights[5] < scrollPos) {
      setActiveCollection('Symbols');
    } else if (collectionHeights[4] < scrollPos) {
      setActiveCollection('Objects');
    } else if (collectionHeights[3] < scrollPos) {
      setActiveCollection('Travel');
    } else if (collectionHeights[2] < scrollPos) {
      setActiveCollection('Food');
    } else if (collectionHeights[1] < scrollPos) {
      setActiveCollection('Animals');
    } else {
      setActiveCollection('People');
    }
  };

  var chooseEmoji = function chooseEmoji(selectedEmoji) {
    handleAddEmoji(selectedEmoji);

    if (handleEmojiPopupToggle) {
      handleEmojiPopupToggle(false);
    }
  };

  var handleEmojiCollectionClick = function handleEmojiCollectionClick(mainCollection) {
    var collection = collectionsRef.current.find(function (el) {
      return el.collectionName === mainCollection;
    });
    var pos = collection.elem.current.offsetTop - 40;
    emojiContainerRef.current.scrollTo(0, pos);
  };

  useEffect(function () {
    var containerTop = emojiContainerRef.current.getBoundingClientRect().top + 10;
    var heights = collectionsRef.current.map(function (col) {
      return col.elem.current.getBoundingClientRect().top - containerTop;
    });
    setCollectionHeights(heights);
  }, []);
  return React__default.createElement(Container$a, {
    rightSide: rightSide,
    id: 'emojisContainer',
    rtlDirection: rtlDirection
  }, React__default.createElement(EmojiHeader, null, activeCollection), React__default.createElement(EmojiSection, {
    ref: emojiContainerRef,
    onScroll: handleEmojiListScroll
  }, React__default.createElement(AllEmojis, null, EMOJIS.map(function (emojiBigCollection, bigColIndex) {
    var mainCollectionKey = emojiBigCollection.key;
    return emojiBigCollection.array.map(function (emojiSmallCollection, bigIndex) {
      var label = emojiSmallCollection.key;
      var array = emojiSmallCollection.array;
      return array.map(function (emoji, i) {
        return React__default.createElement(Emoji, {
          key: "" + emoji,
          className: 'emoji-cont',
          onClick: function onClick() {
            return chooseEmoji(emoji);
          }
        }, bigIndex === 0 && i === 0 && React__default.createElement(CollectionPointer, {
          ref: collectionsRef.current[bigColIndex].elem,
          "data-emoji-sec": mainCollectionKey
        }), React__default.createElement("span", {
          className: 'emoji',
          role: 'img',
          "aria-label": label || '',
          "aria-hidden": label ? 'false' : 'true'
        }, emoji));
      });
    });
  }))), React__default.createElement(EmojiFooter, null, EMOJIS.map(function (emoji) {
    return React__default.createElement(EmojiCollection, {
      activeCollection: activeCollection === emoji.key,
      key: "" + emoji.key,
      onClick: function onClick() {
        return handleEmojiCollectionClick(emoji.key);
      }
    }, React__default.createElement(EmojiIcon, {
      collectionName: emoji.key
    }));
  })));
}
var Container$a = styled.div(_templateObject$i || (_templateObject$i = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  left: ", ";\n  right: ", ";\n  bottom: 46px;\n  width: 306px;\n  border: 1px solid ", ";\n  box-sizing: border-box;\n  box-shadow: 0 0 12px rgba(0, 0, 0, 0.08);\n  border-radius: 6px;\n  background: ", ";\n  z-index: 35;\n"])), function (props) {
  return props.rtlDirection ? '' : props.rightSide ? '-276px' : '0';
}, function (props) {
  return props.rtlDirection && '0';
}, colors.gray1, colors.white);
var EmojiHeader = styled.div(_templateObject2$g || (_templateObject2$g = _taggedTemplateLiteralLoose(["\n  height: 32px;\n  font-style: normal;\n  font-weight: 500;\n  font-size: 13px;\n  line-height: 18px;\n  color: ", ";\n  display: flex;\n  align-items: flex-end;\n  padding: 3px 18px;\n"])), colors.gray6);
var EmojiSection = styled.div(_templateObject3$c || (_templateObject3$c = _taggedTemplateLiteralLoose(["\n  height: 166px;\n  overflow-x: hidden;\n"])));
var EmojiCollection = styled.span(_templateObject4$9 || (_templateObject4$9 = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n  & > * {\n    color: ", ";\n  }\n"])), function (props) {
  return props.activeCollection ? colors.primary : colors.gray7;
});
var CollectionPointer = styled.span(_templateObject5$6 || (_templateObject5$6 = _taggedTemplateLiteralLoose([""])));
var AllEmojis = styled.ul(_templateObject6$6 || (_templateObject6$6 = _taggedTemplateLiteralLoose(["\n  overflow: hidden;\n  padding: 8px;\n  margin: 0;\n"])));
var EmojiFooter = styled.div(_templateObject7$5 || (_templateObject7$5 = _taggedTemplateLiteralLoose(["\n  height: 42px;\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  border-top: 1px solid ", ";\n  padding: 0 10px;\n  & > span {\n    width: 100%;\n    text-align: center;\n  }\n"])), colors.gray1);
var Emoji = styled.li(_templateObject8$4 || (_templateObject8$4 = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n  width: 32px;\n  height: 32px;\n  margin: 0 2px;\n  display: inline-block;\n  box-sizing: border-box;\n  border-radius: 50%;\n  padding-top: 2px;\n  text-align: center;\n  background: transparent;\n  & > * {\n    font-size: 22px;\n  }\n  &:hover {\n    background: #f5f5f8;\n  }\n"])));

function usePermissions(myRole) {
  var dispatch = useDispatch();
  var rolesMap = useSelector(rolesMapSelector, shallowEqual);
  var myPermissions = myRole && rolesMap[myRole] ? rolesMap[myRole].permissions : [];

  var checkActionPermission = function checkActionPermission(actionName) {
    return myPermissions.includes(actionName);
  };

  useEffect(function () {
    dispatch(getRolesAC());
  }, []);
  return [checkActionPermission, myPermissions];
}

var _templateObject$j, _templateObject2$h, _templateObject3$d, _templateObject4$a;
function MessageActions(_ref) {
  var editModeToggle = _ref.editModeToggle,
      channel = _ref.channel,
      handleResendMessage = _ref.handleResendMessage,
      handleOpenDeleteMessage = _ref.handleOpenDeleteMessage,
      handleDeletePendingMessage = _ref.handleDeletePendingMessage,
      handleOpenForwardMessage = _ref.handleOpenForwardMessage,
      handleCopyMessage = _ref.handleCopyMessage,
      handleReportMessage = _ref.handleReportMessage,
      messageStatus = _ref.messageStatus,
      handleAddEmoji = _ref.handleAddEmoji,
      handleReplyMessage = _ref.handleReplyMessage,
      isThreadMessage = _ref.isThreadMessage,
      rtlDirection = _ref.rtlDirection,
      showMessageReaction = _ref.showMessageReaction,
      showEditMessage = _ref.showEditMessage,
      showCopyMessage = _ref.showCopyMessage,
      showReplyMessage = _ref.showReplyMessage,
      showReplyMessageInThread = _ref.showReplyMessageInThread,
      showForwardMessage = _ref.showForwardMessage,
      showDeleteMessage = _ref.showDeleteMessage,
      showReportMessage = _ref.showReportMessage,
      reactionIcon = _ref.reactionIcon,
      editIcon = _ref.editIcon,
      copyIcon = _ref.copyIcon,
      replyIcon = _ref.replyIcon,
      replyInThreadIcon = _ref.replyInThreadIcon,
      deleteIcon = _ref.deleteIcon,
      allowEditDeleteIncomingMessage = _ref.allowEditDeleteIncomingMessage,
      reportIcon = _ref.reportIcon,
      reactionIconOrder = _ref.reactionIconOrder,
      editIconOrder = _ref.editIconOrder,
      copyIconOrder = _ref.copyIconOrder,
      replyIconOrder = _ref.replyIconOrder,
      replyInThreadIconOrder = _ref.replyInThreadIconOrder,
      forwardIcon = _ref.forwardIcon,
      forwardIconOrder = _ref.forwardIconOrder,
      deleteIconOrder = _ref.deleteIconOrder,
      reportIconOrder = _ref.reportIconOrder,
      reactionIconTooltipText = _ref.reactionIconTooltipText,
      editIconTooltipText = _ref.editIconTooltipText,
      copyIconTooltipText = _ref.copyIconTooltipText,
      replyIconTooltipText = _ref.replyIconTooltipText,
      replyInThreadIconTooltipText = _ref.replyInThreadIconTooltipText,
      forwardIconTooltipText = _ref.forwardIconTooltipText,
      deleteIconTooltipText = _ref.deleteIconTooltipText,
      reportIconTooltipText = _ref.reportIconTooltipText,
      myRole = _ref.myRole,
      isIncoming = _ref.isIncoming,
      messageActionIconsColor = _ref.messageActionIconsColor;

  var _useState = useState(false),
      reactionIsOpen = _useState[0],
      setReactionIsOpen = _useState[1];

  var emojisRef = useRef(null);

  var _usePermissions = usePermissions(myRole),
      checkActionPermission = _usePermissions[0];

  var isDirectChannel = channel.type === CHANNEL_TYPE.DIRECT;
  var editMessagePermitted = isIncoming ? checkActionPermission('editAnyMessage') : checkActionPermission('editOwnMessage');
  var replyMessagePermitted = isIncoming ? checkActionPermission('replyAnyMessage') : checkActionPermission('replyOwnMessage');
  var forwardMessagePermitted = checkActionPermission('forwardMessage');

  var handleClick = function handleClick(e) {
    if (emojisRef.current && !emojisRef.current.contains(e.target)) {
      setReactionIsOpen(false);
    }
  };

  useEffect(function () {
    document.addEventListener('mousedown', handleClick);
    return function () {
      document.removeEventListener('mousedown', handleClick);
    };
  }, []);
  return React__default.createElement(MessageActionsWrapper, {
    isThreadMessage: isThreadMessage,
    rtlDirection: rtlDirection
  }, React__default.createElement(EditMessageContainer, {
    className: 'message_actions_cont '
  }, showMessageReaction && checkActionPermission('addMessageReaction') && React__default.createElement(Action, {
    order: reactionIconOrder || 0,
    iconColor: messageActionIconsColor,
    hoverIconColor: colors.primary,
    onClick: function onClick() {
      return setReactionIsOpen(true);
    }
  }, React__default.createElement(ItemNote, {
    direction: 'top'
  }, reactionIconTooltipText || 'React'), reactionIcon || React__default.createElement(SvgReact, null)), showEditMessage && (isIncoming ? allowEditDeleteIncomingMessage : true) && editMessagePermitted && (isDirectChannel ? !isIncoming && channel.peer.activityState !== 'Deleted' : true) && React__default.createElement(Action, {
    order: editIconOrder || 1,
    iconColor: messageActionIconsColor,
    hoverIconColor: colors.primary,
    onClick: function onClick() {
      return editModeToggle();
    }
  }, React__default.createElement(ItemNote, {
    direction: 'top'
  }, editIconTooltipText || 'Edit Message'), editIcon || React__default.createElement(SvgEditSquare, null)), messageStatus === MESSAGE_DELIVERY_STATUS.PENDING && React__default.createElement(Action, {
    iconColor: messageActionIconsColor,
    hoverIconColor: colors.primary,
    onClick: function onClick() {
      return handleResendMessage();
    }
  }, React__default.createElement(ItemNote, {
    direction: 'top'
  }, " Resend Message "), React__default.createElement(SvgResend, null)), !isThreadMessage && React__default.createElement(React__default.Fragment, null, showReplyMessage && replyMessagePermitted && (isDirectChannel ? channel.peer.activityState !== 'Deleted' : true) && React__default.createElement(Action, {
    order: replyIconOrder || 2,
    iconColor: messageActionIconsColor,
    hoverIconColor: colors.primary,
    onClick: function onClick() {
      return handleReplyMessage();
    }
  }, React__default.createElement(ItemNote, {
    direction: 'top'
  }, replyIconTooltipText || 'Reply'), replyIcon || React__default.createElement(SvgReplyIcon, null)), showReplyMessageInThread && replyMessagePermitted && React__default.createElement(Action, {
    order: replyInThreadIconOrder || 3,
    iconColor: messageActionIconsColor,
    hoverIconColor: colors.primary,
    onClick: function onClick() {
      return handleReplyMessage(true);
    }
  }, React__default.createElement(ItemNote, {
    direction: 'top'
  }, replyInThreadIconTooltipText || 'Reply in thread'), replyInThreadIcon || React__default.createElement(SvgThreadReply, null))), showCopyMessage && React__default.createElement(Action, {
    order: copyIconOrder || 4,
    iconColor: messageActionIconsColor,
    hoverIconColor: colors.primary,
    onClick: function onClick() {
      return handleCopyMessage();
    }
  }, React__default.createElement(ItemNote, {
    direction: 'top'
  }, copyIconTooltipText || 'Copy'), copyIcon || React__default.createElement(SvgCopy, null)), showForwardMessage && forwardMessagePermitted && React__default.createElement(Action, {
    order: forwardIconOrder || 5,
    iconColor: messageActionIconsColor,
    hoverIconColor: colors.primary,
    onClick: function onClick() {
      return handleOpenForwardMessage();
    }
  }, React__default.createElement(ItemNote, {
    direction: 'top'
  }, forwardIconTooltipText || 'Forward Message'), forwardIcon || React__default.createElement(SvgForward, null)), showDeleteMessage && (channel.type === CHANNEL_TYPE.PUBLIC ? myRole === 'owner' || myRole === 'admin' : true) && React__default.createElement(Action, {
    order: deleteIconOrder || 6,
    iconColor: messageActionIconsColor,
    hoverIconColor: colors.primary,
    onClick: function onClick() {
      return messageStatus === MESSAGE_DELIVERY_STATUS.PENDING ? handleDeletePendingMessage() : handleOpenDeleteMessage();
    }
  }, React__default.createElement(ItemNote, {
    direction: 'top'
  }, deleteIconTooltipText || 'Delete Message'), deleteIcon || React__default.createElement(SvgTrash, null)), showReportMessage && React__default.createElement(Action, {
    order: reportIconOrder || 7,
    iconColor: messageActionIconsColor,
    hoverIconColor: colors.primary,
    onClick: function onClick() {
      return handleReportMessage();
    }
  }, React__default.createElement(ItemNote, {
    direction: 'top'
  }, reportIconTooltipText || 'Report'), reportIcon || React__default.createElement(SvgReportIcon, null)), React__default.createElement(EmojiContainer, {
    ref: emojisRef,
    rtlDirection: rtlDirection
  }, reactionIsOpen && React__default.createElement(EmojisPopup, {
    rtlDirection: rtlDirection,
    handleEmojiPopupToggle: setReactionIsOpen,
    handleAddEmoji: handleAddEmoji
  }))));
}
var MessageActionsWrapper = styled.div(_templateObject$j || (_templateObject$j = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  left: ", ";\n  right: ", ";\n  top: -46px;\n  padding: 0 0 8px;\n  z-index: 200;\n"])), function (_ref2) {
  var isThreadMessage = _ref2.isThreadMessage,
      rtlDirection = _ref2.rtlDirection;
  return !rtlDirection && (isThreadMessage ? '8px' : '0');
}, function (_ref3) {
  var rtlDirection = _ref3.rtlDirection;
  return rtlDirection && '0';
});
var EditMessageContainer = styled.div(_templateObject2$h || (_templateObject2$h = _taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  align-items: center;\n  direction: ", ";\n  background-color: #fff;\n  border: 1px solid ", ";\n  box-sizing: border-box;\n  border-radius: 4px;\n  box-shadow: 0 0 12px rgba(0, 0, 0, 0.08);\n  //opacity: 0;\n  //visibility: hidden;\n  transition: all 0.2s;\n  z-index: 100;\n"])), function (props) {
  return props.rtlDirection && 'initial';
}, colors.gray1);
var Action = styled.div(_templateObject3$d || (_templateObject3$d = _taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  padding: 9px;\n  cursor: pointer;\n  color: ", ";\n  transition: all 0.2s;\n  order: ", ";\n\n  &:hover {\n    color: ", ";\n\n    ", " {\n      display: block;\n    }\n  }\n"])), function (props) {
  return props.iconColor || colors.gray6;
}, function (props) {
  return props.order || 1;
}, function (props) {
  return props.hoverIconColor || colors.cobalt1;
}, ItemNote);
var EmojiContainer = styled.div(_templateObject4$a || (_templateObject4$a = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  left: ", ";\n  right: ", ";\n  bottom: -10px;\n  z-index: 99;\n"])), function (props) {
  return props.rtlDirection ? '' : '0';
}, function (props) {
  return props.rtlDirection && '0';
});

var _path$F;

function _extends$I() {
  _extends$I = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$I.apply(this, arguments);
}

function SvgCancel(props) {
  return /*#__PURE__*/createElement("svg", _extends$I({
    width: 24,
    height: 24,
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$F || (_path$F = /*#__PURE__*/createElement("path", {
    d: "M7.536 6.264a.9.9 0 00-1.272 1.272L10.727 12l-4.463 4.464a.9.9 0 001.272 1.272L12 13.273l4.464 4.463a.9.9 0 101.272-1.272L13.273 12l4.463-4.464a.9.9 0 10-1.272-1.272L12 10.727 7.536 6.264z",
    fill: "#fff"
  })));
}

var _path$G, _path2$6, _path3$3;

function _extends$J() {
  _extends$J = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$J.apply(this, arguments);
}

function SvgFileIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$J({
    width: 40,
    height: 40,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$G || (_path$G = /*#__PURE__*/createElement("path", {
    d: "M19.5 3H9a3 3 0 00-3 3v24a3 3 0 003 3h18a3 3 0 003-3V13.5L19.5 3z",
    stroke: "#2F81FF",
    strokeWidth: 1.4,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), _path2$6 || (_path2$6 = /*#__PURE__*/createElement("path", {
    d: "M19.5 3v10.5H30",
    stroke: "#2F81FF",
    strokeWidth: 1.4,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), _path3$3 || (_path3$3 = /*#__PURE__*/createElement("path", {
    d: "M12 19h12M12 23h8",
    stroke: "#2F81FF",
    strokeWidth: 1.4,
    strokeLinecap: "round"
  })));
}

var _circle, _path$H;

function _extends$K() {
  _extends$K = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$K.apply(this, arguments);
}

function SvgDeleteUpload(props) {
  return /*#__PURE__*/createElement("svg", _extends$K({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _circle || (_circle = /*#__PURE__*/createElement("circle", {
    cx: 10,
    cy: 10,
    r: 9.3,
    fill: "#A3A5B0",
    stroke: "#fff",
    strokeWidth: 1.4
  })), _path$H || (_path$H = /*#__PURE__*/createElement("path", {
    d: "M13.5 6.5l-7 7M6.5 6.5l7 7",
    stroke: "#fff",
    strokeWidth: 1.4,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })));
}

var _circle$1, _path$I;

function _extends$L() {
  _extends$L = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$L.apply(this, arguments);
}

function SvgDeleteFailed(props) {
  return /*#__PURE__*/createElement("svg", _extends$L({
    width: 18,
    height: 18,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _circle$1 || (_circle$1 = /*#__PURE__*/createElement("circle", {
    cx: 9,
    cy: 9,
    r: 8.5,
    fill: "#fff",
    stroke: "#ED4D60"
  })), _path$I || (_path$I = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M13.014 4.994a.634.634 0 00-.899 0L9 8.101 5.885 4.987a.634.634 0 10-.899.898l3.116 3.116-3.116 3.115a.634.634 0 10.899.898L9 9.9l3.115 3.115a.634.634 0 10.899-.898L9.898 9.001l3.116-3.116a.638.638 0 000-.891z",
    fill: "#ED4D60"
  })));
}

var _path$J;

function _extends$M() {
  _extends$M = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$M.apply(this, arguments);
}

function SvgUpload(props) {
  return /*#__PURE__*/createElement("svg", _extends$M({
    width: 32,
    height: 32,
    viewBox: "0 0 32.01 32.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$J || (_path$J = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M14.5 20.5a1.5 1.5 0 003 0V7.121l4.44 4.44a1.5 1.5 0 002.12-2.122l-7-7a1.5 1.5 0 00-2.12 0l-7 7a1.5 1.5 0 002.12 2.122l4.44-4.44V20.5zm-9 4.5a1.5 1.5 0 000 3h21a1.5 1.5 0 000-3h-21z",
    fill: "#fff"
  })));
}

var _path$K;

function _extends$N() {
  _extends$N = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$N.apply(this, arguments);
}

function SvgDownload(props) {
  return /*#__PURE__*/createElement("svg", _extends$N({
    width: 32,
    height: 32,
    viewBox: "0 0 32.01 32.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$K || (_path$K = /*#__PURE__*/createElement("path", {
    d: "M17.5 3.5a1.5 1.5 0 00-3 0v13.379l-4.44-4.44a1.5 1.5 0 00-2.12 2.122l7 7a1.5 1.5 0 002.12 0l7-7a1.5 1.5 0 00-2.12-2.122l-4.44 4.44V3.5zM5.5 25a1.5 1.5 0 000 3h21a1.5 1.5 0 000-3h-21z",
    fill: "#fff"
  })));
}

var _circle$2, _path$L;

function _extends$O() {
  _extends$O = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$O.apply(this, arguments);
}

function SvgPlayVideo(props) {
  return /*#__PURE__*/createElement("svg", _extends$O({
    width: 56,
    height: 56,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _circle$2 || (_circle$2 = /*#__PURE__*/createElement("circle", {
    cx: 28,
    cy: 28,
    r: 28,
    fill: "#17191C",
    fillOpacity: 0.4
  })), _path$L || (_path$L = /*#__PURE__*/createElement("path", {
    d: "M38.048 26.262c1.27.767 1.27 2.706 0 3.473l-13.224 7.996c-1.258.76-2.824-.202-2.824-1.737V20.003c0-1.535 1.566-2.498 2.824-1.737l13.224 7.996z",
    fill: "#fff"
  })));
}

var getFrame3 = function getFrame3(video, time) {
  try {
    var canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    var ctx = canvas.getContext('2d');

    if (time) {
      video.currentTime = time;
    }

    ctx.drawImage(video, 0, 0);
    return Promise.resolve(createImageThumbnail(null, canvas.toDataURL(), 10, 10));
  } catch (e) {
    return Promise.reject(e);
  }
};
var getFrame = function getFrame(videoSrc, time) {
  try {
    var video = document.createElement('video');
    video.src = videoSrc;
    return Promise.resolve(new Promise(function (resolve, reject) {
      if (videoSrc) {
        var b = setInterval(function () {
          if (video.readyState >= 3) {
            if (time) {
              video.currentTime = time;
            }

            var canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            var ctx = canvas.getContext('2d');
            video.currentTime = 10;
            ctx.drawImage(video, 0, 0);
            console.log('canvas.toDataURL() resized ... ', canvas.toDataURL('', 0.7));
            var thumb = canvas.toDataURL('', 0.7).replace('data:image/jpeg;base64,', '');
            clearInterval(b);
            resolve({
              thumb: thumb,
              width: video.videoWidth,
              height: video.videoHeight
            });
          }
        }, 500);
      } else {
        reject(new Error('src not found'));
      }
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var ATTACHMENTS_CACHE = 'attachments-cache';
var cacheAvailable = ('caches' in self);
var setAttachmentToCache = function setAttachmentToCache(attachmentId, attachmentResponse) {
  if (cacheAvailable) {
    caches.open(ATTACHMENTS_CACHE).then(function (cache) {
      try {
        cache.put(attachmentId, attachmentResponse).then(function () {
          console.log('Cache success');
        })["catch"](function (e) {
          console.log('Error on cache attachment ... ', e);
        });
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    });
  }
};
var getAttachmentUrlFromCache = function getAttachmentUrlFromCache(attachmentId) {
  if (cacheAvailable) {
    return caches.match(attachmentId).then(function (response) {
      try {
        if (response) {
          return Promise.resolve(response.blob()).then(URL.createObjectURL);
        } else {
          console.log('The image or video is not cached', response);
          return Promise.resolve(false);
        }
      } catch (e) {
        return Promise.reject(e);
      }
    });
  } else {
    return new Promise(function (_resolve, reject) {
      return reject(new Error('Cache not available'));
    });
  }
};

var _templateObject$k, _templateObject2$i, _templateObject3$e, _templateObject4$b, _templateObject5$7, _templateObject6$7, _templateObject7$6;

var VideoPreview = function VideoPreview(_ref) {
  var maxWidth = _ref.maxWidth,
      maxHeight = _ref.maxHeight,
      src = _ref.src,
      file = _ref.file,
      borderRadius = _ref.borderRadius,
      isPreview = _ref.isPreview,
      uploading = _ref.uploading,
      isRepliedMessage = _ref.isRepliedMessage,
      backgroundColor = _ref.backgroundColor,
      isDetailsView = _ref.isDetailsView,
      setVideoIsReadyToSend = _ref.setVideoIsReadyToSend;

  var _useState = useState(false),
      videoPlaying = _useState[0],
      setVideoPlaying = _useState[1];

  var _useState2 = useState(0),
      videoDuration = _useState2[0],
      setVideoDuration = _useState2[1];

  var _useState3 = useState(null),
      videoCurrentTime = _useState3[0],
      setVideoCurrentTime = _useState3[1];

  var _useState4 = useState(true),
      loading = _useState4[0],
      setLoading = _useState4[1];

  var _useState5 = useState(false),
      isCached = _useState5[0],
      setIsCached = _useState5[1];

  var _useState6 = useState(false),
      downloadIsCancelled = _useState6[0],
      setDownloadIsCancelled = _useState6[1];

  var videoRef = useRef(null);

  var handlePauseResumeDownload = function handlePauseResumeDownload(e) {
    e.stopPropagation();

    if (downloadIsCancelled) {
      setDownloadIsCancelled(false);

      if (videoRef.current) {
        videoRef.current.src = src;
      }
    } else {
      setDownloadIsCancelled(true);

      if (videoRef.current) {
        videoRef.current.src = '';
      }
    }
  };

  useEffect(function () {
    var checkVideoInterval;

    if (videoRef.current) {
      if (videoPlaying) {
        checkVideoInterval = setInterval(function () {
          if (videoRef.current && videoRef.current.readyState > 0) {
            var minutes = Math.floor((videoDuration - videoRef.current.currentTime) / 60);
            var seconds = Math.floor((videoDuration - videoRef.current.currentTime) % 60);
            setVideoCurrentTime(minutes + ":" + (seconds < 10 ? "0" + seconds : seconds));

            if (videoRef.current.currentTime >= videoDuration) {
              setVideoPlaying(false);

              var _minutes = Math.floor(videoDuration / 60);

              var _seconds = Math.floor(videoDuration % 60);

              setVideoCurrentTime(_minutes + ":" + (_seconds < 10 ? "0" + _seconds : _seconds));
            }
          }
        }, 500);
        videoRef.current.play();
      } else {
        clearInterval(checkVideoInterval);
        videoRef.current.pause();
      }
    }

    return function () {
      return clearInterval(checkVideoInterval);
    };
  }, [videoPlaying]);
  useEffect(function () {
    var checkVideoInterval;

    if (videoRef.current) {
      checkVideoInterval = setInterval(function () {
        try {
          var _temp4 = function () {
            if (videoRef.current && videoRef.current.readyState > 3) {
              var _temp5 = function _temp5() {
                clearInterval(checkVideoInterval);
              };

              videoRef.current.currentTime = 2;
              setLoading(false);
              setVideoDuration(videoRef.current.duration);
              var minutes = Math.floor(videoRef.current.duration / 60);
              var seconds = Math.floor(videoRef.current.duration % 60);
              setVideoCurrentTime(minutes + ":" + (seconds < 10 ? "0" + seconds : seconds));

              var _temp6 = function () {
                if (isPreview) {
                  return Promise.resolve(getFrame3(videoRef.current, 1)).then(function (thumb) {
                    if (thumb) {
                      setVideoThumb(file.attachmentId, _extends({}, thumb, {
                        duration: videoRef.current.duration
                      }));

                      if (setVideoIsReadyToSend) {
                        setVideoIsReadyToSend(file.attachmentId);
                      }
                    }
                  });
                }
              }();

              return _temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6);
            }
          }();

          return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function () {}) : void 0);
        } catch (e) {
          return Promise.reject(e);
        }
      }, 1000);
    }

    if (downloadIsCancelled) {
      clearInterval(checkVideoInterval);
    }

    return function () {
      return clearInterval(checkVideoInterval);
    };
  }, [downloadIsCancelled]);
  useEffect(function () {
    getAttachmentUrlFromCache(file.id).then(function (cachedUrl) {
      if (cachedUrl) {
        setIsCached(true);
      }
    });
  }, []);
  return React__default.createElement(Component, {
    maxWidth: maxWidth,
    maxHeight: maxHeight,
    borderRadius: borderRadius,
    isRepliedMessage: isRepliedMessage,
    isPreview: isPreview,
    backgroundColor: backgroundColor,
    isDetailsView: isDetailsView
  }, !isPreview && loading && !uploading && React__default.createElement(UploadProgress, {
    isDetailsView: isDetailsView,
    onClick: handlePauseResumeDownload,
    isRepliedMessage: isRepliedMessage,
    borderRadius: borderRadius,
    backgroundImage: file.metadata && file.metadata.tmb && !isCached ? file.metadata.tmb : ''
  }, React__default.createElement(UploadPercent, {
    isRepliedMessage: isRepliedMessage
  }, downloadIsCancelled ? React__default.createElement(SvgDownload, null) : React__default.createElement(SvgCancel, null)), !downloadIsCancelled && React__default.createElement(UploadingIcon, {
    isRepliedMessage: isRepliedMessage,
    className: 'rotate_cont'
  })), React__default.createElement("video", {
    draggable: false,
    ref: videoRef,
    preload: 'auto',
    id: 'video',
    src: file.attachmentUrl || src || file.url,
    onPause: function onPause() {
      return setVideoPlaying(false);
    },
    onPlay: function onPlay() {
      return setVideoPlaying(true);
    }
  }, React__default.createElement("source", {
    src: src || file.url,
    type: "video/" + getFileExtension(file.name || file.data.name)
  }), React__default.createElement("source", {
    src: src || file.url,
    type: 'video/ogg'
  }), "Your browser does not support the video tag."), videoCurrentTime && React__default.createElement(VideoControls, null, !isPreview && !!videoDuration && !isRepliedMessage && !uploading && !isDetailsView && React__default.createElement(VideoPlayButton, {
    showOnHover: videoPlaying
  }, React__default.createElement(SvgPlayVideo, null)), React__default.createElement(VideoTime, {
    isDetailsView: isDetailsView,
    isRepliedMessage: isPreview || isRepliedMessage
  }, !isRepliedMessage && !isPreview && React__default.createElement(SvgVideoCall, null), videoCurrentTime)));
};
var VideoControls = styled.div(_templateObject$k || (_templateObject$k = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n"])));
var VideoTime = styled.div(_templateObject2$i || (_templateObject2$i = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  top: ", ";\n  bottom: ", ";\n  left: ", ";\n  font-size: ", ";\n  display: flex;\n  align-items: center;\n  border-radius: 16px;\n  padding: ", ";\n  background-color: rgba(1, 1, 1, 0.3);\n  line-height: 14px;\n  color: ", ";\n\n  & > svg {\n    color: ", ";\n    margin-right: 4px;\n  }\n"])), function (props) {
  return props.isRepliedMessage ? '3px' : props.isDetailsView ? undefined : '8px';
}, function (props) {
  return props.isDetailsView ? '8px' : undefined;
}, function (props) {
  return props.isRepliedMessage ? '3px' : '8px';
}, function (props) {
  return props.isRepliedMessage ? '10px' : '12px';
}, function (props) {
  return props.isRepliedMessage ? '0 3px' : '4px 6px';
}, colors.white, colors.white);
var VideoPlayButton = styled.div(_templateObject3$e || (_templateObject3$e = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n  visibility: ", ";\n"])), function (props) {
  return props.showOnHover && 'hidden';
});
var Component = styled.div(_templateObject4$b || (_templateObject4$b = _taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  max-width: ", ";\n  max-height: ", ";\n  width: ", ";\n  height: ", ";\n\n  ", ";\n  /*width: 100vw;\n  background-color: transparent;\n  margin-top: -50vw;\n  padding: 0 40px;\n  z-index: 20;*/\n\n  & > video {\n    max-width: ", ";\n    max-height: ", ";\n    width: ", ";\n    height: ", ";\n    border: ", ";\n    object-fit: cover;\n    box-sizing: border-box;\n    border-radius: ", ";\n  }\n\n  &:hover {\n    & ", " {\n      visibility: visible;\n    }\n  }\n"])), function (props) {
  return props.maxWidth || '100%';
}, function (props) {
  return props.maxHeight || '100%';
}, function (props) {
  return props.maxWidth;
}, function (props) {
  return props.maxHeight;
}, function (props) {
  return props.isRepliedMessage && 'margin-right: 8px';
}, function (props) {
  return props.maxWidth || '100%';
}, function (props) {
  return props.maxHeight || '100%';
}, function (props) {
  return props.maxWidth;
}, function (props) {
  return props.maxHeight;
}, function (props) {
  return !props.isPreview && props.isRepliedMessage ? '0.5px solid rgba(0, 0, 0, 0.1)' : !props.isDetailsView && "2px solid " + props.backgroundColor;
}, function (props) {
  return props.borderRadius ? props.borderRadius : props.isRepliedMessage ? '4px' : '8px';
}, VideoPlayButton);
var DownloadFile = styled.a(_templateObject5$7 || (_templateObject5$7 = _taggedTemplateLiteralLoose(["\n  visibility: hidden;\n  opacity: 0;\n  margin-left: auto;\n  cursor: pointer;\n  transition: all 0.1s;\n"])));
var AttachmentFile = styled.div(_templateObject6$7 || (_templateObject6$7 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  position: relative;\n  align-items: center;\n  padding: 6px 12px;\n  width: 350px;\n  height: 70px;\n  background: ", ";\n  border: ", ";\n  box-sizing: border-box;\n  margin-right: ", ";\n  margin-top: ", ";\n  border-radius: ", ";\n\n  &:hover ", " {\n    visibility: visible;\n    opacity: 1;\n  }\n\n  & > ", " svg {\n    width: 36px;\n    height: 36px;\n  }\n"])), function (props) {
  return props.background || '#ffffff';
}, function (props) {
  return props.border || "1px solid " + colors.gray1;
}, function (props) {
  return props.isPrevious && '16px';
}, function (props) {
  return !props.isPrevious && '8px';
}, function (props) {
  return props.borderRadius || '6px';
}, DownloadFile, AttachmentIconCont);
var AttachmentImg = styled.img(_templateObject7$6 || (_templateObject7$6 = _taggedTemplateLiteralLoose(["\n  width: 100%;\n  border-radius: ", ";\n  object-fit: cover;\n"])), function (props) {
  return props.borderRadius || '6px';
});

var wavesurfer = createCommonjsModule(function (module, exports) {
/*!
 * wavesurfer.js 6.4.0 (2022-11-05)
 * https://wavesurfer-js.org
 * @license BSD-3-Clause
 */
(function webpackUniversalModuleDefinition(root, factory) {
	module.exports = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/drawer.canvasentry.js":
/*!***********************************!*\
  !*** ./src/drawer.canvasentry.js ***!
  \***********************************/
/***/ ((module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _style = _interopRequireDefault(__webpack_require__(/*! ./util/style */ "./src/util/style.js"));
var _getId = _interopRequireDefault(__webpack_require__(/*! ./util/get-id */ "./src/util/get-id.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
/**
 * The `CanvasEntry` class represents an element consisting of a wave `canvas`
 * and an (optional) progress wave `canvas`.
 *
 * The `MultiCanvas` renderer uses one or more `CanvasEntry` instances to
 * render a waveform, depending on the zoom level.
 */
var CanvasEntry = /*#__PURE__*/function () {
  function CanvasEntry() {
    _classCallCheck(this, CanvasEntry);
    /**
     * The wave node
     *
     * @type {HTMLCanvasElement}
     */
    this.wave = null;
    /**
     * The wave canvas rendering context
     *
     * @type {CanvasRenderingContext2D}
     */
    this.waveCtx = null;
    /**
     * The (optional) progress wave node
     *
     * @type {HTMLCanvasElement}
     */
    this.progress = null;
    /**
     * The (optional) progress wave canvas rendering context
     *
     * @type {CanvasRenderingContext2D}
     */
    this.progressCtx = null;
    /**
     * Start of the area the canvas should render, between 0 and 1
     *
     * @type {number}
     */
    this.start = 0;
    /**
     * End of the area the canvas should render, between 0 and 1
     *
     * @type {number}
     */
    this.end = 1;
    /**
     * Unique identifier for this entry
     *
     * @type {string}
     */
    this.id = (0, _getId.default)(typeof this.constructor.name !== 'undefined' ? this.constructor.name.toLowerCase() + '_' : 'canvasentry_');
    /**
     * Canvas 2d context attributes
     *
     * @type {object}
     */
    this.canvasContextAttributes = {};
  }

  /**
   * Store the wave canvas element and create the 2D rendering context
   *
   * @param {HTMLCanvasElement} element The wave `canvas` element.
   */
  _createClass(CanvasEntry, [{
    key: "initWave",
    value: function initWave(element) {
      this.wave = element;
      this.waveCtx = this.wave.getContext('2d', this.canvasContextAttributes);
    }

    /**
     * Store the progress wave canvas element and create the 2D rendering
     * context
     *
     * @param {HTMLCanvasElement} element The progress wave `canvas` element.
     */
  }, {
    key: "initProgress",
    value: function initProgress(element) {
      this.progress = element;
      this.progressCtx = this.progress.getContext('2d', this.canvasContextAttributes);
    }

    /**
     * Update the dimensions
     *
     * @param {number} elementWidth Width of the entry
     * @param {number} totalWidth Total width of the multi canvas renderer
     * @param {number} width The new width of the element
     * @param {number} height The new height of the element
     */
  }, {
    key: "updateDimensions",
    value: function updateDimensions(elementWidth, totalWidth, width, height) {
      // where the canvas starts and ends in the waveform, represented as a
      // decimal between 0 and 1
      this.start = this.wave.offsetLeft / totalWidth || 0;
      this.end = this.start + elementWidth / totalWidth;

      // set wave canvas dimensions
      this.wave.width = width;
      this.wave.height = height;
      var elementSize = {
        width: elementWidth + 'px'
      };
      (0, _style.default)(this.wave, elementSize);
      if (this.hasProgressCanvas) {
        // set progress canvas dimensions
        this.progress.width = width;
        this.progress.height = height;
        (0, _style.default)(this.progress, elementSize);
      }
    }

    /**
     * Clear the wave and progress rendering contexts
     */
  }, {
    key: "clearWave",
    value: function clearWave() {
      // wave
      this.waveCtx.clearRect(0, 0, this.waveCtx.canvas.width, this.waveCtx.canvas.height);

      // progress
      if (this.hasProgressCanvas) {
        this.progressCtx.clearRect(0, 0, this.progressCtx.canvas.width, this.progressCtx.canvas.height);
      }
    }

    /**
     * Set the fill styles for wave and progress
     * @param {string|string[]} waveColor Fill color for the wave canvas,
     * or an array of colors to apply as a gradient
     * @param {?string|string[]} progressColor Fill color for the progress canvas,
     * or an array of colors to apply as a gradient
     */
  }, {
    key: "setFillStyles",
    value: function setFillStyles(waveColor, progressColor) {
      this.waveCtx.fillStyle = this.getFillStyle(this.waveCtx, waveColor);
      if (this.hasProgressCanvas) {
        this.progressCtx.fillStyle = this.getFillStyle(this.progressCtx, progressColor);
      }
    }

    /**
     * Utility function to handle wave color arguments
     *
     * When the color argument type is a string or CanvasGradient instance,
     * it will be returned as is. Otherwise, it will be treated as an array,
     * and a new CanvasGradient will be returned
     *
     * @since 6.0.0
     * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
     * @param {string|string[]|CanvasGradient} color Either a single fill color
     *     for the wave canvas, an existing CanvasGradient instance, or an array
     *     of colors to apply as a gradient
     * @returns {string|CanvasGradient} Returns a string fillstyle value, or a
     *     canvas gradient
     */
  }, {
    key: "getFillStyle",
    value: function getFillStyle(ctx, color) {
      if (typeof color == 'string' || color instanceof CanvasGradient) {
        return color;
      }
      var waveGradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
      color.forEach(function (value, index) {
        return waveGradient.addColorStop(index / color.length, value);
      });
      return waveGradient;
    }

    /**
     * Set the canvas transforms for wave and progress
     *
     * @param {boolean} vertical Whether to render vertically
     */
  }, {
    key: "applyCanvasTransforms",
    value: function applyCanvasTransforms(vertical) {
      if (vertical) {
        // Reflect the waveform across the line y = -x
        this.waveCtx.setTransform(0, 1, 1, 0, 0, 0);
        if (this.hasProgressCanvas) {
          this.progressCtx.setTransform(0, 1, 1, 0, 0, 0);
        }
      }
    }

    /**
     * Draw a rectangle for wave and progress
     *
     * @param {number} x X start position
     * @param {number} y Y start position
     * @param {number} width Width of the rectangle
     * @param {number} height Height of the rectangle
     * @param {number} radius Radius of the rectangle
     */
  }, {
    key: "fillRects",
    value: function fillRects(x, y, width, height, radius) {
      this.fillRectToContext(this.waveCtx, x, y, width, height, radius);
      if (this.hasProgressCanvas) {
        this.fillRectToContext(this.progressCtx, x, y, width, height, radius);
      }
    }

    /**
     * Draw the actual rectangle on a `canvas` element
     *
     * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
     * @param {number} x X start position
     * @param {number} y Y start position
     * @param {number} width Width of the rectangle
     * @param {number} height Height of the rectangle
     * @param {number} radius Radius of the rectangle
     */
  }, {
    key: "fillRectToContext",
    value: function fillRectToContext(ctx, x, y, width, height, radius) {
      if (!ctx) {
        return;
      }
      if (radius) {
        this.drawRoundedRect(ctx, x, y, width, height, radius);
      } else {
        ctx.fillRect(x, y, width, height);
      }
    }

    /**
     * Draw a rounded rectangle on Canvas
     *
     * @param {CanvasRenderingContext2D} ctx Canvas context
     * @param {number} x X-position of the rectangle
     * @param {number} y Y-position of the rectangle
     * @param {number} width Width of the rectangle
     * @param {number} height Height of the rectangle
     * @param {number} radius Radius of the rectangle
     *
     * @return {void}
     * @example drawRoundedRect(ctx, 50, 50, 5, 10, 3)
     */
  }, {
    key: "drawRoundedRect",
    value: function drawRoundedRect(ctx, x, y, width, height, radius) {
      if (height === 0) {
        return;
      }
      // peaks are float values from -1 to 1. Use absolute height values in
      // order to correctly calculate rounded rectangle coordinates
      if (height < 0) {
        height *= -1;
        y -= height;
      }
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }

    /**
     * Render the actual wave and progress lines
     *
     * @param {number[]} peaks Array with peaks data
     * @param {number} absmax Maximum peak value (absolute)
     * @param {number} halfH Half the height of the waveform
     * @param {number} offsetY Offset to the top
     * @param {number} start The x-offset of the beginning of the area that
     * should be rendered
     * @param {number} end The x-offset of the end of the area that
     * should be rendered
     */
  }, {
    key: "drawLines",
    value: function drawLines(peaks, absmax, halfH, offsetY, start, end) {
      this.drawLineToContext(this.waveCtx, peaks, absmax, halfH, offsetY, start, end);
      if (this.hasProgressCanvas) {
        this.drawLineToContext(this.progressCtx, peaks, absmax, halfH, offsetY, start, end);
      }
    }

    /**
     * Render the actual waveform line on a `canvas` element
     *
     * @param {CanvasRenderingContext2D} ctx Rendering context of target canvas
     * @param {number[]} peaks Array with peaks data
     * @param {number} absmax Maximum peak value (absolute)
     * @param {number} halfH Half the height of the waveform
     * @param {number} offsetY Offset to the top
     * @param {number} start The x-offset of the beginning of the area that
     * should be rendered
     * @param {number} end The x-offset of the end of the area that
     * should be rendered
     */
  }, {
    key: "drawLineToContext",
    value: function drawLineToContext(ctx, peaks, absmax, halfH, offsetY, start, end) {
      if (!ctx) {
        return;
      }
      var length = peaks.length / 2;
      var first = Math.round(length * this.start);

      // use one more peak value to make sure we join peaks at ends -- unless,
      // of course, this is the last canvas
      var last = Math.round(length * this.end) + 1;
      var canvasStart = first;
      var canvasEnd = last;
      var scale = this.wave.width / (canvasEnd - canvasStart - 1);

      // optimization
      var halfOffset = halfH + offsetY;
      var absmaxHalf = absmax / halfH;
      ctx.beginPath();
      ctx.moveTo((canvasStart - first) * scale, halfOffset);
      ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart] || 0) / absmaxHalf));
      var i, peak, h;
      for (i = canvasStart; i < canvasEnd; i++) {
        peak = peaks[2 * i] || 0;
        h = Math.round(peak / absmaxHalf);
        ctx.lineTo((i - first) * scale + this.halfPixel, halfOffset - h);
      }

      // draw the bottom edge going backwards, to make a single
      // closed hull to fill
      var j = canvasEnd - 1;
      for (j; j >= canvasStart; j--) {
        peak = peaks[2 * j + 1] || 0;
        h = Math.round(peak / absmaxHalf);
        ctx.lineTo((j - first) * scale + this.halfPixel, halfOffset - h);
      }
      ctx.lineTo((canvasStart - first) * scale, halfOffset - Math.round((peaks[2 * canvasStart + 1] || 0) / absmaxHalf));
      ctx.closePath();
      ctx.fill();
    }

    /**
     * Destroys this entry
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.waveCtx = null;
      this.wave = null;
      this.progressCtx = null;
      this.progress = null;
    }

    /**
     * Return image data of the wave `canvas` element
     *
     * When using a `type` of `'blob'`, this will return a `Promise` that
     * resolves with a `Blob` instance.
     *
     * @param {string} format='image/png' An optional value of a format type.
     * @param {number} quality=0.92 An optional value between 0 and 1.
     * @param {string} type='dataURL' Either 'dataURL' or 'blob'.
     * @return {string|Promise} When using the default `'dataURL'` `type` this
     * returns a data URL. When using the `'blob'` `type` this returns a
     * `Promise` that resolves with a `Blob` instance.
     */
  }, {
    key: "getImage",
    value: function getImage(format, quality, type) {
      var _this = this;
      if (type === 'blob') {
        return new Promise(function (resolve) {
          _this.wave.toBlob(resolve, format, quality);
        });
      } else if (type === 'dataURL') {
        return this.wave.toDataURL(format, quality);
      }
    }
  }]);
  return CanvasEntry;
}();
exports["default"] = CanvasEntry;
module.exports = exports.default;

/***/ }),

/***/ "./src/drawer.js":
/*!***********************!*\
  !*** ./src/drawer.js ***!
  \***********************/
/***/ ((module, exports, __webpack_require__) => {


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
/**
 * Parent class for renderers
 *
 * @extends {Observer}
 */
var Drawer = /*#__PURE__*/function (_util$Observer) {
  _inherits(Drawer, _util$Observer);
  var _super = _createSuper(Drawer);
  /**
   * @param {HTMLElement} container The container node of the wavesurfer instance
   * @param {WavesurferParams} params The wavesurfer initialisation options
   */
  function Drawer(container, params) {
    var _this;
    _classCallCheck(this, Drawer);
    _this = _super.call(this);
    _this.container = util.withOrientation(container, params.vertical);
    /**
     * @type {WavesurferParams}
     */
    _this.params = params;
    /**
     * The width of the renderer
     * @type {number}
     */
    _this.width = 0;
    /**
     * The height of the renderer
     * @type {number}
     */
    _this.height = params.height * _this.params.pixelRatio;
    _this.lastPos = 0;
    /**
     * The `<wave>` element which is added to the container
     * @type {HTMLElement}
     */
    _this.wrapper = null;
    return _this;
  }

  /**
   * Alias of `util.style`
   *
   * @param {HTMLElement} el The element that the styles will be applied to
   * @param {Object} styles The map of propName: attribute, both are used as-is
   * @return {HTMLElement} el
   */
  _createClass(Drawer, [{
    key: "style",
    value: function style(el, styles) {
      return util.style(el, styles);
    }

    /**
     * Create the wrapper `<wave>` element, style it and set up the events for
     * interaction
     */
  }, {
    key: "createWrapper",
    value: function createWrapper() {
      this.wrapper = util.withOrientation(this.container.appendChild(document.createElement('wave')), this.params.vertical);
      this.style(this.wrapper, {
        display: 'block',
        position: 'relative',
        userSelect: 'none',
        webkitUserSelect: 'none',
        height: this.params.height + 'px'
      });
      if (this.params.fillParent || this.params.scrollParent) {
        this.style(this.wrapper, {
          width: '100%',
          cursor: this.params.hideCursor ? 'none' : 'auto',
          overflowX: this.params.hideScrollbar ? 'hidden' : 'auto',
          overflowY: 'hidden'
        });
      }
      this.setupWrapperEvents();
    }

    /**
     * Handle click event
     *
     * @param {Event} e Click event
     * @param {?boolean} noPrevent Set to true to not call `e.preventDefault()`
     * @return {number} Playback position from 0 to 1
     */
  }, {
    key: "handleEvent",
    value: function handleEvent(e, noPrevent) {
      !noPrevent && e.preventDefault();
      var clientX = util.withOrientation(e.targetTouches ? e.targetTouches[0] : e, this.params.vertical).clientX;
      var bbox = this.wrapper.getBoundingClientRect();
      var nominalWidth = this.width;
      var parentWidth = this.getWidth();
      var progressPixels = this.getProgressPixels(bbox, clientX);
      var progress;
      if (!this.params.fillParent && nominalWidth < parentWidth) {
        progress = progressPixels * (this.params.pixelRatio / nominalWidth) || 0;
      } else {
        progress = (progressPixels + this.wrapper.scrollLeft) / this.wrapper.scrollWidth || 0;
      }
      return util.clamp(progress, 0, 1);
    }
  }, {
    key: "getProgressPixels",
    value: function getProgressPixels(wrapperBbox, clientX) {
      if (this.params.rtl) {
        return wrapperBbox.right - clientX;
      } else {
        return clientX - wrapperBbox.left;
      }
    }
  }, {
    key: "setupWrapperEvents",
    value: function setupWrapperEvents() {
      var _this2 = this;
      this.wrapper.addEventListener('click', function (e) {
        var orientedEvent = util.withOrientation(e, _this2.params.vertical);
        var scrollbarHeight = _this2.wrapper.offsetHeight - _this2.wrapper.clientHeight;
        if (scrollbarHeight !== 0) {
          // scrollbar is visible.  Check if click was on it
          var bbox = _this2.wrapper.getBoundingClientRect();
          if (orientedEvent.clientY >= bbox.bottom - scrollbarHeight) {
            // ignore mousedown as it was on the scrollbar
            return;
          }
        }
        if (_this2.params.interact) {
          _this2.fireEvent('click', e, _this2.handleEvent(e));
        }
      });
      this.wrapper.addEventListener('dblclick', function (e) {
        if (_this2.params.interact) {
          _this2.fireEvent('dblclick', e, _this2.handleEvent(e));
        }
      });
      this.wrapper.addEventListener('scroll', function (e) {
        return _this2.fireEvent('scroll', e);
      });
    }

    /**
     * Draw peaks on the canvas
     *
     * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
     * for split channel rendering
     * @param {number} length The width of the area that should be drawn
     * @param {number} start The x-offset of the beginning of the area that
     * should be rendered
     * @param {number} end The x-offset of the end of the area that should be
     * rendered
     */
  }, {
    key: "drawPeaks",
    value: function drawPeaks(peaks, length, start, end) {
      if (!this.setWidth(length)) {
        this.clearWave();
      }
      this.params.barWidth ? this.drawBars(peaks, 0, start, end) : this.drawWave(peaks, 0, start, end);
    }

    /**
     * Scroll to the beginning
     */
  }, {
    key: "resetScroll",
    value: function resetScroll() {
      if (this.wrapper !== null) {
        this.wrapper.scrollLeft = 0;
      }
    }

    /**
     * Recenter the view-port at a certain percent of the waveform
     *
     * @param {number} percent Value from 0 to 1 on the waveform
     */
  }, {
    key: "recenter",
    value: function recenter(percent) {
      var position = this.wrapper.scrollWidth * percent;
      this.recenterOnPosition(position, true);
    }

    /**
     * Recenter the view-port on a position, either scroll there immediately or
     * in steps of 5 pixels
     *
     * @param {number} position X-offset in pixels
     * @param {boolean} immediate Set to true to immediately scroll somewhere
     */
  }, {
    key: "recenterOnPosition",
    value: function recenterOnPosition(position, immediate) {
      var scrollLeft = this.wrapper.scrollLeft;
      var half = ~~(this.wrapper.clientWidth / 2);
      var maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;
      var target = position - half;
      var offset = target - scrollLeft;
      if (maxScroll == 0) {
        // no need to continue if scrollbar is not there
        return;
      }

      // if the cursor is currently visible...
      if (!immediate && -half <= offset && offset < half) {
        // set rate at which waveform is centered
        var rate = this.params.autoCenterRate;

        // make rate depend on width of view and length of waveform
        rate /= half;
        rate *= maxScroll;
        offset = Math.max(-rate, Math.min(rate, offset));
        target = scrollLeft + offset;
      }

      // limit target to valid range (0 to maxScroll)
      target = Math.max(0, Math.min(maxScroll, target));
      // no use attempting to scroll if we're not moving
      if (target != scrollLeft) {
        this.wrapper.scrollLeft = target;
      }
    }

    /**
     * Get the current scroll position in pixels
     *
     * @return {number} Horizontal scroll position in pixels
     */
  }, {
    key: "getScrollX",
    value: function getScrollX() {
      var x = 0;
      if (this.wrapper) {
        var pixelRatio = this.params.pixelRatio;
        x = Math.round(this.wrapper.scrollLeft * pixelRatio);

        // In cases of elastic scroll (safari with mouse wheel) you can
        // scroll beyond the limits of the container
        // Calculate and floor the scrollable extent to make sure an out
        // of bounds value is not returned
        // Ticket #1312
        if (this.params.scrollParent) {
          var maxScroll = ~~(this.wrapper.scrollWidth * pixelRatio - this.getWidth());
          x = Math.min(maxScroll, Math.max(0, x));
        }
      }
      return x;
    }

    /**
     * Get the width of the container
     *
     * @return {number} The width of the container
     */
  }, {
    key: "getWidth",
    value: function getWidth() {
      return Math.round(this.container.clientWidth * this.params.pixelRatio);
    }

    /**
     * Set the width of the container
     *
     * @param {number} width The new width of the container
     * @return {boolean} Whether the width of the container was updated or not
     */
  }, {
    key: "setWidth",
    value: function setWidth(width) {
      if (this.width == width) {
        return false;
      }
      this.width = width;
      if (this.params.fillParent || this.params.scrollParent) {
        this.style(this.wrapper, {
          width: ''
        });
      } else {
        var newWidth = ~~(this.width / this.params.pixelRatio) + 'px';
        this.style(this.wrapper, {
          width: newWidth
        });
      }
      this.updateSize();
      return true;
    }

    /**
     * Set the height of the container
     *
     * @param {number} height The new height of the container.
     * @return {boolean} Whether the height of the container was updated or not
     */
  }, {
    key: "setHeight",
    value: function setHeight(height) {
      if (height == this.height) {
        return false;
      }
      this.height = height;
      this.style(this.wrapper, {
        height: ~~(this.height / this.params.pixelRatio) + 'px'
      });
      this.updateSize();
      return true;
    }

    /**
     * Called by wavesurfer when progress should be rendered
     *
     * @param {number} progress From 0 to 1
     */
  }, {
    key: "progress",
    value: function progress(_progress) {
      var minPxDelta = 1 / this.params.pixelRatio;
      var pos = Math.round(_progress * this.width) * minPxDelta;
      if (pos < this.lastPos || pos - this.lastPos >= minPxDelta) {
        this.lastPos = pos;
        if (this.params.scrollParent && this.params.autoCenter) {
          var newPos = ~~(this.wrapper.scrollWidth * _progress);
          this.recenterOnPosition(newPos, this.params.autoCenterImmediately);
        }
        this.updateProgress(pos);
      }
    }

    /**
     * This is called when wavesurfer is destroyed
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.unAll();
      if (this.wrapper) {
        if (this.wrapper.parentNode == this.container.domElement) {
          this.container.removeChild(this.wrapper.domElement);
        }
        this.wrapper = null;
      }
    }

    /* Renderer-specific methods */

    /**
     * Called after cursor related params have changed.
     *
     * @abstract
     */
  }, {
    key: "updateCursor",
    value: function updateCursor() {}

    /**
     * Called when the size of the container changes so the renderer can adjust
     *
     * @abstract
     */
  }, {
    key: "updateSize",
    value: function updateSize() {}

    /**
     * Draw a waveform with bars
     *
     * @abstract
     * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel
     * rendering
     * @param {number} channelIndex The index of the current channel. Normally
     * should be 0
     * @param {number} start The x-offset of the beginning of the area that
     * should be rendered
     * @param {number} end The x-offset of the end of the area that should be
     * rendered
     */
  }, {
    key: "drawBars",
    value: function drawBars(peaks, channelIndex, start, end) {}

    /**
     * Draw a waveform
     *
     * @abstract
     * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for split channel
     * rendering
     * @param {number} channelIndex The index of the current channel. Normally
     * should be 0
     * @param {number} start The x-offset of the beginning of the area that
     * should be rendered
     * @param {number} end The x-offset of the end of the area that should be
     * rendered
     */
  }, {
    key: "drawWave",
    value: function drawWave(peaks, channelIndex, start, end) {}

    /**
     * Clear the waveform
     *
     * @abstract
     */
  }, {
    key: "clearWave",
    value: function clearWave() {}

    /**
     * Render the new progress
     *
     * @abstract
     * @param {number} position X-Offset of progress position in pixels
     */
  }, {
    key: "updateProgress",
    value: function updateProgress(position) {}
  }]);
  return Drawer;
}(util.Observer);
exports["default"] = Drawer;
module.exports = exports.default;

/***/ }),

/***/ "./src/drawer.multicanvas.js":
/*!***********************************!*\
  !*** ./src/drawer.multicanvas.js ***!
  \***********************************/
/***/ ((module, exports, __webpack_require__) => {


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _drawer = _interopRequireDefault(__webpack_require__(/*! ./drawer */ "./src/drawer.js"));
var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));
var _drawer2 = _interopRequireDefault(__webpack_require__(/*! ./drawer.canvasentry */ "./src/drawer.canvasentry.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
/**
 * MultiCanvas renderer for wavesurfer. Is currently the default and sole
 * builtin renderer.
 *
 * A `MultiCanvas` consists of one or more `CanvasEntry` instances, depending
 * on the zoom level.
 */
var MultiCanvas = /*#__PURE__*/function (_Drawer) {
  _inherits(MultiCanvas, _Drawer);
  var _super = _createSuper(MultiCanvas);
  /**
   * @param {HTMLElement} container The container node of the wavesurfer instance
   * @param {WavesurferParams} params The wavesurfer initialisation options
   */
  function MultiCanvas(container, params) {
    var _this;
    _classCallCheck(this, MultiCanvas);
    _this = _super.call(this, container, params);

    /**
     * @type {number}
     */
    _this.maxCanvasWidth = params.maxCanvasWidth;

    /**
     * @type {number}
     */
    _this.maxCanvasElementWidth = Math.round(params.maxCanvasWidth / params.pixelRatio);

    /**
     * Whether or not the progress wave is rendered. If the `waveColor`
     * and `progressColor` are the same color it is not.
     *
     * @type {boolean}
     */
    _this.hasProgressCanvas = params.waveColor != params.progressColor;

    /**
     * @type {number}
     */
    _this.halfPixel = 0.5 / params.pixelRatio;

    /**
     * List of `CanvasEntry` instances.
     *
     * @type {Array}
     */
    _this.canvases = [];

    /**
     * @type {HTMLElement}
     */
    _this.progressWave = null;

    /**
     * Class used to generate entries.
     *
     * @type {function}
     */
    _this.EntryClass = _drawer2.default;

    /**
     * Canvas 2d context attributes.
     *
     * @type {object}
     */
    _this.canvasContextAttributes = params.drawingContextAttributes;

    /**
     * Overlap added between entries to prevent vertical white stripes
     * between `canvas` elements.
     *
     * @type {number}
     */
    _this.overlap = 2 * Math.ceil(params.pixelRatio / 2);

    /**
     * The radius of the wave bars. Makes bars rounded
     *
     * @type {number}
     */
    _this.barRadius = params.barRadius || 0;

    /**
     * Whether to render the waveform vertically. Defaults to false.
     *
     * @type {boolean}
     */
    _this.vertical = params.vertical;
    return _this;
  }

  /**
   * Initialize the drawer
   */
  _createClass(MultiCanvas, [{
    key: "init",
    value: function init() {
      this.createWrapper();
      this.createElements();
    }

    /**
     * Create the canvas elements and style them
     *
     */
  }, {
    key: "createElements",
    value: function createElements() {
      this.progressWave = util.withOrientation(this.wrapper.appendChild(document.createElement('wave')), this.params.vertical);
      this.style(this.progressWave, {
        position: 'absolute',
        zIndex: 3,
        left: 0,
        top: 0,
        bottom: 0,
        overflow: 'hidden',
        width: '0',
        display: 'none',
        boxSizing: 'border-box',
        borderRightStyle: 'solid',
        pointerEvents: 'none'
      });
      this.addCanvas();
      this.updateCursor();
    }

    /**
     * Update cursor style
     */
  }, {
    key: "updateCursor",
    value: function updateCursor() {
      this.style(this.progressWave, {
        borderRightWidth: this.params.cursorWidth + 'px',
        borderRightColor: this.params.cursorColor
      });
    }

    /**
     * Adjust to the updated size by adding or removing canvases
     */
  }, {
    key: "updateSize",
    value: function updateSize() {
      var _this2 = this;
      var totalWidth = Math.round(this.width / this.params.pixelRatio);
      var requiredCanvases = Math.ceil(totalWidth / (this.maxCanvasElementWidth + this.overlap));

      // add required canvases
      while (this.canvases.length < requiredCanvases) {
        this.addCanvas();
      }

      // remove older existing canvases, if any
      while (this.canvases.length > requiredCanvases) {
        this.removeCanvas();
      }
      var canvasWidth = this.maxCanvasWidth + this.overlap;
      var lastCanvas = this.canvases.length - 1;
      this.canvases.forEach(function (entry, i) {
        if (i == lastCanvas) {
          canvasWidth = _this2.width - _this2.maxCanvasWidth * lastCanvas;
        }
        _this2.updateDimensions(entry, canvasWidth, _this2.height);
        entry.clearWave();
      });
    }

    /**
     * Add a canvas to the canvas list
     *
     */
  }, {
    key: "addCanvas",
    value: function addCanvas() {
      var entry = new this.EntryClass();
      entry.canvasContextAttributes = this.canvasContextAttributes;
      entry.hasProgressCanvas = this.hasProgressCanvas;
      entry.halfPixel = this.halfPixel;
      var leftOffset = this.maxCanvasElementWidth * this.canvases.length;

      // wave
      var wave = util.withOrientation(this.wrapper.appendChild(document.createElement('canvas')), this.params.vertical);
      this.style(wave, {
        position: 'absolute',
        zIndex: 2,
        left: leftOffset + 'px',
        top: 0,
        bottom: 0,
        height: '100%',
        pointerEvents: 'none'
      });
      entry.initWave(wave);

      // progress
      if (this.hasProgressCanvas) {
        var progress = util.withOrientation(this.progressWave.appendChild(document.createElement('canvas')), this.params.vertical);
        this.style(progress, {
          position: 'absolute',
          left: leftOffset + 'px',
          top: 0,
          bottom: 0,
          height: '100%'
        });
        entry.initProgress(progress);
      }
      this.canvases.push(entry);
    }

    /**
     * Pop single canvas from the list
     *
     */
  }, {
    key: "removeCanvas",
    value: function removeCanvas() {
      var lastEntry = this.canvases[this.canvases.length - 1];

      // wave
      lastEntry.wave.parentElement.removeChild(lastEntry.wave.domElement);

      // progress
      if (this.hasProgressCanvas) {
        lastEntry.progress.parentElement.removeChild(lastEntry.progress.domElement);
      }

      // cleanup
      if (lastEntry) {
        lastEntry.destroy();
        lastEntry = null;
      }
      this.canvases.pop();
    }

    /**
     * Update the dimensions of a canvas element
     *
     * @param {CanvasEntry} entry Target entry
     * @param {number} width The new width of the element
     * @param {number} height The new height of the element
     */
  }, {
    key: "updateDimensions",
    value: function updateDimensions(entry, width, height) {
      var elementWidth = Math.round(width / this.params.pixelRatio);
      var totalWidth = Math.round(this.width / this.params.pixelRatio);

      // update canvas dimensions
      entry.updateDimensions(elementWidth, totalWidth, width, height);

      // style element
      this.style(this.progressWave, {
        display: 'block'
      });
    }

    /**
     * Clear the whole multi-canvas
     */
  }, {
    key: "clearWave",
    value: function clearWave() {
      var _this3 = this;
      util.frame(function () {
        _this3.canvases.forEach(function (entry) {
          return entry.clearWave();
        });
      })();
    }

    /**
     * Draw a waveform with bars
     *
     * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
     * for split channel rendering
     * @param {number} channelIndex The index of the current channel. Normally
     * should be 0. Must be an integer.
     * @param {number} start The x-offset of the beginning of the area that
     * should be rendered
     * @param {number} end The x-offset of the end of the area that should be
     * rendered
     * @returns {void}
     */
  }, {
    key: "drawBars",
    value: function drawBars(peaks, channelIndex, start, end) {
      var _this4 = this;
      return this.prepareDraw(peaks, channelIndex, start, end, function (_ref) {
        var absmax = _ref.absmax,
          hasMinVals = _ref.hasMinVals,
          offsetY = _ref.offsetY,
          halfH = _ref.halfH,
          peaks = _ref.peaks,
          ch = _ref.channelIndex;
        // if drawBars was called within ws.empty we don't pass a start and
        // don't want anything to happen
        if (start === undefined) {
          return;
        }
        // Skip every other value if there are negatives.
        var peakIndexScale = hasMinVals ? 2 : 1;
        var length = peaks.length / peakIndexScale;
        var bar = _this4.params.barWidth * _this4.params.pixelRatio;
        var gap = _this4.params.barGap === null ? Math.max(_this4.params.pixelRatio, ~~(bar / 2)) : Math.max(_this4.params.pixelRatio, _this4.params.barGap * _this4.params.pixelRatio);
        var step = bar + gap;
        var scale = length / _this4.width;
        var first = start;
        var last = end;
        var peakIndex = first;
        for (peakIndex; peakIndex < last; peakIndex += step) {
          // search for the highest peak in the range this bar falls into
          var peak = 0;
          var peakIndexRange = Math.floor(peakIndex * scale) * peakIndexScale; // start index
          var peakIndexEnd = Math.floor((peakIndex + step) * scale) * peakIndexScale;
          do {
            // do..while makes sure at least one peak is always evaluated
            var newPeak = Math.abs(peaks[peakIndexRange]); // for arrays starting with negative values
            if (newPeak > peak) {
              peak = newPeak; // higher
            }

            peakIndexRange += peakIndexScale; // skip every other value for negatives
          } while (peakIndexRange < peakIndexEnd);

          // calculate the height of this bar according to the highest peak found
          var h = Math.round(peak / absmax * halfH);

          // raise the bar height to the specified minimum height
          // Math.max is used to replace any value smaller than barMinHeight (not just 0) with barMinHeight
          if (_this4.params.barMinHeight) {
            h = Math.max(h, _this4.params.barMinHeight);
          }
          _this4.fillRect(peakIndex + _this4.halfPixel, halfH - h + offsetY, bar + _this4.halfPixel, h * 2, _this4.barRadius, ch);
        }
      });
    }

    /**
     * Draw a waveform
     *
     * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays
     * for split channel rendering
     * @param {number} channelIndex The index of the current channel. Normally
     * should be 0
     * @param {number?} start The x-offset of the beginning of the area that
     * should be rendered (If this isn't set only a flat line is rendered)
     * @param {number?} end The x-offset of the end of the area that should be
     * rendered
     * @returns {void}
     */
  }, {
    key: "drawWave",
    value: function drawWave(peaks, channelIndex, start, end) {
      var _this5 = this;
      return this.prepareDraw(peaks, channelIndex, start, end, function (_ref2) {
        var absmax = _ref2.absmax,
          hasMinVals = _ref2.hasMinVals,
          offsetY = _ref2.offsetY,
          halfH = _ref2.halfH,
          peaks = _ref2.peaks,
          channelIndex = _ref2.channelIndex;
        if (!hasMinVals) {
          var reflectedPeaks = [];
          var len = peaks.length;
          var i = 0;
          for (i; i < len; i++) {
            reflectedPeaks[2 * i] = peaks[i];
            reflectedPeaks[2 * i + 1] = -peaks[i];
          }
          peaks = reflectedPeaks;
        }

        // if drawWave was called within ws.empty we don't pass a start and
        // end and simply want a flat line
        if (start !== undefined) {
          _this5.drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex);
        }

        // always draw a median line
        _this5.fillRect(0, halfH + offsetY - _this5.halfPixel, _this5.width, _this5.halfPixel, _this5.barRadius, channelIndex);
      });
    }

    /**
     * Tell the canvas entries to render their portion of the waveform
     *
     * @param {number[]} peaks Peaks data
     * @param {number} absmax Maximum peak value (absolute)
     * @param {number} halfH Half the height of the waveform
     * @param {number} offsetY Offset to the top
     * @param {number} start The x-offset of the beginning of the area that
     * should be rendered
     * @param {number} end The x-offset of the end of the area that
     * should be rendered
     * @param {channelIndex} channelIndex The channel index of the line drawn
     */
  }, {
    key: "drawLine",
    value: function drawLine(peaks, absmax, halfH, offsetY, start, end, channelIndex) {
      var _this6 = this;
      var _ref3 = this.params.splitChannelsOptions.channelColors[channelIndex] || {},
        waveColor = _ref3.waveColor,
        progressColor = _ref3.progressColor;
      this.canvases.forEach(function (entry, i) {
        _this6.setFillStyles(entry, waveColor, progressColor);
        _this6.applyCanvasTransforms(entry, _this6.params.vertical);
        entry.drawLines(peaks, absmax, halfH, offsetY, start, end);
      });
    }

    /**
     * Draw a rectangle on the multi-canvas
     *
     * @param {number} x X-position of the rectangle
     * @param {number} y Y-position of the rectangle
     * @param {number} width Width of the rectangle
     * @param {number} height Height of the rectangle
     * @param {number} radius Radius of the rectangle
     * @param {channelIndex} channelIndex The channel index of the bar drawn
     */
  }, {
    key: "fillRect",
    value: function fillRect(x, y, width, height, radius, channelIndex) {
      var startCanvas = Math.floor(x / this.maxCanvasWidth);
      var endCanvas = Math.min(Math.ceil((x + width) / this.maxCanvasWidth) + 1, this.canvases.length);
      var i = startCanvas;
      for (i; i < endCanvas; i++) {
        var entry = this.canvases[i];
        var leftOffset = i * this.maxCanvasWidth;
        var intersection = {
          x1: Math.max(x, i * this.maxCanvasWidth),
          y1: y,
          x2: Math.min(x + width, i * this.maxCanvasWidth + entry.wave.width),
          y2: y + height
        };
        if (intersection.x1 < intersection.x2) {
          var _ref4 = this.params.splitChannelsOptions.channelColors[channelIndex] || {},
            waveColor = _ref4.waveColor,
            progressColor = _ref4.progressColor;
          this.setFillStyles(entry, waveColor, progressColor);
          this.applyCanvasTransforms(entry, this.params.vertical);
          entry.fillRects(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1, radius);
        }
      }
    }

    /**
     * Returns whether to hide the channel from being drawn based on params.
     *
     * @param {number} channelIndex The index of the current channel.
     * @returns {bool} True to hide the channel, false to draw.
     */
  }, {
    key: "hideChannel",
    value: function hideChannel(channelIndex) {
      return this.params.splitChannels && this.params.splitChannelsOptions.filterChannels.includes(channelIndex);
    }

    /**
     * Performs preparation tasks and calculations which are shared by `drawBars`
     * and `drawWave`
     *
     * @param {number[]|Number.<Array[]>} peaks Can also be an array of arrays for
     * split channel rendering
     * @param {number} channelIndex The index of the current channel. Normally
     * should be 0
     * @param {number?} start The x-offset of the beginning of the area that
     * should be rendered. If this isn't set only a flat line is rendered
     * @param {number?} end The x-offset of the end of the area that should be
     * rendered
     * @param {function} fn The render function to call, e.g. `drawWave`
     * @param {number} drawIndex The index of the current channel after filtering.
     * @param {number?} normalizedMax Maximum modulation value across channels for use with relativeNormalization. Ignored when undefined
     * @returns {void}
     */
  }, {
    key: "prepareDraw",
    value: function prepareDraw(peaks, channelIndex, start, end, fn, drawIndex, normalizedMax) {
      var _this7 = this;
      return util.frame(function () {
        // Split channels and call this function with the channelIndex set
        if (peaks[0] instanceof Array) {
          var channels = peaks;
          if (_this7.params.splitChannels) {
            var filteredChannels = channels.filter(function (c, i) {
              return !_this7.hideChannel(i);
            });
            if (!_this7.params.splitChannelsOptions.overlay) {
              _this7.setHeight(Math.max(filteredChannels.length, 1) * _this7.params.height * _this7.params.pixelRatio);
            }
            var overallAbsMax;
            if (_this7.params.splitChannelsOptions && _this7.params.splitChannelsOptions.relativeNormalization) {
              // calculate maximum peak across channels to use for normalization
              overallAbsMax = util.max(channels.map(function (channelPeaks) {
                return util.absMax(channelPeaks);
              }));
            }
            return channels.forEach(function (channelPeaks, i) {
              return _this7.prepareDraw(channelPeaks, i, start, end, fn, filteredChannels.indexOf(channelPeaks), overallAbsMax);
            });
          }
          peaks = channels[0];
        }

        // Return and do not draw channel peaks if hidden.
        if (_this7.hideChannel(channelIndex)) {
          return;
        }

        // calculate maximum modulation value, either from the barHeight
        // parameter or if normalize=true from the largest value in the peak
        // set
        var absmax = 1 / _this7.params.barHeight;
        if (_this7.params.normalize) {
          absmax = normalizedMax === undefined ? util.absMax(peaks) : normalizedMax;
        }

        // Bar wave draws the bottom only as a reflection of the top,
        // so we don't need negative values
        var hasMinVals = [].some.call(peaks, function (val) {
          return val < 0;
        });
        var height = _this7.params.height * _this7.params.pixelRatio;
        var halfH = height / 2;
        var offsetY = height * drawIndex || 0;

        // Override offsetY if overlay is true
        if (_this7.params.splitChannelsOptions && _this7.params.splitChannelsOptions.overlay) {
          offsetY = 0;
        }
        return fn({
          absmax: absmax,
          hasMinVals: hasMinVals,
          height: height,
          offsetY: offsetY,
          halfH: halfH,
          peaks: peaks,
          channelIndex: channelIndex
        });
      })();
    }

    /**
     * Set the fill styles for a certain entry (wave and progress)
     *
     * @param {CanvasEntry} entry Target entry
     * @param {string} waveColor Wave color to draw this entry
     * @param {string} progressColor Progress color to draw this entry
     */
  }, {
    key: "setFillStyles",
    value: function setFillStyles(entry) {
      var waveColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.waveColor;
      var progressColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.params.progressColor;
      entry.setFillStyles(waveColor, progressColor);
    }

    /**
     * Set the canvas transforms for a certain entry (wave and progress)
     *
     * @param {CanvasEntry} entry Target entry
     * @param {boolean} vertical Whether to render the waveform vertically
     */
  }, {
    key: "applyCanvasTransforms",
    value: function applyCanvasTransforms(entry) {
      var vertical = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      entry.applyCanvasTransforms(vertical);
    }

    /**
     * Return image data of the multi-canvas
     *
     * When using a `type` of `'blob'`, this will return a `Promise`.
     *
     * @param {string} format='image/png' An optional value of a format type.
     * @param {number} quality=0.92 An optional value between 0 and 1.
     * @param {string} type='dataURL' Either 'dataURL' or 'blob'.
     * @return {string|string[]|Promise} When using the default `'dataURL'`
     * `type` this returns a single data URL or an array of data URLs,
     * one for each canvas. When using the `'blob'` `type` this returns a
     * `Promise` that resolves with an array of `Blob` instances, one for each
     * canvas.
     */
  }, {
    key: "getImage",
    value: function getImage(format, quality, type) {
      if (type === 'blob') {
        return Promise.all(this.canvases.map(function (entry) {
          return entry.getImage(format, quality, type);
        }));
      } else if (type === 'dataURL') {
        var images = this.canvases.map(function (entry) {
          return entry.getImage(format, quality, type);
        });
        return images.length > 1 ? images : images[0];
      }
    }

    /**
     * Render the new progress
     *
     * @param {number} position X-offset of progress position in pixels
     */
  }, {
    key: "updateProgress",
    value: function updateProgress(position) {
      this.style(this.progressWave, {
        width: position + 'px'
      });
    }
  }]);
  return MultiCanvas;
}(_drawer.default);
exports["default"] = MultiCanvas;
module.exports = exports.default;

/***/ }),

/***/ "./src/mediaelement-webaudio.js":
/*!**************************************!*\
  !*** ./src/mediaelement-webaudio.js ***!
  \**************************************/
/***/ ((module, exports, __webpack_require__) => {


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _mediaelement = _interopRequireDefault(__webpack_require__(/*! ./mediaelement */ "./src/mediaelement.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
/**
 * MediaElementWebAudio backend: load audio via an HTML5 audio tag, but playback with the WebAudio API.
 * The advantage here is that the html5 <audio> tag can perform range requests on the server and not
 * buffer the entire file in one request, and you still get the filtering and scripting functionality
 * of the webaudio API.
 * Note that in order to use range requests and prevent buffering, you must provide peak data.
 *
 * @since 3.2.0
 */
var MediaElementWebAudio = /*#__PURE__*/function (_MediaElement) {
  _inherits(MediaElementWebAudio, _MediaElement);
  var _super = _createSuper(MediaElementWebAudio);
  /**
   * Construct the backend
   *
   * @param {WavesurferParams} params Wavesurfer parameters
   */
  function MediaElementWebAudio(params) {
    var _this;
    _classCallCheck(this, MediaElementWebAudio);
    _this = _super.call(this, params);
    /** @private */
    _this.params = params;
    /** @private */
    _this.sourceMediaElement = null;
    return _this;
  }

  /**
   * Initialise the backend, called in `wavesurfer.createBackend()`
   */
  _createClass(MediaElementWebAudio, [{
    key: "init",
    value: function init() {
      this.setPlaybackRate(this.params.audioRate);
      this.createTimer();
      this.createVolumeNode();
      this.createScriptNode();
      this.createAnalyserNode();
    }
    /**
     * Private method called by both `load` (from url)
     * and `loadElt` (existing media element) methods.
     *
     * @param {HTMLMediaElement} media HTML5 Audio or Video element
     * @param {number[]|Number.<Array[]>} peaks Array of peak data
     * @param {string} preload HTML 5 preload attribute value
     * @private
     */
  }, {
    key: "_load",
    value: function _load(media, peaks, preload) {
      _get(_getPrototypeOf(MediaElementWebAudio.prototype), "_load", this).call(this, media, peaks, preload);
      this.createMediaElementSource(media);
    }

    /**
     * Create MediaElementSource node
     *
     * @since 3.2.0
     * @param {HTMLMediaElement} mediaElement HTML5 Audio to load
     */
  }, {
    key: "createMediaElementSource",
    value: function createMediaElementSource(mediaElement) {
      this.sourceMediaElement = this.ac.createMediaElementSource(mediaElement);
      this.sourceMediaElement.connect(this.analyser);
    }
  }, {
    key: "play",
    value: function play(start, end) {
      this.resumeAudioContext();
      return _get(_getPrototypeOf(MediaElementWebAudio.prototype), "play", this).call(this, start, end);
    }

    /**
     * This is called when wavesurfer is destroyed
     *
     */
  }, {
    key: "destroy",
    value: function destroy() {
      _get(_getPrototypeOf(MediaElementWebAudio.prototype), "destroy", this).call(this);
      this.destroyWebAudio();
    }
  }]);
  return MediaElementWebAudio;
}(_mediaelement.default);
exports["default"] = MediaElementWebAudio;
module.exports = exports.default;

/***/ }),

/***/ "./src/mediaelement.js":
/*!*****************************!*\
  !*** ./src/mediaelement.js ***!
  \*****************************/
/***/ ((module, exports, __webpack_require__) => {


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _webaudio = _interopRequireDefault(__webpack_require__(/*! ./webaudio */ "./src/webaudio.js"));
var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
/**
 * MediaElement backend
 */
var MediaElement = /*#__PURE__*/function (_WebAudio) {
  _inherits(MediaElement, _WebAudio);
  var _super = _createSuper(MediaElement);
  /**
   * Construct the backend
   *
   * @param {WavesurferParams} params Wavesurfer parameters
   */
  function MediaElement(params) {
    var _this;
    _classCallCheck(this, MediaElement);
    _this = _super.call(this, params);
    /** @private */
    _this.params = params;

    /**
     * Initially a dummy media element to catch errors. Once `_load` is
     * called, this will contain the actual `HTMLMediaElement`.
     * @private
     */
    _this.media = {
      currentTime: 0,
      duration: 0,
      paused: true,
      playbackRate: 1,
      play: function play() {},
      pause: function pause() {},
      volume: 0
    };

    /** @private */
    _this.mediaType = params.mediaType.toLowerCase();
    /** @private */
    _this.elementPosition = params.elementPosition;
    /** @private */
    _this.peaks = null;
    /** @private */
    _this.playbackRate = 1;
    /** @private */
    _this.volume = 1;
    /** @private */
    _this.isMuted = false;
    /** @private */
    _this.buffer = null;
    /** @private */
    _this.onPlayEnd = null;
    /** @private */
    _this.mediaListeners = {};
    return _this;
  }

  /**
   * Initialise the backend, called in `wavesurfer.createBackend()`
   */
  _createClass(MediaElement, [{
    key: "init",
    value: function init() {
      this.setPlaybackRate(this.params.audioRate);
      this.createTimer();
    }

    /**
     * Attach event listeners to media element.
     */
  }, {
    key: "_setupMediaListeners",
    value: function _setupMediaListeners() {
      var _this2 = this;
      this.mediaListeners.error = function () {
        _this2.fireEvent('error', 'Error loading media element');
      };
      this.mediaListeners.canplay = function () {
        _this2.fireEvent('canplay');
      };
      this.mediaListeners.ended = function () {
        _this2.fireEvent('finish');
      };
      // listen to and relay play, pause and seeked events to enable
      // playback control from the external media element
      this.mediaListeners.play = function () {
        _this2.fireEvent('play');
      };
      this.mediaListeners.pause = function () {
        _this2.fireEvent('pause');
      };
      this.mediaListeners.seeked = function (event) {
        _this2.fireEvent('seek');
      };
      this.mediaListeners.volumechange = function (event) {
        _this2.isMuted = _this2.media.muted;
        if (_this2.isMuted) {
          _this2.volume = 0;
        } else {
          _this2.volume = _this2.media.volume;
        }
        _this2.fireEvent('volume');
      };

      // reset event listeners
      Object.keys(this.mediaListeners).forEach(function (id) {
        _this2.media.removeEventListener(id, _this2.mediaListeners[id]);
        _this2.media.addEventListener(id, _this2.mediaListeners[id]);
      });
    }

    /**
     * Create a timer to provide a more precise `audioprocess` event.
     */
  }, {
    key: "createTimer",
    value: function createTimer() {
      var _this3 = this;
      var onAudioProcess = function onAudioProcess() {
        if (_this3.isPaused()) {
          return;
        }
        _this3.fireEvent('audioprocess', _this3.getCurrentTime());

        // Call again in the next frame
        util.frame(onAudioProcess)();
      };
      this.on('play', onAudioProcess);

      // Update the progress one more time to prevent it from being stuck in
      // case of lower framerates
      this.on('pause', function () {
        _this3.fireEvent('audioprocess', _this3.getCurrentTime());
      });
    }

    /**
     * Create media element with url as its source,
     * and append to container element.
     *
     * @param {string} url Path to media file
     * @param {HTMLElement} container HTML element
     * @param {number[]|Number.<Array[]>} peaks Array of peak data
     * @param {string} preload HTML 5 preload attribute value
     * @throws Will throw an error if the `url` argument is not a valid media
     * element.
     */
  }, {
    key: "load",
    value: function load(url, container, peaks, preload) {
      var media = document.createElement(this.mediaType);
      media.controls = this.params.mediaControls;
      media.autoplay = this.params.autoplay || false;
      media.preload = preload == null ? 'auto' : preload;
      media.src = url;
      media.style.width = '100%';
      var prevMedia = container.querySelector(this.mediaType);
      if (prevMedia) {
        container.removeChild(prevMedia);
      }
      container.appendChild(media);
      this._load(media, peaks, preload);
    }

    /**
     * Load existing media element.
     *
     * @param {HTMLMediaElement} elt HTML5 Audio or Video element
     * @param {number[]|Number.<Array[]>} peaks Array of peak data
     */
  }, {
    key: "loadElt",
    value: function loadElt(elt, peaks) {
      elt.controls = this.params.mediaControls;
      elt.autoplay = this.params.autoplay || false;
      this._load(elt, peaks, elt.preload);
    }

    /**
     * Method called by both `load` (from url)
     * and `loadElt` (existing media element) methods.
     *
     * @param {HTMLMediaElement} media HTML5 Audio or Video element
     * @param {number[]|Number.<Array[]>} peaks Array of peak data
     * @param {string} preload HTML 5 preload attribute value
     * @throws Will throw an error if the `media` argument is not a valid media
     * element.
     * @private
     */
  }, {
    key: "_load",
    value: function _load(media, peaks, preload) {
      // verify media element is valid
      if (!(media instanceof HTMLMediaElement) || typeof media.addEventListener === 'undefined') {
        throw new Error('media parameter is not a valid media element');
      }

      // load must be called manually on iOS, otherwise peaks won't draw
      // until a user interaction triggers load --> 'ready' event
      //
      // note that we avoid calling media.load here when given peaks and preload == 'none'
      // as this almost always triggers some browser fetch of the media.
      if (typeof media.load == 'function' && !(peaks && preload == 'none')) {
        // Resets the media element and restarts the media resource. Any
        // pending events are discarded. How much media data is fetched is
        // still affected by the preload attribute.
        media.load();
      }
      this.media = media;
      this._setupMediaListeners();
      this.peaks = peaks;
      this.onPlayEnd = null;
      this.buffer = null;
      this.isMuted = media.muted;
      this.setPlaybackRate(this.playbackRate);
      this.setVolume(this.volume);
    }

    /**
     * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
     *
     * @return {boolean} Media paused or not
     */
  }, {
    key: "isPaused",
    value: function isPaused() {
      return !this.media || this.media.paused;
    }

    /**
     * Used by `wavesurfer.getDuration()`
     *
     * @return {number} Duration
     */
  }, {
    key: "getDuration",
    value: function getDuration() {
      if (this.explicitDuration) {
        return this.explicitDuration;
      }
      var duration = (this.buffer || this.media).duration;
      if (duration >= Infinity) {
        // streaming audio
        duration = this.media.seekable.end(0);
      }
      return duration;
    }

    /**
     * Returns the current time in seconds relative to the audio-clip's
     * duration.
     *
     * @return {number} Current time
     */
  }, {
    key: "getCurrentTime",
    value: function getCurrentTime() {
      return this.media && this.media.currentTime;
    }

    /**
     * Get the position from 0 to 1
     *
     * @return {number} Current position
     */
  }, {
    key: "getPlayedPercents",
    value: function getPlayedPercents() {
      return this.getCurrentTime() / this.getDuration() || 0;
    }

    /**
     * Get the audio source playback rate.
     *
     * @return {number} Playback rate
     */
  }, {
    key: "getPlaybackRate",
    value: function getPlaybackRate() {
      return this.playbackRate || this.media.playbackRate;
    }

    /**
     * Set the audio source playback rate.
     *
     * @param {number} value Playback rate
     */
  }, {
    key: "setPlaybackRate",
    value: function setPlaybackRate(value) {
      this.playbackRate = value || 1;
      this.media.playbackRate = this.playbackRate;
    }

    /**
     * Used by `wavesurfer.seekTo()`
     *
     * @param {number} start Position to start at in seconds
     */
  }, {
    key: "seekTo",
    value: function seekTo(start) {
      if (start != null && !isNaN(start)) {
        this.media.currentTime = start;
      }
      this.clearPlayEnd();
    }

    /**
     * Plays the loaded audio region.
     *
     * @param {number} start Start offset in seconds, relative to the beginning
     * of a clip.
     * @param {number} end When to stop, relative to the beginning of a clip.
     * @emits MediaElement#play
     * @return {Promise} Result
     */
  }, {
    key: "play",
    value: function play(start, end) {
      this.seekTo(start);
      var promise = this.media.play();
      end && this.setPlayEnd(end);
      return promise;
    }

    /**
     * Pauses the loaded audio.
     *
     * @emits MediaElement#pause
     * @return {Promise} Result
     */
  }, {
    key: "pause",
    value: function pause() {
      var promise;
      if (this.media) {
        promise = this.media.pause();
      }
      this.clearPlayEnd();
      return promise;
    }

    /**
     * Set the play end
     *
     * @param {number} end Where to end
     */
  }, {
    key: "setPlayEnd",
    value: function setPlayEnd(end) {
      var _this4 = this;
      this.clearPlayEnd();
      this._onPlayEnd = function (time) {
        if (time >= end) {
          _this4.pause();
          _this4.seekTo(end);
        }
      };
      this.on('audioprocess', this._onPlayEnd);
    }

    /** @private */
  }, {
    key: "clearPlayEnd",
    value: function clearPlayEnd() {
      if (this._onPlayEnd) {
        this.un('audioprocess', this._onPlayEnd);
        this._onPlayEnd = null;
      }
    }

    /**
     * Compute the max and min value of the waveform when broken into
     * <length> subranges.
     *
     * @param {number} length How many subranges to break the waveform into.
     * @param {number} first First sample in the required range.
     * @param {number} last Last sample in the required range.
     * @return {number[]|Number.<Array[]>} Array of 2*<length> peaks or array of
     * arrays of peaks consisting of (max, min) values for each subrange.
     */
  }, {
    key: "getPeaks",
    value: function getPeaks(length, first, last) {
      if (this.buffer) {
        return _get(_getPrototypeOf(MediaElement.prototype), "getPeaks", this).call(this, length, first, last);
      }
      return this.peaks || [];
    }

    /**
     * Set the sink id for the media player
     *
     * @param {string} deviceId String value representing audio device id.
     * @returns {Promise} A Promise that resolves to `undefined` when there
     * are no errors.
     */
  }, {
    key: "setSinkId",
    value: function setSinkId(deviceId) {
      if (deviceId) {
        if (!this.media.setSinkId) {
          return Promise.reject(new Error('setSinkId is not supported in your browser'));
        }
        return this.media.setSinkId(deviceId);
      }
      return Promise.reject(new Error('Invalid deviceId: ' + deviceId));
    }

    /**
     * Get the current volume
     *
     * @return {number} value A floating point value between 0 and 1.
     */
  }, {
    key: "getVolume",
    value: function getVolume() {
      return this.volume;
    }

    /**
     * Set the audio volume
     *
     * @param {number} value A floating point value between 0 and 1.
     */
  }, {
    key: "setVolume",
    value: function setVolume(value) {
      this.volume = value;
      // no need to change when it's already at that volume
      if (this.media.volume !== this.volume) {
        this.media.volume = this.volume;
      }
    }

    /**
     * Enable or disable muted audio
     *
     * @since 4.0.0
     * @param {boolean} muted Specify `true` to mute audio.
     */
  }, {
    key: "setMute",
    value: function setMute(muted) {
      // This causes a volume change to be emitted too through the
      // volumechange event listener.
      this.isMuted = this.media.muted = muted;
    }

    /**
     * This is called when wavesurfer is destroyed
     *
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this5 = this;
      this.pause();
      this.unAll();
      this.destroyed = true;

      // cleanup media event listeners
      Object.keys(this.mediaListeners).forEach(function (id) {
        if (_this5.media) {
          _this5.media.removeEventListener(id, _this5.mediaListeners[id]);
        }
      });
      if (this.params.removeMediaElementOnDestroy && this.media && this.media.parentNode) {
        this.media.parentNode.removeChild(this.media);
      }
      this.media = null;
    }
  }]);
  return MediaElement;
}(_webaudio.default);
exports["default"] = MediaElement;
module.exports = exports.default;

/***/ }),

/***/ "./src/peakcache.js":
/*!**************************!*\
  !*** ./src/peakcache.js ***!
  \**************************/
/***/ ((module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
/**
 * Caches the decoded peaks data to improve rendering speed for large audio
 *
 * Is used if the option parameter `partialRender` is set to `true`
 */
var PeakCache = /*#__PURE__*/function () {
  /**
   * Instantiate cache
   */
  function PeakCache() {
    _classCallCheck(this, PeakCache);
    this.clearPeakCache();
  }

  /**
   * Empty the cache
   */
  _createClass(PeakCache, [{
    key: "clearPeakCache",
    value: function clearPeakCache() {
      /**
       * Flat array with entries that are always in pairs to mark the
       * beginning and end of each subrange.  This is a convenience so we can
       * iterate over the pairs for easy set difference operations.
       * @private
       */
      this.peakCacheRanges = [];
      /**
       * Length of the entire cachable region, used for resetting the cache
       * when this changes (zoom events, for instance).
       * @private
       */
      this.peakCacheLength = -1;
    }

    /**
     * Add a range of peaks to the cache
     *
     * @param {number} length The length of the range
     * @param {number} start The x offset of the start of the range
     * @param {number} end The x offset of the end of the range
     * @return {Number.<Array[]>} Array with arrays of numbers
     */
  }, {
    key: "addRangeToPeakCache",
    value: function addRangeToPeakCache(length, start, end) {
      if (length != this.peakCacheLength) {
        this.clearPeakCache();
        this.peakCacheLength = length;
      }

      // Return ranges that weren't in the cache before the call.
      var uncachedRanges = [];
      var i = 0;
      // Skip ranges before the current start.
      while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] < start) {
        i++;
      }
      // If |i| is even, |start| falls after an existing range.  Otherwise,
      // |start| falls between an existing range, and the uncached region
      // starts when we encounter the next node in |peakCacheRanges| or
      // |end|, whichever comes first.
      if (i % 2 == 0) {
        uncachedRanges.push(start);
      }
      while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] <= end) {
        uncachedRanges.push(this.peakCacheRanges[i]);
        i++;
      }
      // If |i| is even, |end| is after all existing ranges.
      if (i % 2 == 0) {
        uncachedRanges.push(end);
      }

      // Filter out the 0-length ranges.
      uncachedRanges = uncachedRanges.filter(function (item, pos, arr) {
        if (pos == 0) {
          return item != arr[pos + 1];
        } else if (pos == arr.length - 1) {
          return item != arr[pos - 1];
        }
        return item != arr[pos - 1] && item != arr[pos + 1];
      });

      // Merge the two ranges together, uncachedRanges will either contain
      // wholly new points, or duplicates of points in peakCacheRanges.  If
      // duplicates are detected, remove both and extend the range.
      this.peakCacheRanges = this.peakCacheRanges.concat(uncachedRanges);
      this.peakCacheRanges = this.peakCacheRanges.sort(function (a, b) {
        return a - b;
      }).filter(function (item, pos, arr) {
        if (pos == 0) {
          return item != arr[pos + 1];
        } else if (pos == arr.length - 1) {
          return item != arr[pos - 1];
        }
        return item != arr[pos - 1] && item != arr[pos + 1];
      });

      // Push the uncached ranges into an array of arrays for ease of
      // iteration in the functions that call this.
      var uncachedRangePairs = [];
      for (i = 0; i < uncachedRanges.length; i += 2) {
        uncachedRangePairs.push([uncachedRanges[i], uncachedRanges[i + 1]]);
      }
      return uncachedRangePairs;
    }

    /**
     * For testing
     *
     * @return {Number.<Array[]>} Array with arrays of numbers
     */
  }, {
    key: "getCacheRanges",
    value: function getCacheRanges() {
      var peakCacheRangePairs = [];
      var i;
      for (i = 0; i < this.peakCacheRanges.length; i += 2) {
        peakCacheRangePairs.push([this.peakCacheRanges[i], this.peakCacheRanges[i + 1]]);
      }
      return peakCacheRangePairs;
    }
  }]);
  return PeakCache;
}();
exports["default"] = PeakCache;
module.exports = exports.default;

/***/ }),

/***/ "./src/util/absMax.js":
/*!****************************!*\
  !*** ./src/util/absMax.js ***!
  \****************************/
/***/ ((module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = absMax;
var _max = _interopRequireDefault(__webpack_require__(/*! ./max */ "./src/util/max.js"));
var _min = _interopRequireDefault(__webpack_require__(/*! ./min */ "./src/util/min.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Get the largest absolute value in an array
 *
 * @param   {Array} values Array of numbers
 * @returns {Number} Largest number found
 * @example console.log(max([-3, 2, 1]), max([-3, 2, 4])); // logs 3 4
 * @since 4.3.0
 */
function absMax(values) {
  var max = (0, _max.default)(values);
  var min = (0, _min.default)(values);
  return -min > max ? -min : max;
}
module.exports = exports.default;

/***/ }),

/***/ "./src/util/clamp.js":
/*!***************************!*\
  !*** ./src/util/clamp.js ***!
  \***************************/
/***/ ((module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = clamp;
/**
 * Returns a number limited to the given range.
 *
 * @param {number} val The number to be limited to a range
 * @param {number} min The lower boundary of the limit range
 * @param {number} max The upper boundary of the limit range
 * @returns {number} A number in the range [min, max]
 */
function clamp(val, min, max) {
  return Math.min(Math.max(min, val), max);
}
module.exports = exports.default;

/***/ }),

/***/ "./src/util/fetch.js":
/*!***************************!*\
  !*** ./src/util/fetch.js ***!
  \***************************/
/***/ ((module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = fetchFile;
var _observer = _interopRequireDefault(__webpack_require__(/*! ./observer */ "./src/util/observer.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var ProgressHandler = /*#__PURE__*/function () {
  /**
   * Instantiate ProgressHandler
   *
   * @param {Observer} instance The `fetchFile` observer instance.
   * @param {Number} contentLength Content length.
   * @param {Response} response Response object.
   */
  function ProgressHandler(instance, contentLength, response) {
    _classCallCheck(this, ProgressHandler);
    this.instance = instance;
    this.instance._reader = response.body.getReader();
    this.total = parseInt(contentLength, 10);
    this.loaded = 0;
  }

  /**
   * A method that is called once, immediately after the `ReadableStream``
   * is constructed.
   *
   * @param {ReadableStreamDefaultController} controller Controller instance
   *     used to control the stream.
   */
  _createClass(ProgressHandler, [{
    key: "start",
    value: function start(controller) {
      var _this = this;
      var read = function read() {
        // instance._reader.read() returns a promise that resolves
        // when a value has been received
        _this.instance._reader.read().then(function (_ref) {
          var done = _ref.done,
            value = _ref.value;
          // result objects contain two properties:
          // done  - true if the stream has already given you all its data.
          // value - some data. Always undefined when done is true.
          if (done) {
            // ensure onProgress called when content-length=0
            if (_this.total === 0) {
              _this.instance.onProgress.call(_this.instance, {
                loaded: _this.loaded,
                total: _this.total,
                lengthComputable: false
              });
            }
            // no more data needs to be consumed, close the stream
            controller.close();
            return;
          }
          _this.loaded += value.byteLength;
          _this.instance.onProgress.call(_this.instance, {
            loaded: _this.loaded,
            total: _this.total,
            lengthComputable: !(_this.total === 0)
          });
          // enqueue the next data chunk into our target stream
          controller.enqueue(value);
          read();
        }).catch(function (error) {
          controller.error(error);
        });
      };
      read();
    }
  }]);
  return ProgressHandler;
}();
/**
 * Load a file using `fetch`.
 *
 * @param {object} options Request options to use. See example below.
 * @returns {Observer} Observer instance
 * @example
 * // default options
 * let options = {
 *     url: undefined,
 *     method: 'GET',
 *     mode: 'cors',
 *     credentials: 'same-origin',
 *     cache: 'default',
 *     responseType: 'json',
 *     requestHeaders: [],
 *     redirect: 'follow',
 *     referrer: 'client'
 * };
 *
 * // override some options
 * options.url = '../media/demo.wav';

 * // available types: 'arraybuffer', 'blob', 'json' or 'text'
 * options.responseType = 'arraybuffer';
 *
 * // make fetch call
 * let request = util.fetchFile(options);
 *
 * // listen for events
 * request.on('progress', e => {
 *     console.log('progress', e);
 * });
 *
 * request.on('success', data => {
 *     console.log('success!', data);
 * });
 *
 * request.on('error', e => {
 *     console.warn('fetchFile error: ', e);
 * });
 */
function fetchFile(options) {
  if (!options) {
    throw new Error('fetch options missing');
  } else if (!options.url) {
    throw new Error('fetch url missing');
  }
  var instance = new _observer.default();
  var fetchHeaders = new Headers();
  var fetchRequest = new Request(options.url);

  // add ability to abort
  instance.controller = new AbortController();

  // check if headers have to be added
  if (options && options.requestHeaders) {
    // add custom request headers
    options.requestHeaders.forEach(function (header) {
      fetchHeaders.append(header.key, header.value);
    });
  }

  // parse fetch options
  var responseType = options.responseType || 'json';
  var fetchOptions = {
    method: options.method || 'GET',
    headers: fetchHeaders,
    mode: options.mode || 'cors',
    credentials: options.credentials || 'same-origin',
    cache: options.cache || 'default',
    redirect: options.redirect || 'follow',
    referrer: options.referrer || 'client',
    signal: instance.controller.signal
  };
  fetch(fetchRequest, fetchOptions).then(function (response) {
    // store response reference
    instance.response = response;
    var progressAvailable = true;
    if (!response.body) {
      // ReadableStream is not yet supported in this browser
      // see https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
      progressAvailable = false;
    }

    // Server must send CORS header "Access-Control-Expose-Headers: content-length"
    var contentLength = response.headers.get('content-length');
    if (contentLength === null) {
      // Content-Length server response header missing.
      // Don't evaluate download progress if we can't compare against a total size
      // see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Access-Control-Expose-Headers
      progressAvailable = false;
    }
    if (!progressAvailable) {
      // not able to check download progress so skip it
      return response;
    }

    // fire progress event when during load
    instance.onProgress = function (e) {
      instance.fireEvent('progress', e);
    };
    return new Response(new ReadableStream(new ProgressHandler(instance, contentLength, response)), fetchOptions);
  }).then(function (response) {
    var errMsg;
    if (response.ok) {
      switch (responseType) {
        case 'arraybuffer':
          return response.arrayBuffer();
        case 'json':
          return response.json();
        case 'blob':
          return response.blob();
        case 'text':
          return response.text();
        default:
          errMsg = 'Unknown responseType: ' + responseType;
          break;
      }
    }
    if (!errMsg) {
      errMsg = 'HTTP error status: ' + response.status;
    }
    throw new Error(errMsg);
  }).then(function (response) {
    instance.fireEvent('success', response);
  }).catch(function (error) {
    instance.fireEvent('error', error);
  });

  // return the fetch request
  instance.fetchRequest = fetchRequest;
  return instance;
}
module.exports = exports.default;

/***/ }),

/***/ "./src/util/frame.js":
/*!***************************!*\
  !*** ./src/util/frame.js ***!
  \***************************/
/***/ ((module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = frame;
var _requestAnimationFrame = _interopRequireDefault(__webpack_require__(/*! ./request-animation-frame */ "./src/util/request-animation-frame.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Create a function which will be called at the next requestAnimationFrame
 * cycle
 *
 * @param {function} func The function to call
 *
 * @return {func} The function wrapped within a requestAnimationFrame
 */
function frame(func) {
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (0, _requestAnimationFrame.default)(function () {
      return func.apply(void 0, args);
    });
  };
}
module.exports = exports.default;

/***/ }),

/***/ "./src/util/get-id.js":
/*!****************************!*\
  !*** ./src/util/get-id.js ***!
  \****************************/
/***/ ((module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getId;
/**
 * Get a random prefixed ID
 *
 * @param {String} prefix Prefix to use. Default is `'wavesurfer_'`.
 * @returns {String} Random prefixed ID
 * @example
 * console.log(getId()); // logs 'wavesurfer_b5pors4ru6g'
 *
 * let prefix = 'foo-';
 * console.log(getId(prefix)); // logs 'foo-b5pors4ru6g'
 */
function getId(prefix) {
  if (prefix === undefined) {
    prefix = 'wavesurfer_';
  }
  return prefix + Math.random().toString(32).substring(2);
}
module.exports = exports.default;

/***/ }),

/***/ "./src/util/index.js":
/*!***************************!*\
  !*** ./src/util/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Observer", ({
  enumerable: true,
  get: function get() {
    return _observer.default;
  }
}));
Object.defineProperty(exports, "absMax", ({
  enumerable: true,
  get: function get() {
    return _absMax.default;
  }
}));
Object.defineProperty(exports, "clamp", ({
  enumerable: true,
  get: function get() {
    return _clamp.default;
  }
}));
Object.defineProperty(exports, "debounce", ({
  enumerable: true,
  get: function get() {
    return _debounce.default;
  }
}));
Object.defineProperty(exports, "fetchFile", ({
  enumerable: true,
  get: function get() {
    return _fetch.default;
  }
}));
Object.defineProperty(exports, "frame", ({
  enumerable: true,
  get: function get() {
    return _frame.default;
  }
}));
Object.defineProperty(exports, "getId", ({
  enumerable: true,
  get: function get() {
    return _getId.default;
  }
}));
Object.defineProperty(exports, "ignoreSilenceMode", ({
  enumerable: true,
  get: function get() {
    return _silenceMode.default;
  }
}));
Object.defineProperty(exports, "max", ({
  enumerable: true,
  get: function get() {
    return _max.default;
  }
}));
Object.defineProperty(exports, "min", ({
  enumerable: true,
  get: function get() {
    return _min.default;
  }
}));
Object.defineProperty(exports, "preventClick", ({
  enumerable: true,
  get: function get() {
    return _preventClick.default;
  }
}));
Object.defineProperty(exports, "requestAnimationFrame", ({
  enumerable: true,
  get: function get() {
    return _requestAnimationFrame.default;
  }
}));
Object.defineProperty(exports, "style", ({
  enumerable: true,
  get: function get() {
    return _style.default;
  }
}));
Object.defineProperty(exports, "withOrientation", ({
  enumerable: true,
  get: function get() {
    return _orientation.default;
  }
}));
var _getId = _interopRequireDefault(__webpack_require__(/*! ./get-id */ "./src/util/get-id.js"));
var _max = _interopRequireDefault(__webpack_require__(/*! ./max */ "./src/util/max.js"));
var _min = _interopRequireDefault(__webpack_require__(/*! ./min */ "./src/util/min.js"));
var _absMax = _interopRequireDefault(__webpack_require__(/*! ./absMax */ "./src/util/absMax.js"));
var _observer = _interopRequireDefault(__webpack_require__(/*! ./observer */ "./src/util/observer.js"));
var _style = _interopRequireDefault(__webpack_require__(/*! ./style */ "./src/util/style.js"));
var _requestAnimationFrame = _interopRequireDefault(__webpack_require__(/*! ./request-animation-frame */ "./src/util/request-animation-frame.js"));
var _frame = _interopRequireDefault(__webpack_require__(/*! ./frame */ "./src/util/frame.js"));
var _debounce = _interopRequireDefault(__webpack_require__(/*! debounce */ "./node_modules/debounce/index.js"));
var _preventClick = _interopRequireDefault(__webpack_require__(/*! ./prevent-click */ "./src/util/prevent-click.js"));
var _fetch = _interopRequireDefault(__webpack_require__(/*! ./fetch */ "./src/util/fetch.js"));
var _clamp = _interopRequireDefault(__webpack_require__(/*! ./clamp */ "./src/util/clamp.js"));
var _orientation = _interopRequireDefault(__webpack_require__(/*! ./orientation */ "./src/util/orientation.js"));
var _silenceMode = _interopRequireDefault(__webpack_require__(/*! ./silence-mode */ "./src/util/silence-mode.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./src/util/max.js":
/*!*************************!*\
  !*** ./src/util/max.js ***!
  \*************************/
/***/ ((module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = max;
/**
 * Get the largest value
 *
 * @param   {Array} values Array of numbers
 * @returns {Number} Largest number found
 * @example console.log(max([1, 2, 3])); // logs 3
 */
function max(values) {
  var largest = -Infinity;
  Object.keys(values).forEach(function (i) {
    if (values[i] > largest) {
      largest = values[i];
    }
  });
  return largest;
}
module.exports = exports.default;

/***/ }),

/***/ "./src/util/min.js":
/*!*************************!*\
  !*** ./src/util/min.js ***!
  \*************************/
/***/ ((module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = min;
/**
 * Get the smallest value
 *
 * @param   {Array} values Array of numbers
 * @returns {Number} Smallest number found
 * @example console.log(min([1, 2, 3])); // logs 1
 */
function min(values) {
  var smallest = Number(Infinity);
  Object.keys(values).forEach(function (i) {
    if (values[i] < smallest) {
      smallest = values[i];
    }
  });
  return smallest;
}
module.exports = exports.default;

/***/ }),

/***/ "./src/util/observer.js":
/*!******************************!*\
  !*** ./src/util/observer.js ***!
  \******************************/
/***/ ((module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
/**
 * @typedef {Object} ListenerDescriptor
 * @property {string} name The name of the event
 * @property {function} callback The callback
 * @property {function} un The function to call to remove the listener
 */
/**
 * Observer class
 */
var Observer = /*#__PURE__*/function () {
  /**
   * Instantiate Observer
   */
  function Observer() {
    _classCallCheck(this, Observer);
    /**
     * @private
     * @todo Initialise the handlers here already and remove the conditional
     * assignment in `on()`
     */
    this._disabledEventEmissions = [];
    this.handlers = null;
  }
  /**
   * Attach a handler function for an event.
   *
   * @param {string} event Name of the event to listen to
   * @param {function} fn The callback to trigger when the event is fired
   * @return {ListenerDescriptor} The event descriptor
   */
  _createClass(Observer, [{
    key: "on",
    value: function on(event, fn) {
      var _this = this;
      if (!this.handlers) {
        this.handlers = {};
      }
      var handlers = this.handlers[event];
      if (!handlers) {
        handlers = this.handlers[event] = [];
      }
      handlers.push(fn);

      // Return an event descriptor
      return {
        name: event,
        callback: fn,
        un: function un(e, fn) {
          return _this.un(e, fn);
        }
      };
    }

    /**
     * Remove an event handler.
     *
     * @param {string} event Name of the event the listener that should be
     * removed listens to
     * @param {function} fn The callback that should be removed
     */
  }, {
    key: "un",
    value: function un(event, fn) {
      if (!this.handlers) {
        return;
      }
      var handlers = this.handlers[event];
      var i;
      if (handlers) {
        if (fn) {
          for (i = handlers.length - 1; i >= 0; i--) {
            if (handlers[i] == fn) {
              handlers.splice(i, 1);
            }
          }
        } else {
          handlers.length = 0;
        }
      }
    }

    /**
     * Remove all event handlers.
     */
  }, {
    key: "unAll",
    value: function unAll() {
      this.handlers = null;
    }

    /**
     * Attach a handler to an event. The handler is executed at most once per
     * event type.
     *
     * @param {string} event The event to listen to
     * @param {function} handler The callback that is only to be called once
     * @return {ListenerDescriptor} The event descriptor
     */
  }, {
    key: "once",
    value: function once(event, handler) {
      var _this2 = this;
      var fn = function fn() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        /*  eslint-disable no-invalid-this */
        handler.apply(_this2, args);
        /*  eslint-enable no-invalid-this */
        setTimeout(function () {
          _this2.un(event, fn);
        }, 0);
      };
      return this.on(event, fn);
    }

    /**
     * Disable firing a list of events by name. When specified, event handlers for any event type
     * passed in here will not be called.
     *
     * @since 4.0.0
     * @param {string[]} eventNames an array of event names to disable emissions for
     * @example
     * // disable seek and interaction events
     * wavesurfer.setDisabledEventEmissions(['seek', 'interaction']);
     */
  }, {
    key: "setDisabledEventEmissions",
    value: function setDisabledEventEmissions(eventNames) {
      this._disabledEventEmissions = eventNames;
    }

    /**
     * plugins borrow part of this class without calling the constructor,
     * so we have to be careful about _disabledEventEmissions
     */
  }, {
    key: "_isDisabledEventEmission",
    value: function _isDisabledEventEmission(event) {
      return this._disabledEventEmissions && this._disabledEventEmissions.includes(event);
    }

    /**
     * Manually fire an event
     *
     * @param {string} event The event to fire manually
     * @param {...any} args The arguments with which to call the listeners
     */
  }, {
    key: "fireEvent",
    value: function fireEvent(event) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      if (!this.handlers || this._isDisabledEventEmission(event)) {
        return;
      }
      var handlers = this.handlers[event];
      handlers && handlers.forEach(function (fn) {
        fn.apply(void 0, args);
      });
    }
  }]);
  return Observer;
}();
exports["default"] = Observer;
module.exports = exports.default;

/***/ }),

/***/ "./src/util/orientation.js":
/*!*********************************!*\
  !*** ./src/util/orientation.js ***!
  \*********************************/
/***/ ((module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = withOrientation;
var verticalPropMap = {
  width: 'height',
  height: 'width',
  overflowX: 'overflowY',
  overflowY: 'overflowX',
  clientWidth: 'clientHeight',
  clientHeight: 'clientWidth',
  clientX: 'clientY',
  clientY: 'clientX',
  scrollWidth: 'scrollHeight',
  scrollLeft: 'scrollTop',
  offsetLeft: 'offsetTop',
  offsetTop: 'offsetLeft',
  offsetHeight: 'offsetWidth',
  offsetWidth: 'offsetHeight',
  left: 'top',
  right: 'bottom',
  top: 'left',
  bottom: 'right',
  borderRightStyle: 'borderBottomStyle',
  borderRightWidth: 'borderBottomWidth',
  borderRightColor: 'borderBottomColor'
};

/**
 * Convert a horizontally-oriented property name to a vertical one.
 *
 * @param {string} prop A property name
 * @param {bool} vertical Whether the element is oriented vertically
 * @returns {string} prop, converted appropriately
 */
function mapProp(prop, vertical) {
  if (Object.prototype.hasOwnProperty.call(verticalPropMap, prop)) {
    return vertical ? verticalPropMap[prop] : prop;
  } else {
    return prop;
  }
}
var isProxy = Symbol("isProxy");

/**
 * Returns an appropriately oriented object based on vertical.
 * If vertical is true, attribute getting and setting will be mapped through
 * verticalPropMap, so that e.g. getting the object's .width will give its
 * .height instead.
 * Certain methods of an oriented object will return oriented objects as well.
 * Oriented objects can't be added to the DOM directly since they are Proxy objects
 * and thus fail typechecks. Use domElement to get the actual element for this.
 *
 * @param {object} target The object to be wrapped and oriented
 * @param {bool} vertical Whether the element is oriented vertically
 * @returns {Proxy} An oriented object with attr translation via verticalAttrMap
 * @since 5.0.0
 */
function withOrientation(target, vertical) {
  if (target[isProxy]) {
    return target;
  } else {
    return new Proxy(target, {
      get: function get(obj, prop, receiver) {
        if (prop === isProxy) {
          return true;
        } else if (prop === 'domElement') {
          return obj;
        } else if (prop === 'style') {
          return withOrientation(obj.style, vertical);
        } else if (prop === 'canvas') {
          return withOrientation(obj.canvas, vertical);
        } else if (prop === 'getBoundingClientRect') {
          return function () {
            return withOrientation(obj.getBoundingClientRect.apply(obj, arguments), vertical);
          };
        } else if (prop === 'getContext') {
          return function () {
            return withOrientation(obj.getContext.apply(obj, arguments), vertical);
          };
        } else {
          var value = obj[mapProp(prop, vertical)];
          return typeof value == 'function' ? value.bind(obj) : value;
        }
      },
      set: function set(obj, prop, value) {
        obj[mapProp(prop, vertical)] = value;
        return true;
      }
    });
  }
}
module.exports = exports.default;

/***/ }),

/***/ "./src/util/prevent-click.js":
/*!***********************************!*\
  !*** ./src/util/prevent-click.js ***!
  \***********************************/
/***/ ((module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = preventClick;
/**
 * Stops propagation of click event and removes event listener
 *
 * @private
 * @param {object} event The click event
 */
function preventClickHandler(event) {
  event.stopPropagation();
  document.body.removeEventListener('click', preventClickHandler, true);
}

/**
 * Starts listening for click event and prevent propagation
 *
 * @param {object} values Values
 */
function preventClick(values) {
  document.body.addEventListener('click', preventClickHandler, true);
}
module.exports = exports.default;

/***/ }),

/***/ "./src/util/request-animation-frame.js":
/*!*********************************************!*\
  !*** ./src/util/request-animation-frame.js ***!
  \*********************************************/
/***/ ((module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/* eslint-disable valid-jsdoc */
/**
 * Returns the `requestAnimationFrame` function for the browser, or a shim with
 * `setTimeout` if the function is not found
 *
 * @return {function} Available `requestAnimationFrame` function for the browser
 */
var _default = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback, element) {
  return setTimeout(callback, 1000 / 60);
}).bind(window);
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ "./src/util/silence-mode.js":
/*!**********************************!*\
  !*** ./src/util/silence-mode.js ***!
  \**********************************/
/***/ ((module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = ignoreSilenceMode;
/**
 * Ignores device silence mode when using the `WebAudio` backend.
 *
 * Many mobile devices contain a hardware button to mute the ringtone for incoming
 * calls and messages. Unfortunately, on some platforms like iOS, this also mutes
 * wavesurfer's audio when using the `WebAudio` backend. This function creates a
 * temporary `<audio>` element that makes sure the WebAudio backend keeps playing
 * when muting the device ringer.
 *
 * @since 5.2.0
 */
function ignoreSilenceMode() {
  // Set the src to a short bit of url encoded as a silent mp3
  // NOTE The silence MP3 must be high quality, when web audio sounds are played
  // in parallel the web audio sound is mixed to match the bitrate of the html sound
  // 0.01 seconds of silence VBR220-260 Joint Stereo 859B
  var audioData = "data:audio/mpeg;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA//////////////////////////////////////////////////////////////////8AAABhTEFNRTMuMTAwA8MAAAAAAAAAABQgJAUHQQAB9AAAAnGMHkkIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQxAADgnABGiAAQBCqgCRMAAgEAH///////////////7+n/9FTuQsQH//////2NG0jWUGlio5gLQTOtIoeR2WX////X4s9Atb/JRVCbBUpeRUq//////////////////9RUi0f2jn/+xDECgPCjAEQAABN4AAANIAAAAQVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==";

  // disable iOS Airplay (setting the attribute in js doesn't work)
  var tmp = document.createElement("div");
  tmp.innerHTML = '<audio x-webkit-airplay="deny"></audio>';
  var audioSilentMode = tmp.children.item(0);
  audioSilentMode.src = audioData;
  audioSilentMode.preload = "auto";
  audioSilentMode.type = "audio/mpeg";
  audioSilentMode.disableRemotePlayback = true;

  // play
  audioSilentMode.play();

  // cleanup
  audioSilentMode.remove();
  tmp.remove();
}
module.exports = exports.default;

/***/ }),

/***/ "./src/util/style.js":
/*!***************************!*\
  !*** ./src/util/style.js ***!
  \***************************/
/***/ ((module, exports) => {


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = style;
/**
 * Apply a map of styles to an element
 *
 * @param {HTMLElement} el The element that the styles will be applied to
 * @param {Object} styles The map of propName: attribute, both are used as-is
 *
 * @return {HTMLElement} el
 */
function style(el, styles) {
  Object.keys(styles).forEach(function (prop) {
    if (el.style[prop] !== styles[prop]) {
      el.style[prop] = styles[prop];
    }
  });
  return el;
}
module.exports = exports.default;

/***/ }),

/***/ "./src/wavesurfer.js":
/*!***************************!*\
  !*** ./src/wavesurfer.js ***!
  \***************************/
/***/ ((module, exports, __webpack_require__) => {


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));
var _drawer = _interopRequireDefault(__webpack_require__(/*! ./drawer.multicanvas */ "./src/drawer.multicanvas.js"));
var _webaudio = _interopRequireDefault(__webpack_require__(/*! ./webaudio */ "./src/webaudio.js"));
var _mediaelement = _interopRequireDefault(__webpack_require__(/*! ./mediaelement */ "./src/mediaelement.js"));
var _peakcache = _interopRequireDefault(__webpack_require__(/*! ./peakcache */ "./src/peakcache.js"));
var _mediaelementWebaudio = _interopRequireDefault(__webpack_require__(/*! ./mediaelement-webaudio */ "./src/mediaelement-webaudio.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
/**
 * WaveSurfer core library class
 *
 * @extends {Observer}
 * @example
 * const params = {
 *   container: '#waveform',
 *   waveColor: 'violet',
 *   progressColor: 'purple'
 * };
 *
 * // initialise like this
 * const wavesurfer = WaveSurfer.create(params);
 *
 * // or like this ...
 * const wavesurfer = new WaveSurfer(params);
 * wavesurfer.init();
 *
 * // load audio file
 * wavesurfer.load('example/media/demo.wav');
 */
var WaveSurfer = /*#__PURE__*/function (_util$Observer) {
  _inherits(WaveSurfer, _util$Observer);
  var _super = _createSuper(WaveSurfer);
  /**
   * Initialise wavesurfer instance
   *
   * @param {WavesurferParams} params Instantiation options for wavesurfer
   * @example
   * const wavesurfer = new WaveSurfer(params);
   * @returns {this} Wavesurfer instance
   */
  function WaveSurfer(params) {
    var _this;
    _classCallCheck(this, WaveSurfer);
    _this = _super.call(this);
    /**
     * Extract relevant parameters (or defaults)
     * @private
     */
    _defineProperty(_assertThisInitialized(_this), "defaultParams", {
      audioContext: null,
      audioScriptProcessor: null,
      audioRate: 1,
      autoCenter: true,
      autoCenterRate: 5,
      autoCenterImmediately: false,
      backend: 'WebAudio',
      backgroundColor: null,
      barHeight: 1,
      barRadius: 0,
      barGap: null,
      barMinHeight: null,
      container: null,
      cursorColor: '#333',
      cursorWidth: 1,
      dragSelection: true,
      drawingContextAttributes: {
        // Boolean that hints the user agent to reduce the latency
        // by desynchronizing the canvas paint cycle from the event
        // loop
        desynchronized: false
      },
      duration: null,
      fillParent: true,
      forceDecode: false,
      height: 128,
      hideScrollbar: false,
      hideCursor: false,
      ignoreSilenceMode: false,
      interact: true,
      loopSelection: true,
      maxCanvasWidth: 4000,
      mediaContainer: null,
      mediaControls: false,
      mediaType: 'audio',
      minPxPerSec: 20,
      normalize: false,
      partialRender: false,
      pixelRatio: window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI,
      plugins: [],
      progressColor: '#555',
      removeMediaElementOnDestroy: true,
      renderer: _drawer.default,
      responsive: false,
      rtl: false,
      scrollParent: false,
      skipLength: 2,
      splitChannels: false,
      splitChannelsOptions: {
        overlay: false,
        channelColors: {},
        filterChannels: [],
        relativeNormalization: false,
        splitDragSelection: false
      },
      vertical: false,
      waveColor: '#999',
      xhr: {}
    });
    _defineProperty(_assertThisInitialized(_this), "backends", {
      MediaElement: _mediaelement.default,
      WebAudio: _webaudio.default,
      MediaElementWebAudio: _mediaelementWebaudio.default
    });
    _defineProperty(_assertThisInitialized(_this), "util", util);
    _this.params = Object.assign({}, _this.defaultParams, params);
    _this.params.splitChannelsOptions = Object.assign({}, _this.defaultParams.splitChannelsOptions, params.splitChannelsOptions);
    /** @private */
    _this.container = 'string' == typeof params.container ? document.querySelector(_this.params.container) : _this.params.container;
    if (!_this.container) {
      throw new Error('Container element not found');
    }
    if (_this.params.mediaContainer == null) {
      /** @private */
      _this.mediaContainer = _this.container;
    } else if (typeof _this.params.mediaContainer == 'string') {
      /** @private */
      _this.mediaContainer = document.querySelector(_this.params.mediaContainer);
    } else {
      /** @private */
      _this.mediaContainer = _this.params.mediaContainer;
    }
    if (!_this.mediaContainer) {
      throw new Error('Media Container element not found');
    }
    if (_this.params.maxCanvasWidth <= 1) {
      throw new Error('maxCanvasWidth must be greater than 1');
    } else if (_this.params.maxCanvasWidth % 2 == 1) {
      throw new Error('maxCanvasWidth must be an even number');
    }
    if (_this.params.rtl === true) {
      if (_this.params.vertical === true) {
        util.style(_this.container, {
          transform: 'rotateX(180deg)'
        });
      } else {
        util.style(_this.container, {
          transform: 'rotateY(180deg)'
        });
      }
    }
    if (_this.params.backgroundColor) {
      _this.setBackgroundColor(_this.params.backgroundColor);
    }

    /**
     * @private Used to save the current volume when muting so we can
     * restore once unmuted
     * @type {number}
     */
    _this.savedVolume = 0;

    /**
     * @private The current muted state
     * @type {boolean}
     */
    _this.isMuted = false;

    /**
     * @private Will hold a list of event descriptors that need to be
     * canceled on subsequent loads of audio
     * @type {Object[]}
     */
    _this.tmpEvents = [];

    /**
     * @private Holds any running audio downloads
     * @type {Observer}
     */
    _this.currentRequest = null;
    /** @private */
    _this.arraybuffer = null;
    /** @private */
    _this.drawer = null;
    /** @private */
    _this.backend = null;
    /** @private */
    _this.peakCache = null;

    // cache constructor objects
    if (typeof _this.params.renderer !== 'function') {
      throw new Error('Renderer parameter is invalid');
    }
    /**
     * @private The uninitialised Drawer class
     */
    _this.Drawer = _this.params.renderer;
    /**
     * @private The uninitialised Backend class
     */
    // Back compat
    if (_this.params.backend == 'AudioElement') {
      _this.params.backend = 'MediaElement';
    }
    if ((_this.params.backend == 'WebAudio' || _this.params.backend === 'MediaElementWebAudio') && !_webaudio.default.prototype.supportsWebAudio.call(null)) {
      _this.params.backend = 'MediaElement';
    }
    _this.Backend = _this.backends[_this.params.backend];

    /**
     * @private map of plugin names that are currently initialised
     */
    _this.initialisedPluginList = {};
    /** @private */
    _this.isDestroyed = false;

    /**
     * Get the current ready status.
     *
     * @example const isReady = wavesurfer.isReady;
     * @return {boolean}
     */
    _this.isReady = false;

    // responsive debounced event listener. If this.params.responsive is not
    // set, this is never called. Use 100ms or this.params.responsive as
    // timeout for the debounce function.
    var prevWidth = 0;
    _this._onResize = util.debounce(function () {
      if (_this.drawer.wrapper && prevWidth != _this.drawer.wrapper.clientWidth && !_this.params.scrollParent) {
        prevWidth = _this.drawer.wrapper.clientWidth;
        if (prevWidth) {
          // redraw only if waveform container is rendered and has a width
          _this.drawer.fireEvent('redraw');
        }
      }
    }, typeof _this.params.responsive === 'number' ? _this.params.responsive : 100);
    return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
  }

  /**
   * Initialise the wave
   *
   * @example
   * var wavesurfer = new WaveSurfer(params);
   * wavesurfer.init();
   * @return {this} The wavesurfer instance
   */
  _createClass(WaveSurfer, [{
    key: "init",
    value: function init() {
      this.registerPlugins(this.params.plugins);
      this.createDrawer();
      this.createBackend();
      this.createPeakCache();
      return this;
    }

    /**
     * Add and initialise array of plugins (if `plugin.deferInit` is falsey),
     * this function is called in the init function of wavesurfer
     *
     * @param {PluginDefinition[]} plugins An array of plugin definitions
     * @emits {WaveSurfer#plugins-registered} Called with the array of plugin definitions
     * @return {this} The wavesurfer instance
     */
  }, {
    key: "registerPlugins",
    value: function registerPlugins(plugins) {
      var _this2 = this;
      // first instantiate all the plugins
      plugins.forEach(function (plugin) {
        return _this2.addPlugin(plugin);
      });

      // now run the init functions
      plugins.forEach(function (plugin) {
        // call init function of the plugin if deferInit is falsey
        // in that case you would manually use initPlugins()
        if (!plugin.deferInit) {
          _this2.initPlugin(plugin.name);
        }
      });
      this.fireEvent('plugins-registered', plugins);
      return this;
    }

    /**
     * Get a map of plugin names that are currently initialised
     *
     * @example wavesurfer.getPlugins();
     * @return {Object} Object with plugin names
     */
  }, {
    key: "getActivePlugins",
    value: function getActivePlugins() {
      return this.initialisedPluginList;
    }

    /**
     * Add a plugin object to wavesurfer
     *
     * @param {PluginDefinition} plugin A plugin definition
     * @emits {WaveSurfer#plugin-added} Called with the name of the plugin that was added
     * @example wavesurfer.addPlugin(WaveSurfer.minimap());
     * @return {this} The wavesurfer instance
     */
  }, {
    key: "addPlugin",
    value: function addPlugin(plugin) {
      var _this3 = this;
      if (!plugin.name) {
        throw new Error('Plugin does not have a name!');
      }
      if (!plugin.instance) {
        throw new Error("Plugin ".concat(plugin.name, " does not have an instance property!"));
      }

      // staticProps properties are applied to wavesurfer instance
      if (plugin.staticProps) {
        Object.keys(plugin.staticProps).forEach(function (pluginStaticProp) {
          /**
           * Properties defined in a plugin definition's `staticProps` property are added as
           * staticProps properties of the WaveSurfer instance
           */
          _this3[pluginStaticProp] = plugin.staticProps[pluginStaticProp];
        });
      }
      var Instance = plugin.instance;

      // turn the plugin instance into an observer
      var observerPrototypeKeys = Object.getOwnPropertyNames(util.Observer.prototype);
      observerPrototypeKeys.forEach(function (key) {
        Instance.prototype[key] = util.Observer.prototype[key];
      });

      /**
       * Instantiated plugin classes are added as a property of the wavesurfer
       * instance
       * @type {Object}
       */
      this[plugin.name] = new Instance(plugin.params || {}, this);
      this.fireEvent('plugin-added', plugin.name);
      return this;
    }

    /**
     * Initialise a plugin
     *
     * @param {string} name A plugin name
     * @emits WaveSurfer#plugin-initialised
     * @example wavesurfer.initPlugin('minimap');
     * @return {this} The wavesurfer instance
     */
  }, {
    key: "initPlugin",
    value: function initPlugin(name) {
      if (!this[name]) {
        throw new Error("Plugin ".concat(name, " has not been added yet!"));
      }
      if (this.initialisedPluginList[name]) {
        // destroy any already initialised plugins
        this.destroyPlugin(name);
      }
      this[name].init();
      this.initialisedPluginList[name] = true;
      this.fireEvent('plugin-initialised', name);
      return this;
    }

    /**
     * Destroy a plugin
     *
     * @param {string} name A plugin name
     * @emits WaveSurfer#plugin-destroyed
     * @example wavesurfer.destroyPlugin('minimap');
     * @returns {this} The wavesurfer instance
     */
  }, {
    key: "destroyPlugin",
    value: function destroyPlugin(name) {
      if (!this[name]) {
        throw new Error("Plugin ".concat(name, " has not been added yet and cannot be destroyed!"));
      }
      if (!this.initialisedPluginList[name]) {
        throw new Error("Plugin ".concat(name, " is not active and cannot be destroyed!"));
      }
      if (typeof this[name].destroy !== 'function') {
        throw new Error("Plugin ".concat(name, " does not have a destroy function!"));
      }
      this[name].destroy();
      delete this.initialisedPluginList[name];
      this.fireEvent('plugin-destroyed', name);
      return this;
    }

    /**
     * Destroy all initialised plugins. Convenience function to use when
     * wavesurfer is removed
     *
     * @private
     */
  }, {
    key: "destroyAllPlugins",
    value: function destroyAllPlugins() {
      var _this4 = this;
      Object.keys(this.initialisedPluginList).forEach(function (name) {
        return _this4.destroyPlugin(name);
      });
    }

    /**
     * Create the drawer and draw the waveform
     *
     * @private
     * @emits WaveSurfer#drawer-created
     */
  }, {
    key: "createDrawer",
    value: function createDrawer() {
      var _this5 = this;
      this.drawer = new this.Drawer(this.container, this.params);
      this.drawer.init();
      this.fireEvent('drawer-created', this.drawer);
      if (this.params.responsive !== false) {
        window.addEventListener('resize', this._onResize, true);
        window.addEventListener('orientationchange', this._onResize, true);
      }
      this.drawer.on('redraw', function () {
        _this5.drawBuffer();
        _this5.drawer.progress(_this5.backend.getPlayedPercents());
      });

      // Click-to-seek
      this.drawer.on('click', function (e, progress) {
        setTimeout(function () {
          return _this5.seekTo(progress);
        }, 0);
      });

      // Relay the scroll event from the drawer
      this.drawer.on('scroll', function (e) {
        if (_this5.params.partialRender) {
          _this5.drawBuffer();
        }
        _this5.fireEvent('scroll', e);
      });
    }

    /**
     * Create the backend
     *
     * @private
     * @emits WaveSurfer#backend-created
     */
  }, {
    key: "createBackend",
    value: function createBackend() {
      var _this6 = this;
      if (this.backend) {
        this.backend.destroy();
      }
      this.backend = new this.Backend(this.params);
      this.backend.init();
      this.fireEvent('backend-created', this.backend);
      this.backend.on('finish', function () {
        _this6.drawer.progress(_this6.backend.getPlayedPercents());
        _this6.fireEvent('finish');
      });
      this.backend.on('play', function () {
        return _this6.fireEvent('play');
      });
      this.backend.on('pause', function () {
        return _this6.fireEvent('pause');
      });
      this.backend.on('audioprocess', function (time) {
        _this6.drawer.progress(_this6.backend.getPlayedPercents());
        _this6.fireEvent('audioprocess', time);
      });

      // only needed for MediaElement and MediaElementWebAudio backend
      if (this.params.backend === 'MediaElement' || this.params.backend === 'MediaElementWebAudio') {
        this.backend.on('seek', function () {
          _this6.drawer.progress(_this6.backend.getPlayedPercents());
        });
        this.backend.on('volume', function () {
          var newVolume = _this6.getVolume();
          _this6.fireEvent('volume', newVolume);
          if (_this6.backend.isMuted !== _this6.isMuted) {
            _this6.isMuted = _this6.backend.isMuted;
            _this6.fireEvent('mute', _this6.isMuted);
          }
        });
      }
    }

    /**
     * Create the peak cache
     *
     * @private
     */
  }, {
    key: "createPeakCache",
    value: function createPeakCache() {
      if (this.params.partialRender) {
        this.peakCache = new _peakcache.default();
      }
    }

    /**
     * Get the duration of the audio clip
     *
     * @example const duration = wavesurfer.getDuration();
     * @return {number} Duration in seconds
     */
  }, {
    key: "getDuration",
    value: function getDuration() {
      return this.backend.getDuration();
    }

    /**
     * Get the current playback position
     *
     * @example const currentTime = wavesurfer.getCurrentTime();
     * @return {number} Playback position in seconds
     */
  }, {
    key: "getCurrentTime",
    value: function getCurrentTime() {
      return this.backend.getCurrentTime();
    }

    /**
     * Set the current play time in seconds.
     *
     * @param {number} seconds A positive number in seconds. E.g. 10 means 10
     * seconds, 60 means 1 minute
     */
  }, {
    key: "setCurrentTime",
    value: function setCurrentTime(seconds) {
      if (seconds >= this.getDuration()) {
        this.seekTo(1);
      } else {
        this.seekTo(seconds / this.getDuration());
      }
    }

    /**
     * Starts playback from the current position. Optional start and end
     * measured in seconds can be used to set the range of audio to play.
     *
     * @param {?number} start Position to start at
     * @param {?number} end Position to end at
     * @emits WaveSurfer#interaction
     * @return {Promise} Result of the backend play method
     * @example
     * // play from second 1 to 5
     * wavesurfer.play(1, 5);
     */
  }, {
    key: "play",
    value: function play(start, end) {
      var _this7 = this;
      if (this.params.ignoreSilenceMode) {
        // ignores device hardware silence mode
        util.ignoreSilenceMode();
      }
      this.fireEvent('interaction', function () {
        return _this7.play(start, end);
      });
      return this.backend.play(start, end);
    }

    /**
     * Set a point in seconds for playback to stop at.
     *
     * @param {number} position Position (in seconds) to stop at
     * @version 3.3.0
     */
  }, {
    key: "setPlayEnd",
    value: function setPlayEnd(position) {
      this.backend.setPlayEnd(position);
    }

    /**
     * Stops and pauses playback
     *
     * @example wavesurfer.pause();
     * @return {Promise} Result of the backend pause method
     */
  }, {
    key: "pause",
    value: function pause() {
      if (!this.backend.isPaused()) {
        return this.backend.pause();
      }
    }

    /**
     * Toggle playback
     *
     * @example wavesurfer.playPause();
     * @return {Promise} Result of the backend play or pause method
     */
  }, {
    key: "playPause",
    value: function playPause() {
      return this.backend.isPaused() ? this.play() : this.pause();
    }

    /**
     * Get the current playback state
     *
     * @example const isPlaying = wavesurfer.isPlaying();
     * @return {boolean} False if paused, true if playing
     */
  }, {
    key: "isPlaying",
    value: function isPlaying() {
      return !this.backend.isPaused();
    }

    /**
     * Skip backward
     *
     * @param {?number} seconds Amount to skip back, if not specified `skipLength`
     * is used
     * @example wavesurfer.skipBackward();
     */
  }, {
    key: "skipBackward",
    value: function skipBackward(seconds) {
      this.skip(-seconds || -this.params.skipLength);
    }

    /**
     * Skip forward
     *
     * @param {?number} seconds Amount to skip back, if not specified `skipLength`
     * is used
     * @example wavesurfer.skipForward();
     */
  }, {
    key: "skipForward",
    value: function skipForward(seconds) {
      this.skip(seconds || this.params.skipLength);
    }

    /**
     * Skip a number of seconds from the current position (use a negative value
     * to go backwards).
     *
     * @param {number} offset Amount to skip back or forwards
     * @example
     * // go back 2 seconds
     * wavesurfer.skip(-2);
     */
  }, {
    key: "skip",
    value: function skip(offset) {
      var duration = this.getDuration() || 1;
      var position = this.getCurrentTime() || 0;
      position = Math.max(0, Math.min(duration, position + (offset || 0)));
      this.seekAndCenter(position / duration);
    }

    /**
     * Seeks to a position and centers the view
     *
     * @param {number} progress Between 0 (=beginning) and 1 (=end)
     * @example
     * // seek and go to the middle of the audio
     * wavesurfer.seekTo(0.5);
     */
  }, {
    key: "seekAndCenter",
    value: function seekAndCenter(progress) {
      this.seekTo(progress);
      this.drawer.recenter(progress);
    }

    /**
     * Seeks to a position
     *
     * @param {number} progress Between 0 (=beginning) and 1 (=end)
     * @emits WaveSurfer#interaction
     * @emits WaveSurfer#seek
     * @example
     * // seek to the middle of the audio
     * wavesurfer.seekTo(0.5);
     */
  }, {
    key: "seekTo",
    value: function seekTo(progress) {
      var _this8 = this;
      // return an error if progress is not a number between 0 and 1
      if (typeof progress !== 'number' || !isFinite(progress) || progress < 0 || progress > 1) {
        throw new Error('Error calling wavesurfer.seekTo, parameter must be a number between 0 and 1!');
      }
      this.fireEvent('interaction', function () {
        return _this8.seekTo(progress);
      });
      var isWebAudioBackend = this.params.backend === 'WebAudio';
      var paused = this.backend.isPaused();
      if (isWebAudioBackend && !paused) {
        this.backend.pause();
      }

      // avoid small scrolls while paused seeking
      var oldScrollParent = this.params.scrollParent;
      this.params.scrollParent = false;
      this.backend.seekTo(progress * this.getDuration());
      this.drawer.progress(progress);
      if (isWebAudioBackend && !paused) {
        this.backend.play();
      }
      this.params.scrollParent = oldScrollParent;
      this.fireEvent('seek', progress);
    }

    /**
     * Stops and goes to the beginning.
     *
     * @example wavesurfer.stop();
     */
  }, {
    key: "stop",
    value: function stop() {
      this.pause();
      this.seekTo(0);
      this.drawer.progress(0);
    }

    /**
     * Sets the ID of the audio device to use for output and returns a Promise.
     *
     * @param {string} deviceId String value representing underlying output
     * device
     * @returns {Promise} `Promise` that resolves to `undefined` when there are
     * no errors detected.
     */
  }, {
    key: "setSinkId",
    value: function setSinkId(deviceId) {
      return this.backend.setSinkId(deviceId);
    }

    /**
     * Set the playback volume.
     *
     * @param {number} newVolume A value between 0 and 1, 0 being no
     * volume and 1 being full volume.
     * @emits WaveSurfer#volume
     */
  }, {
    key: "setVolume",
    value: function setVolume(newVolume) {
      this.backend.setVolume(newVolume);
      this.fireEvent('volume', newVolume);
    }

    /**
     * Get the playback volume.
     *
     * @return {number} A value between 0 and 1, 0 being no
     * volume and 1 being full volume.
     */
  }, {
    key: "getVolume",
    value: function getVolume() {
      return this.backend.getVolume();
    }

    /**
     * Set the playback rate.
     *
     * @param {number} rate A positive number. E.g. 0.5 means half the normal
     * speed, 2 means double speed and so on.
     * @example wavesurfer.setPlaybackRate(2);
     */
  }, {
    key: "setPlaybackRate",
    value: function setPlaybackRate(rate) {
      this.backend.setPlaybackRate(rate);
    }

    /**
     * Get the playback rate.
     *
     * @return {number} The current playback rate.
     */
  }, {
    key: "getPlaybackRate",
    value: function getPlaybackRate() {
      return this.backend.getPlaybackRate();
    }

    /**
     * Toggle the volume on and off. If not currently muted it will save the
     * current volume value and turn the volume off. If currently muted then it
     * will restore the volume to the saved value, and then rest the saved
     * value.
     *
     * @example wavesurfer.toggleMute();
     */
  }, {
    key: "toggleMute",
    value: function toggleMute() {
      this.setMute(!this.isMuted);
    }

    /**
     * Enable or disable muted audio
     *
     * @param {boolean} mute Specify `true` to mute audio.
     * @emits WaveSurfer#volume
     * @emits WaveSurfer#mute
     * @example
     * // unmute
     * wavesurfer.setMute(false);
     * console.log(wavesurfer.getMute()) // logs false
     */
  }, {
    key: "setMute",
    value: function setMute(mute) {
      // ignore all muting requests if the audio is already in that state
      if (mute === this.isMuted) {
        this.fireEvent('mute', this.isMuted);
        return;
      }
      if (this.backend.setMute) {
        // Backends such as the MediaElement backend have their own handling
        // of mute, let them handle it.
        this.backend.setMute(mute);
        this.isMuted = mute;
      } else {
        if (mute) {
          // If currently not muted then save current volume,
          // turn off the volume and update the mute properties
          this.savedVolume = this.backend.getVolume();
          this.backend.setVolume(0);
          this.isMuted = true;
          this.fireEvent('volume', 0);
        } else {
          // If currently muted then restore to the saved volume
          // and update the mute properties
          this.backend.setVolume(this.savedVolume);
          this.isMuted = false;
          this.fireEvent('volume', this.savedVolume);
        }
      }
      this.fireEvent('mute', this.isMuted);
    }

    /**
     * Get the current mute status.
     *
     * @example const isMuted = wavesurfer.getMute();
     * @return {boolean} Current mute status
     */
  }, {
    key: "getMute",
    value: function getMute() {
      return this.isMuted;
    }

    /**
     * Get the list of current set filters as an array.
     *
     * Filters must be set with setFilters method first
     *
     * @return {array} List of enabled filters
     */
  }, {
    key: "getFilters",
    value: function getFilters() {
      return this.backend.filters || [];
    }

    /**
     * Toggles `scrollParent` and redraws
     *
     * @example wavesurfer.toggleScroll();
     */
  }, {
    key: "toggleScroll",
    value: function toggleScroll() {
      this.params.scrollParent = !this.params.scrollParent;
      this.drawBuffer();
    }

    /**
     * Toggle mouse interaction
     *
     * @example wavesurfer.toggleInteraction();
     */
  }, {
    key: "toggleInteraction",
    value: function toggleInteraction() {
      this.params.interact = !this.params.interact;
    }

    /**
     * Get the fill color of the waveform after the cursor.
     *
     * @param {?number} channelIdx Optional index of the channel to get its wave color if splitChannels is true
     * @return {string|object} A CSS color string, or an array of CSS color strings.
     */
  }, {
    key: "getWaveColor",
    value: function getWaveColor() {
      var channelIdx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (this.params.splitChannelsOptions.channelColors[channelIdx]) {
        return this.params.splitChannelsOptions.channelColors[channelIdx].waveColor;
      }
      return this.params.waveColor;
    }

    /**
     * Set the fill color of the waveform after the cursor.
     *
     * @param {string|object} color A CSS color string, or an array of CSS color strings.
     * @param {?number} channelIdx Optional index of the channel to set its wave color if splitChannels is true
     * @example wavesurfer.setWaveColor('#ddd');
     */
  }, {
    key: "setWaveColor",
    value: function setWaveColor(color) {
      var channelIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (this.params.splitChannelsOptions.channelColors[channelIdx]) {
        this.params.splitChannelsOptions.channelColors[channelIdx].waveColor = color;
      } else {
        this.params.waveColor = color;
      }
      this.drawBuffer();
    }

    /**
     * Get the fill color of the waveform behind the cursor.
     *
     * @param {?number} channelIdx Optional index of the channel to get its progress color if splitChannels is true
     * @return {string|object} A CSS color string, or an array of CSS color strings.
     */
  }, {
    key: "getProgressColor",
    value: function getProgressColor() {
      var channelIdx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (this.params.splitChannelsOptions.channelColors[channelIdx]) {
        return this.params.splitChannelsOptions.channelColors[channelIdx].progressColor;
      }
      return this.params.progressColor;
    }

    /**
     * Set the fill color of the waveform behind the cursor.
     *
     * @param {string|object} color A CSS color string, or an array of CSS color strings.
     * @param {?number} channelIdx Optional index of the channel to set its progress color if splitChannels is true
     * @example wavesurfer.setProgressColor('#400');
     */
  }, {
    key: "setProgressColor",
    value: function setProgressColor(color, channelIdx) {
      if (this.params.splitChannelsOptions.channelColors[channelIdx]) {
        this.params.splitChannelsOptions.channelColors[channelIdx].progressColor = color;
      } else {
        this.params.progressColor = color;
      }
      this.drawBuffer();
    }

    /**
     * Get the background color of the waveform container.
     *
     * @return {string} A CSS color string.
     */
  }, {
    key: "getBackgroundColor",
    value: function getBackgroundColor() {
      return this.params.backgroundColor;
    }

    /**
     * Set the background color of the waveform container.
     *
     * @param {string} color A CSS color string.
     * @example wavesurfer.setBackgroundColor('#FF00FF');
     */
  }, {
    key: "setBackgroundColor",
    value: function setBackgroundColor(color) {
      this.params.backgroundColor = color;
      util.style(this.container, {
        background: this.params.backgroundColor
      });
    }

    /**
     * Get the fill color of the cursor indicating the playhead
     * position.
     *
     * @return {string} A CSS color string.
     */
  }, {
    key: "getCursorColor",
    value: function getCursorColor() {
      return this.params.cursorColor;
    }

    /**
     * Set the fill color of the cursor indicating the playhead
     * position.
     *
     * @param {string} color A CSS color string.
     * @example wavesurfer.setCursorColor('#222');
     */
  }, {
    key: "setCursorColor",
    value: function setCursorColor(color) {
      this.params.cursorColor = color;
      this.drawer.updateCursor();
    }

    /**
     * Get the height of the waveform.
     *
     * @return {number} Height measured in pixels.
     */
  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.params.height;
    }

    /**
     * Set the height of the waveform.
     *
     * @param {number} height Height measured in pixels.
     * @example wavesurfer.setHeight(200);
     */
  }, {
    key: "setHeight",
    value: function setHeight(height) {
      this.params.height = height;
      this.drawer.setHeight(height * this.params.pixelRatio);
      this.drawBuffer();
    }

    /**
     * Hide channels from being drawn on the waveform if splitting channels.
     *
     * For example, if we want to draw only the peaks for the right stereo channel:
     *
     * const wavesurfer = new WaveSurfer.create({...splitChannels: true});
     * wavesurfer.load('stereo_audio.mp3');
     *
     * wavesurfer.setFilteredChannel([0]); <-- hide left channel peaks.
     *
     * @param {array} channelIndices Channels to be filtered out from drawing.
     * @version 4.0.0
     */
  }, {
    key: "setFilteredChannels",
    value: function setFilteredChannels(channelIndices) {
      this.params.splitChannelsOptions.filterChannels = channelIndices;
      this.drawBuffer();
    }

    /**
     * Get the correct peaks for current wave view-port and render wave
     *
     * @private
     * @emits WaveSurfer#redraw
     */
  }, {
    key: "drawBuffer",
    value: function drawBuffer() {
      var nominalWidth = Math.round(this.getDuration() * this.params.minPxPerSec * this.params.pixelRatio);
      var parentWidth = this.drawer.getWidth();
      var width = nominalWidth;
      // always start at 0 after zooming for scrolling : issue redraw left part
      var start = 0;
      var end = Math.max(start + parentWidth, width);
      // Fill container
      if (this.params.fillParent && (!this.params.scrollParent || nominalWidth < parentWidth)) {
        width = parentWidth;
        start = 0;
        end = width;
      }
      var peaks;
      if (this.params.partialRender) {
        var newRanges = this.peakCache.addRangeToPeakCache(width, start, end);
        var i;
        for (i = 0; i < newRanges.length; i++) {
          peaks = this.backend.getPeaks(width, newRanges[i][0], newRanges[i][1]);
          this.drawer.drawPeaks(peaks, width, newRanges[i][0], newRanges[i][1]);
        }
      } else {
        peaks = this.backend.getPeaks(width, start, end);
        this.drawer.drawPeaks(peaks, width, start, end);
      }
      this.fireEvent('redraw', peaks, width);
    }

    /**
     * Horizontally zooms the waveform in and out. It also changes the parameter
     * `minPxPerSec` and enables the `scrollParent` option. Calling the function
     * with a falsey parameter will reset the zoom state.
     *
     * @param {?number} pxPerSec Number of horizontal pixels per second of
     * audio, if none is set the waveform returns to unzoomed state
     * @emits WaveSurfer#zoom
     * @example wavesurfer.zoom(20);
     */
  }, {
    key: "zoom",
    value: function zoom(pxPerSec) {
      if (!pxPerSec) {
        this.params.minPxPerSec = this.defaultParams.minPxPerSec;
        this.params.scrollParent = false;
      } else {
        this.params.minPxPerSec = pxPerSec;
        this.params.scrollParent = true;
      }
      this.drawBuffer();
      this.drawer.progress(this.backend.getPlayedPercents());
      this.drawer.recenter(this.getCurrentTime() / this.getDuration());
      this.fireEvent('zoom', pxPerSec);
    }

    /**
     * Decode buffer and load
     *
     * @private
     * @param {ArrayBuffer} arraybuffer Buffer to process
     */
  }, {
    key: "loadArrayBuffer",
    value: function loadArrayBuffer(arraybuffer) {
      var _this9 = this;
      this.decodeArrayBuffer(arraybuffer, function (data) {
        if (!_this9.isDestroyed) {
          _this9.loadDecodedBuffer(data);
        }
      });
    }

    /**
     * Directly load an externally decoded AudioBuffer
     *
     * @private
     * @param {AudioBuffer} buffer Buffer to process
     * @emits WaveSurfer#ready
     */
  }, {
    key: "loadDecodedBuffer",
    value: function loadDecodedBuffer(buffer) {
      this.backend.load(buffer);
      this.drawBuffer();
      this.isReady = true;
      this.fireEvent('ready');
    }

    /**
     * Loads audio data from a Blob or File object
     *
     * @param {Blob|File} blob Audio data
     * @example
     */
  }, {
    key: "loadBlob",
    value: function loadBlob(blob) {
      var _this10 = this;
      // Create file reader
      var reader = new FileReader();
      reader.addEventListener('progress', function (e) {
        return _this10.onProgress(e);
      });
      reader.addEventListener('load', function (e) {
        return _this10.loadArrayBuffer(e.target.result);
      });
      reader.addEventListener('error', function () {
        return _this10.fireEvent('error', 'Error reading file');
      });
      reader.readAsArrayBuffer(blob);
      this.empty();
    }

    /**
     * Loads audio and re-renders the waveform.
     *
     * @param {string|HTMLMediaElement} url The url of the audio file or the
     * audio element with the audio
     * @param {number[]|Number.<Array[]>} peaks Wavesurfer does not have to decode
     * the audio to render the waveform if this is specified
     * @param {?string} preload (Use with backend `MediaElement` and `MediaElementWebAudio`)
     * `'none'|'metadata'|'auto'` Preload attribute for the media element
     * @param {?number} duration The duration of the audio. This is used to
     * render the peaks data in the correct size for the audio duration (as
     * befits the current `minPxPerSec` and zoom value) without having to decode
     * the audio.
     * @returns {void}
     * @throws Will throw an error if the `url` argument is empty.
     * @example
     * // uses fetch or media element to load file (depending on backend)
     * wavesurfer.load('http://example.com/demo.wav');
     *
     * // setting preload attribute with media element backend and supplying
     * // peaks
     * wavesurfer.load(
     *   'http://example.com/demo.wav',
     *   [0.0218, 0.0183, 0.0165, 0.0198, 0.2137, 0.2888],
     *   true
     * );
     */
  }, {
    key: "load",
    value: function load(url, peaks, preload, duration) {
      if (!url) {
        throw new Error('url parameter cannot be empty');
      }
      this.empty();
      if (preload) {
        // check whether the preload attribute will be usable and if not log
        // a warning listing the reasons why not and nullify the variable
        var preloadIgnoreReasons = {
          "Preload is not 'auto', 'none' or 'metadata'": ['auto', 'metadata', 'none'].indexOf(preload) === -1,
          'Peaks are not provided': !peaks,
          "Backend is not of type 'MediaElement' or 'MediaElementWebAudio'": ['MediaElement', 'MediaElementWebAudio'].indexOf(this.params.backend) === -1,
          'Url is not of type string': typeof url !== 'string'
        };
        var activeReasons = Object.keys(preloadIgnoreReasons).filter(function (reason) {
          return preloadIgnoreReasons[reason];
        });
        if (activeReasons.length) {
          // eslint-disable-next-line no-console
          console.warn('Preload parameter of wavesurfer.load will be ignored because:\n\t- ' + activeReasons.join('\n\t- '));
          // stop invalid values from being used
          preload = null;
        }
      }

      // loadBuffer(url, peaks, duration) requires that url is a string
      // but users can pass in a HTMLMediaElement to WaveSurfer
      if (this.params.backend === 'WebAudio' && url instanceof HTMLMediaElement) {
        url = url.src;
      }
      switch (this.params.backend) {
        case 'WebAudio':
          return this.loadBuffer(url, peaks, duration);
        case 'MediaElement':
        case 'MediaElementWebAudio':
          return this.loadMediaElement(url, peaks, preload, duration);
      }
    }

    /**
     * Loads audio using Web Audio buffer backend.
     *
     * @private
     * @emits WaveSurfer#waveform-ready
     * @param {string} url URL of audio file
     * @param {number[]|Number.<Array[]>} peaks Peaks data
     * @param {?number} duration Optional duration of audio file
     * @returns {void}
     */
  }, {
    key: "loadBuffer",
    value: function loadBuffer(url, peaks, duration) {
      var _this11 = this;
      var load = function load(action) {
        if (action) {
          _this11.tmpEvents.push(_this11.once('ready', action));
        }
        return _this11.getArrayBuffer(url, function (data) {
          return _this11.loadArrayBuffer(data);
        });
      };
      if (peaks) {
        this.backend.setPeaks(peaks, duration);
        this.drawBuffer();
        this.fireEvent('waveform-ready');
        this.tmpEvents.push(this.once('interaction', load));
      } else {
        return load();
      }
    }

    /**
     * Either create a media element, or load an existing media element.
     *
     * @private
     * @emits WaveSurfer#waveform-ready
     * @param {string|HTMLMediaElement} urlOrElt Either a path to a media file, or an
     * existing HTML5 Audio/Video Element
     * @param {number[]|Number.<Array[]>} peaks Array of peaks. Required to bypass web audio
     * dependency
     * @param {?boolean} preload Set to true if the preload attribute of the
     * audio element should be enabled
     * @param {?number} duration Optional duration of audio file
     */
  }, {
    key: "loadMediaElement",
    value: function loadMediaElement(urlOrElt, peaks, preload, duration) {
      var _this12 = this;
      var url = urlOrElt;
      if (typeof urlOrElt === 'string') {
        this.backend.load(url, this.mediaContainer, peaks, preload);
      } else {
        var elt = urlOrElt;
        this.backend.loadElt(elt, peaks);

        // If peaks are not provided,
        // url = element.src so we can get peaks with web audio
        url = elt.src;
      }
      this.tmpEvents.push(this.backend.once('canplay', function () {
        // ignore when backend was already destroyed
        if (!_this12.backend.destroyed) {
          _this12.drawBuffer();
          _this12.isReady = true;
          _this12.fireEvent('ready');
        }
      }), this.backend.once('error', function (err) {
        return _this12.fireEvent('error', err);
      }));

      // If peaks are provided, render them and fire the `waveform-ready` event.
      if (peaks) {
        this.backend.setPeaks(peaks, duration);
        this.drawBuffer();
        this.fireEvent('waveform-ready');
      }

      // If no pre-decoded peaks are provided, or are provided with
      // forceDecode flag, attempt to download the audio file and decode it
      // with Web Audio.
      if ((!peaks || this.params.forceDecode) && this.backend.supportsWebAudio()) {
        this.getArrayBuffer(url, function (arraybuffer) {
          _this12.decodeArrayBuffer(arraybuffer, function (buffer) {
            _this12.backend.buffer = buffer;
            _this12.backend.setPeaks(null);
            _this12.drawBuffer();
            _this12.fireEvent('waveform-ready');
          });
        });
      }
    }

    /**
     * Decode an array buffer and pass data to a callback
     *
     * @private
     * @param {Object} arraybuffer The array buffer to decode
     * @param {function} callback The function to call on complete
     */
  }, {
    key: "decodeArrayBuffer",
    value: function decodeArrayBuffer(arraybuffer, callback) {
      var _this13 = this;
      if (!this.isDestroyed) {
        this.arraybuffer = arraybuffer;
        this.backend.decodeArrayBuffer(arraybuffer, function (data) {
          // Only use the decoded data if we haven't been destroyed or
          // another decode started in the meantime
          if (!_this13.isDestroyed && _this13.arraybuffer == arraybuffer) {
            callback(data);
            _this13.arraybuffer = null;
          }
        }, function () {
          return _this13.fireEvent('error', 'Error decoding audiobuffer');
        });
      }
    }

    /**
     * Load an array buffer using fetch and pass the result to a callback
     *
     * @param {string} url The URL of the file object
     * @param {function} callback The function to call on complete
     * @returns {util.fetchFile} fetch call
     * @private
     */
  }, {
    key: "getArrayBuffer",
    value: function getArrayBuffer(url, callback) {
      var _this14 = this;
      var options = Object.assign({
        url: url,
        responseType: 'arraybuffer'
      }, this.params.xhr);
      var request = util.fetchFile(options);
      this.currentRequest = request;
      this.tmpEvents.push(request.on('progress', function (e) {
        _this14.onProgress(e);
      }), request.on('success', function (data) {
        callback(data);
        _this14.currentRequest = null;
      }), request.on('error', function (e) {
        _this14.fireEvent('error', e);
        _this14.currentRequest = null;
      }));
      return request;
    }

    /**
     * Called while the audio file is loading
     *
     * @private
     * @param {Event} e Progress event
     * @emits WaveSurfer#loading
     */
  }, {
    key: "onProgress",
    value: function onProgress(e) {
      var percentComplete;
      if (e.lengthComputable) {
        percentComplete = e.loaded / e.total;
      } else {
        // Approximate progress with an asymptotic
        // function, and assume downloads in the 1-3 MB range.
        percentComplete = e.loaded / (e.loaded + 1000000);
      }
      this.fireEvent('loading', Math.round(percentComplete * 100), e.target);
    }

    /**
     * Exports PCM data into a JSON array and optionally opens in a new window
     * as valid JSON Blob instance.
     *
     * @param {number} length=1024 The scale in which to export the peaks
     * @param {number} accuracy=10000
     * @param {?boolean} noWindow Set to true to disable opening a new
     * window with the JSON
     * @param {number} start Start index
     * @param {number} end End index
     * @return {Promise} Promise that resolves with array of peaks
     */
  }, {
    key: "exportPCM",
    value: function exportPCM(length, accuracy, noWindow, start, end) {
      length = length || 1024;
      start = start || 0;
      accuracy = accuracy || 10000;
      noWindow = noWindow || false;
      var peaks = this.backend.getPeaks(length, start, end);
      var arr = [].map.call(peaks, function (val) {
        return Math.round(val * accuracy) / accuracy;
      });
      return new Promise(function (resolve, reject) {
        if (!noWindow) {
          var blobJSON = new Blob([JSON.stringify(arr)], {
            type: 'application/json;charset=utf-8'
          });
          var objURL = URL.createObjectURL(blobJSON);
          window.open(objURL);
          URL.revokeObjectURL(objURL);
        }
        resolve(arr);
      });
    }

    /**
     * Save waveform image as data URI.
     *
     * The default format is `image/png`. Other supported types are
     * `image/jpeg` and `image/webp`.
     *
     * @param {string} format='image/png' A string indicating the image format.
     * The default format type is `image/png`.
     * @param {number} quality=1 A number between 0 and 1 indicating the image
     * quality to use for image formats that use lossy compression such as
     * `image/jpeg` and `image/webp`.
     * @param {string} type Image data type to return. Either `dataURL` (default)
     * or `blob`.
     * @return {string|string[]|Promise} When using `dataURL` type this returns
     * a single data URL or an array of data URLs, one for each canvas. When using
     * `blob` type this returns a `Promise` resolving with an array of `Blob`
     * instances, one for each canvas.
     */
  }, {
    key: "exportImage",
    value: function exportImage(format, quality, type) {
      if (!format) {
        format = 'image/png';
      }
      if (!quality) {
        quality = 1;
      }
      if (!type) {
        type = 'dataURL';
      }
      return this.drawer.getImage(format, quality, type);
    }

    /**
     * Cancel any fetch request currently in progress
     */
  }, {
    key: "cancelAjax",
    value: function cancelAjax() {
      if (this.currentRequest && this.currentRequest.controller) {
        // If the current request has a ProgressHandler, then its ReadableStream might need to be cancelled too
        // See: Wavesurfer issue #2042
        // See Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1583815
        if (this.currentRequest._reader) {
          // Ignoring exceptions thrown by call to cancel()
          this.currentRequest._reader.cancel().catch(function (err) {});
        }
        this.currentRequest.controller.abort();
        this.currentRequest = null;
      }
    }

    /**
     * @private
     */
  }, {
    key: "clearTmpEvents",
    value: function clearTmpEvents() {
      this.tmpEvents.forEach(function (e) {
        return e.un();
      });
    }

    /**
     * Display empty waveform.
     */
  }, {
    key: "empty",
    value: function empty() {
      if (!this.backend.isPaused()) {
        this.stop();
        this.backend.disconnectSource();
      }
      this.isReady = false;
      this.cancelAjax();
      this.clearTmpEvents();

      // empty drawer
      this.drawer.progress(0);
      this.drawer.setWidth(0);
      this.drawer.drawPeaks({
        length: this.drawer.getWidth()
      }, 0);
    }

    /**
     * Remove events, elements and disconnect WebAudio nodes.
     *
     * @emits WaveSurfer#destroy
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyAllPlugins();
      this.fireEvent('destroy');
      this.cancelAjax();
      this.clearTmpEvents();
      this.unAll();
      if (this.params.responsive !== false) {
        window.removeEventListener('resize', this._onResize, true);
        window.removeEventListener('orientationchange', this._onResize, true);
      }
      if (this.backend) {
        this.backend.destroy();
        // clears memory usage
        this.backend = null;
      }
      if (this.drawer) {
        this.drawer.destroy();
      }
      this.isDestroyed = true;
      this.isReady = false;
      this.arraybuffer = null;
    }
  }], [{
    key: "create",
    value: /** @private */

    /** @private */

    /**
     * Instantiate this class, call its `init` function and returns it
     *
     * @param {WavesurferParams} params The wavesurfer parameters
     * @return {Object} WaveSurfer instance
     * @example const wavesurfer = WaveSurfer.create(params);
     */
    function create(params) {
      var wavesurfer = new WaveSurfer(params);
      return wavesurfer.init();
    }

    /**
     * The library version number is available as a static property of the
     * WaveSurfer class
     *
     * @type {String}
     * @example
     * console.log('Using wavesurfer.js ' + WaveSurfer.VERSION);
     */
  }]);
  return WaveSurfer;
}(util.Observer);
exports["default"] = WaveSurfer;
_defineProperty(WaveSurfer, "VERSION", "6.4.0");
_defineProperty(WaveSurfer, "util", util);
module.exports = exports.default;

/***/ }),

/***/ "./src/webaudio.js":
/*!*************************!*\
  !*** ./src/webaudio.js ***!
  \*************************/
/***/ ((module, exports, __webpack_require__) => {


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./src/util/index.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// using constants to prevent someone writing the string wrong
var PLAYING = 'playing';
var PAUSED = 'paused';
var FINISHED = 'finished';

/**
 * WebAudio backend
 *
 * @extends {Observer}
 */
var WebAudio = /*#__PURE__*/function (_util$Observer) {
  _inherits(WebAudio, _util$Observer);
  var _super = _createSuper(WebAudio);
  /**
   * Construct the backend
   *
   * @param {WavesurferParams} params Wavesurfer parameters
   */
  function WebAudio(params) {
    var _defineProperty2, _this$states;
    var _this;
    _classCallCheck(this, WebAudio);
    _this = _super.call(this);
    /** @private */
    _defineProperty(_assertThisInitialized(_this), "audioContext", null);
    _defineProperty(_assertThisInitialized(_this), "offlineAudioContext", null);
    _defineProperty(_assertThisInitialized(_this), "stateBehaviors", (_defineProperty2 = {}, _defineProperty(_defineProperty2, PLAYING, {
      init: function init() {
        this.addOnAudioProcess();
      },
      getPlayedPercents: function getPlayedPercents() {
        var duration = this.getDuration();
        return this.getCurrentTime() / duration || 0;
      },
      getCurrentTime: function getCurrentTime() {
        return this.startPosition + this.getPlayedTime();
      }
    }), _defineProperty(_defineProperty2, PAUSED, {
      init: function init() {
        this.removeOnAudioProcess();
      },
      getPlayedPercents: function getPlayedPercents() {
        var duration = this.getDuration();
        return this.getCurrentTime() / duration || 0;
      },
      getCurrentTime: function getCurrentTime() {
        return this.startPosition;
      }
    }), _defineProperty(_defineProperty2, FINISHED, {
      init: function init() {
        this.removeOnAudioProcess();
        this.fireEvent('finish');
      },
      getPlayedPercents: function getPlayedPercents() {
        return 1;
      },
      getCurrentTime: function getCurrentTime() {
        return this.getDuration();
      }
    }), _defineProperty2));
    _this.params = params;
    /** ac: Audio Context instance */
    _this.ac = params.audioContext || (_this.supportsWebAudio() ? _this.getAudioContext() : {});
    /**@private */
    _this.lastPlay = _this.ac.currentTime;
    /** @private */
    _this.startPosition = 0;
    /** @private */
    _this.scheduledPause = null;
    /** @private */
    _this.states = (_this$states = {}, _defineProperty(_this$states, PLAYING, Object.create(_this.stateBehaviors[PLAYING])), _defineProperty(_this$states, PAUSED, Object.create(_this.stateBehaviors[PAUSED])), _defineProperty(_this$states, FINISHED, Object.create(_this.stateBehaviors[FINISHED])), _this$states);
    /** @private */
    _this.buffer = null;
    /** @private */
    _this.filters = [];
    /** gainNode: allows to control audio volume */
    _this.gainNode = null;
    /** @private */
    _this.mergedPeaks = null;
    /** @private */
    _this.offlineAc = null;
    /** @private */
    _this.peaks = null;
    /** @private */
    _this.playbackRate = 1;
    /** analyser: provides audio analysis information */
    _this.analyser = null;
    /** scriptNode: allows processing audio */
    _this.scriptNode = null;
    /** @private */
    _this.source = null;
    /** @private */
    _this.splitPeaks = [];
    /** @private */
    _this.state = null;
    /** @private */
    _this.explicitDuration = params.duration;
    /** @private */
    _this.sinkStreamDestination = null;
    /** @private */
    _this.sinkAudioElement = null;
    /**
     * Boolean indicating if the backend was destroyed.
     */
    _this.destroyed = false;
    return _this;
  }

  /**
   * Initialise the backend, called in `wavesurfer.createBackend()`
   */
  _createClass(WebAudio, [{
    key: "supportsWebAudio",
    value: /** scriptBufferSize: size of the processing buffer */

    /** audioContext: allows to process audio with WebAudio API */

    /** @private */

    /** @private */

    /**
     * Does the browser support this backend
     *
     * @return {boolean} Whether or not this browser supports this backend
     */
    function supportsWebAudio() {
      return !!(window.AudioContext || window.webkitAudioContext);
    }

    /**
     * Get the audio context used by this backend or create one
     *
     * @return {AudioContext} Existing audio context, or creates a new one
     */
  }, {
    key: "getAudioContext",
    value: function getAudioContext() {
      if (!window.WaveSurferAudioContext) {
        window.WaveSurferAudioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return window.WaveSurferAudioContext;
    }

    /**
     * Get the offline audio context used by this backend or create one
     *
     * @param {number} sampleRate The sample rate to use
     * @return {OfflineAudioContext} Existing offline audio context, or creates
     * a new one
     */
  }, {
    key: "getOfflineAudioContext",
    value: function getOfflineAudioContext(sampleRate) {
      if (!window.WaveSurferOfflineAudioContext) {
        window.WaveSurferOfflineAudioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 2, sampleRate);
      }
      return window.WaveSurferOfflineAudioContext;
    }
  }, {
    key: "init",
    value: function init() {
      this.createVolumeNode();
      this.createScriptNode();
      this.createAnalyserNode();
      this.setState(PAUSED);
      this.setPlaybackRate(this.params.audioRate);
      this.setLength(0);
    }

    /** @private */
  }, {
    key: "disconnectFilters",
    value: function disconnectFilters() {
      if (this.filters) {
        this.filters.forEach(function (filter) {
          filter && filter.disconnect();
        });
        this.filters = null;
        // Reconnect direct path
        this.analyser.connect(this.gainNode);
      }
    }

    /**
     * @private
     *
     * @param {string} state The new state
     */
  }, {
    key: "setState",
    value: function setState(state) {
      if (this.state !== this.states[state]) {
        this.state = this.states[state];
        this.state.init.call(this);
      }
    }

    /**
     * Unpacked `setFilters()`
     *
     * @param {...AudioNode} filters One or more filters to set
     */
  }, {
    key: "setFilter",
    value: function setFilter() {
      for (var _len = arguments.length, filters = new Array(_len), _key = 0; _key < _len; _key++) {
        filters[_key] = arguments[_key];
      }
      this.setFilters(filters);
    }

    /**
     * Insert custom Web Audio nodes into the graph
     *
     * @param {AudioNode[]} filters Packed filters array
     * @example
     * const lowpass = wavesurfer.backend.ac.createBiquadFilter();
     * wavesurfer.backend.setFilter(lowpass);
     */
  }, {
    key: "setFilters",
    value: function setFilters(filters) {
      // Remove existing filters
      this.disconnectFilters();

      // Insert filters if filter array not empty
      if (filters && filters.length) {
        this.filters = filters;

        // Disconnect direct path before inserting filters
        this.analyser.disconnect();

        // Connect each filter in turn
        filters.reduce(function (prev, curr) {
          prev.connect(curr);
          return curr;
        }, this.analyser).connect(this.gainNode);
      }
    }
    /** Create ScriptProcessorNode to process audio */
  }, {
    key: "createScriptNode",
    value: function createScriptNode() {
      if (this.params.audioScriptProcessor) {
        this.scriptNode = this.params.audioScriptProcessor;
      } else {
        if (this.ac.createScriptProcessor) {
          this.scriptNode = this.ac.createScriptProcessor(WebAudio.scriptBufferSize);
        } else {
          this.scriptNode = this.ac.createJavaScriptNode(WebAudio.scriptBufferSize);
        }
      }
      this.scriptNode.connect(this.ac.destination);
    }

    /** @private */
  }, {
    key: "addOnAudioProcess",
    value: function addOnAudioProcess() {
      var _this2 = this;
      this.scriptNode.onaudioprocess = function () {
        var time = _this2.getCurrentTime();
        if (time >= _this2.getDuration()) {
          _this2.setState(FINISHED);
          _this2.fireEvent('pause');
        } else if (time >= _this2.scheduledPause) {
          _this2.pause();
        } else if (_this2.state === _this2.states[PLAYING]) {
          _this2.fireEvent('audioprocess', time);
        }
      };
    }

    /** @private */
  }, {
    key: "removeOnAudioProcess",
    value: function removeOnAudioProcess() {
      this.scriptNode.onaudioprocess = null;
    }
    /** Create analyser node to perform audio analysis */
  }, {
    key: "createAnalyserNode",
    value: function createAnalyserNode() {
      this.analyser = this.ac.createAnalyser();
      this.analyser.connect(this.gainNode);
    }

    /**
     * Create the gain node needed to control the playback volume.
     *
     */
  }, {
    key: "createVolumeNode",
    value: function createVolumeNode() {
      // Create gain node using the AudioContext
      if (this.ac.createGain) {
        this.gainNode = this.ac.createGain();
      } else {
        this.gainNode = this.ac.createGainNode();
      }
      // Add the gain node to the graph
      this.gainNode.connect(this.ac.destination);
    }

    /**
     * Set the sink id for the media player
     *
     * @param {string} deviceId String value representing audio device id.
     * @returns {Promise} A Promise that resolves to `undefined` when there
     * are no errors.
     */
  }, {
    key: "setSinkId",
    value: function setSinkId(deviceId) {
      if (deviceId) {
        /**
         * The webaudio API doesn't currently support setting the device
         * output. Here we create an HTMLAudioElement, connect the
         * webaudio stream to that element and setSinkId there.
         */
        if (!this.sinkAudioElement) {
          this.sinkAudioElement = new window.Audio();
          // autoplay is necessary since we're not invoking .play()
          this.sinkAudioElement.autoplay = true;
        }
        if (!this.sinkAudioElement.setSinkId) {
          return Promise.reject(new Error('setSinkId is not supported in your browser'));
        }
        if (!this.sinkStreamDestination) {
          this.sinkStreamDestination = this.ac.createMediaStreamDestination();
        }
        this.gainNode.disconnect();
        this.gainNode.connect(this.sinkStreamDestination);
        this.sinkAudioElement.srcObject = this.sinkStreamDestination.stream;
        return this.sinkAudioElement.setSinkId(deviceId);
      } else {
        return Promise.reject(new Error('Invalid deviceId: ' + deviceId));
      }
    }

    /**
     * Set the audio volume
     *
     * @param {number} value A floating point value between 0 and 1.
     */
  }, {
    key: "setVolume",
    value: function setVolume(value) {
      this.gainNode.gain.setValueAtTime(value, this.ac.currentTime);
    }

    /**
     * Get the current volume
     *
     * @return {number} value A floating point value between 0 and 1.
     */
  }, {
    key: "getVolume",
    value: function getVolume() {
      return this.gainNode.gain.value;
    }

    /**
     * Decode an array buffer and pass data to a callback
     *
     * @private
     * @param {ArrayBuffer} arraybuffer The array buffer to decode
     * @param {function} callback The function to call on complete.
     * @param {function} errback The function to call on error.
     */
  }, {
    key: "decodeArrayBuffer",
    value: function decodeArrayBuffer(arraybuffer, callback, errback) {
      if (!this.offlineAc) {
        this.offlineAc = this.getOfflineAudioContext(this.ac && this.ac.sampleRate ? this.ac.sampleRate : 44100);
      }
      if ('webkitAudioContext' in window) {
        // Safari: no support for Promise-based decodeAudioData enabled
        // Enable it in Safari using the Experimental Features > Modern WebAudio API option
        this.offlineAc.decodeAudioData(arraybuffer, function (data) {
          return callback(data);
        }, errback);
      } else {
        this.offlineAc.decodeAudioData(arraybuffer).then(function (data) {
          return callback(data);
        }).catch(function (err) {
          return errback(err);
        });
      }
    }

    /**
     * Set pre-decoded peaks
     *
     * @param {number[]|Number.<Array[]>} peaks Peaks data
     * @param {?number} duration Explicit duration
     */
  }, {
    key: "setPeaks",
    value: function setPeaks(peaks, duration) {
      if (duration != null) {
        this.explicitDuration = duration;
      }
      this.peaks = peaks;
    }

    /**
     * Set the rendered length (different from the length of the audio)
     *
     * @param {number} length The rendered length
     */
  }, {
    key: "setLength",
    value: function setLength(length) {
      // No resize, we can preserve the cached peaks.
      if (this.mergedPeaks && length == 2 * this.mergedPeaks.length - 1 + 2) {
        return;
      }
      this.splitPeaks = [];
      this.mergedPeaks = [];
      // Set the last element of the sparse array so the peak arrays are
      // appropriately sized for other calculations.
      var channels = this.buffer ? this.buffer.numberOfChannels : 1;
      var c;
      for (c = 0; c < channels; c++) {
        this.splitPeaks[c] = [];
        this.splitPeaks[c][2 * (length - 1)] = 0;
        this.splitPeaks[c][2 * (length - 1) + 1] = 0;
      }
      this.mergedPeaks[2 * (length - 1)] = 0;
      this.mergedPeaks[2 * (length - 1) + 1] = 0;
    }

    /**
     * Compute the max and min value of the waveform when broken into <length> subranges.
     *
     * @param {number} length How many subranges to break the waveform into.
     * @param {number} first First sample in the required range.
     * @param {number} last Last sample in the required range.
     * @return {number[]|Number.<Array[]>} Array of 2*<length> peaks or array of arrays of
     * peaks consisting of (max, min) values for each subrange.
     */
  }, {
    key: "getPeaks",
    value: function getPeaks(length, first, last) {
      if (this.peaks) {
        return this.peaks;
      }
      if (!this.buffer) {
        return [];
      }
      first = first || 0;
      last = last || length - 1;
      this.setLength(length);
      if (!this.buffer) {
        return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
      }

      /**
       * The following snippet fixes a buffering data issue on the Safari
       * browser which returned undefined It creates the missing buffer based
       * on 1 channel, 4096 samples and the sampleRate from the current
       * webaudio context 4096 samples seemed to be the best fit for rendering
       * will review this code once a stable version of Safari TP is out
       */
      if (!this.buffer.length) {
        var newBuffer = this.createBuffer(1, 4096, this.sampleRate);
        this.buffer = newBuffer.buffer;
      }
      var sampleSize = this.buffer.length / length;
      var sampleStep = ~~(sampleSize / 10) || 1;
      var channels = this.buffer.numberOfChannels;
      var c;
      for (c = 0; c < channels; c++) {
        var peaks = this.splitPeaks[c];
        var chan = this.buffer.getChannelData(c);
        var i = void 0;
        for (i = first; i <= last; i++) {
          var start = ~~(i * sampleSize);
          var end = ~~(start + sampleSize);
          /**
           * Initialize the max and min to the first sample of this
           * subrange, so that even if the samples are entirely
           * on one side of zero, we still return the true max and
           * min values in the subrange.
           */
          var min = chan[start];
          var max = min;
          var j = void 0;
          for (j = start; j < end; j += sampleStep) {
            var value = chan[j];
            if (value > max) {
              max = value;
            }
            if (value < min) {
              min = value;
            }
          }
          peaks[2 * i] = max;
          peaks[2 * i + 1] = min;
          if (c == 0 || max > this.mergedPeaks[2 * i]) {
            this.mergedPeaks[2 * i] = max;
          }
          if (c == 0 || min < this.mergedPeaks[2 * i + 1]) {
            this.mergedPeaks[2 * i + 1] = min;
          }
        }
      }
      return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
    }

    /**
     * Get the position from 0 to 1
     *
     * @return {number} Position
     */
  }, {
    key: "getPlayedPercents",
    value: function getPlayedPercents() {
      return this.state.getPlayedPercents.call(this);
    }

    /** @private */
  }, {
    key: "disconnectSource",
    value: function disconnectSource() {
      if (this.source) {
        this.source.disconnect();
      }
    }
    /**
     * Destroy all references with WebAudio, disconnecting audio nodes and closing Audio Context
     */
  }, {
    key: "destroyWebAudio",
    value: function destroyWebAudio() {
      this.disconnectFilters();
      this.disconnectSource();
      this.gainNode.disconnect();
      this.scriptNode.disconnect();
      this.analyser.disconnect();

      // close the audioContext if closeAudioContext option is set to true
      if (this.params.closeAudioContext) {
        // check if browser supports AudioContext.close()
        if (typeof this.ac.close === 'function' && this.ac.state != 'closed') {
          this.ac.close();
        }
        // clear the reference to the audiocontext
        this.ac = null;
        // clear the actual audiocontext, either passed as param or the
        // global singleton
        if (!this.params.audioContext) {
          window.WaveSurferAudioContext = null;
        } else {
          this.params.audioContext = null;
        }
        // clear the offlineAudioContext
        window.WaveSurferOfflineAudioContext = null;
      }

      // disconnect resources used by setSinkId
      if (this.sinkStreamDestination) {
        this.sinkAudioElement.pause();
        this.sinkAudioElement.srcObject = null;
        this.sinkStreamDestination.disconnect();
        this.sinkStreamDestination = null;
      }
    }
    /**
     * This is called when wavesurfer is destroyed
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.isPaused()) {
        this.pause();
      }
      this.unAll();
      this.buffer = null;
      this.destroyed = true;
      this.destroyWebAudio();
    }

    /**
     * Loaded a decoded audio buffer
     *
     * @param {Object} buffer Decoded audio buffer to load
     */
  }, {
    key: "load",
    value: function load(buffer) {
      this.startPosition = 0;
      this.lastPlay = this.ac.currentTime;
      this.buffer = buffer;
      this.createSource();
    }

    /** @private */
  }, {
    key: "createSource",
    value: function createSource() {
      this.disconnectSource();
      this.source = this.ac.createBufferSource();

      // adjust for old browsers
      this.source.start = this.source.start || this.source.noteGrainOn;
      this.source.stop = this.source.stop || this.source.noteOff;
      this.setPlaybackRate(this.playbackRate);
      this.source.buffer = this.buffer;
      this.source.connect(this.analyser);
    }

    /**
     * @private
     *
     * some browsers require an explicit call to #resume before they will play back audio
     */
  }, {
    key: "resumeAudioContext",
    value: function resumeAudioContext() {
      if (this.ac.state == 'suspended') {
        this.ac.resume && this.ac.resume();
      }
    }

    /**
     * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
     *
     * @return {boolean} Whether or not this backend is currently paused
     */
  }, {
    key: "isPaused",
    value: function isPaused() {
      return this.state !== this.states[PLAYING];
    }

    /**
     * Used by `wavesurfer.getDuration()`
     *
     * @return {number} Duration of loaded buffer
     */
  }, {
    key: "getDuration",
    value: function getDuration() {
      if (this.explicitDuration) {
        return this.explicitDuration;
      }
      if (!this.buffer) {
        return 0;
      }
      return this.buffer.duration;
    }

    /**
     * Used by `wavesurfer.seekTo()`
     *
     * @param {number} start Position to start at in seconds
     * @param {number} end Position to end at in seconds
     * @return {{start: number, end: number}} Object containing start and end
     * positions
     */
  }, {
    key: "seekTo",
    value: function seekTo(start, end) {
      if (!this.buffer) {
        return;
      }
      this.scheduledPause = null;
      if (start == null) {
        start = this.getCurrentTime();
        if (start >= this.getDuration()) {
          start = 0;
        }
      }
      if (end == null) {
        end = this.getDuration();
      }
      this.startPosition = start;
      this.lastPlay = this.ac.currentTime;
      if (this.state === this.states[FINISHED]) {
        this.setState(PAUSED);
      }
      return {
        start: start,
        end: end
      };
    }

    /**
     * Get the playback position in seconds
     *
     * @return {number} The playback position in seconds
     */
  }, {
    key: "getPlayedTime",
    value: function getPlayedTime() {
      return (this.ac.currentTime - this.lastPlay) * this.playbackRate;
    }

    /**
     * Plays the loaded audio region.
     *
     * @param {number} start Start offset in seconds, relative to the beginning
     * of a clip.
     * @param {number} end When to stop relative to the beginning of a clip.
     */
  }, {
    key: "play",
    value: function play(start, end) {
      if (!this.buffer) {
        return;
      }

      // need to re-create source on each playback
      this.createSource();
      var adjustedTime = this.seekTo(start, end);
      start = adjustedTime.start;
      end = adjustedTime.end;
      this.scheduledPause = end;
      this.source.start(0, start);
      this.resumeAudioContext();
      this.setState(PLAYING);
      this.fireEvent('play');
    }

    /**
     * Pauses the loaded audio.
     */
  }, {
    key: "pause",
    value: function pause() {
      this.scheduledPause = null;
      this.startPosition += this.getPlayedTime();
      try {
        this.source && this.source.stop(0);
      } catch (err) {
        // Calling stop can throw the following 2 errors:
        // - RangeError (The value specified for when is negative.)
        // - InvalidStateNode (The node has not been started by calling start().)
        // We can safely ignore both errors, because:
        // - The range is surely correct
        // - The node might not have been started yet, in which case we just want to carry on without causing any trouble.
      }
      this.setState(PAUSED);
      this.fireEvent('pause');
    }

    /**
     * Returns the current time in seconds relative to the audio-clip's
     * duration.
     *
     * @return {number} The current time in seconds
     */
  }, {
    key: "getCurrentTime",
    value: function getCurrentTime() {
      return this.state.getCurrentTime.call(this);
    }

    /**
     * Returns the current playback rate. (0=no playback, 1=normal playback)
     *
     * @return {number} The current playback rate
     */
  }, {
    key: "getPlaybackRate",
    value: function getPlaybackRate() {
      return this.playbackRate;
    }

    /**
     * Set the audio source playback rate.
     *
     * @param {number} value The playback rate to use
     */
  }, {
    key: "setPlaybackRate",
    value: function setPlaybackRate(value) {
      this.playbackRate = value || 1;
      this.source && this.source.playbackRate.setValueAtTime(this.playbackRate, this.ac.currentTime);
    }

    /**
     * Set a point in seconds for playback to stop at.
     *
     * @param {number} end Position to end at
     * @version 3.3.0
     */
  }, {
    key: "setPlayEnd",
    value: function setPlayEnd(end) {
      this.scheduledPause = end;
    }
  }]);
  return WebAudio;
}(util.Observer);
exports["default"] = WebAudio;
_defineProperty(WebAudio, "scriptBufferSize", 256);
module.exports = exports.default;

/***/ }),

/***/ "./node_modules/debounce/index.js":
/*!****************************************!*\
  !*** ./node_modules/debounce/index.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing. The function also has a property 'clear' 
 * that is a function which will clear the timer to prevent previously scheduled executions. 
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */
function debounce(func, wait, immediate){
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;

  function later() {
    var last = Date.now() - timestamp;

    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  }
  var debounced = function(){
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };

  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  
  debounced.flush = function() {
    if (timeout) {
      result = func.apply(context, args);
      context = args = null;
      
      clearTimeout(timeout);
      timeout = null;
    }
  };

  return debounced;
}
// Adds compatibility for ES modules
debounce.debounce = debounce;

module.exports = debounce;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/wavesurfer.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=wavesurfer.js.map
});

var WaveSurfer = unwrapExports(wavesurfer);

var _circle$3, _path$M;

function _extends$P() {
  _extends$P = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$P.apply(this, arguments);
}

function SvgPlay(props) {
  return /*#__PURE__*/createElement("svg", _extends$P({
    width: 32,
    height: 32,
    viewBox: "0 0 33 33",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _circle$3 || (_circle$3 = /*#__PURE__*/createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#0DBD8B"
  })), _path$M || (_path$M = /*#__PURE__*/createElement("path", {
    d: "M21.652 15.022c.714.432.714 1.522 0 1.954l-7.438 4.498c-.708.428-1.589-.114-1.589-.977v-8.995c0-.864.88-1.405 1.589-.977l7.438 4.497z",
    fill: "#fff"
  })));
}

var _circle$4, _path$N;

function _extends$Q() {
  _extends$Q = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$Q.apply(this, arguments);
}

function SvgPause(props) {
  return /*#__PURE__*/createElement("svg", _extends$Q({
    width: 32,
    height: 32,
    viewBox: "0 0 33 33",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _circle$4 || (_circle$4 = /*#__PURE__*/createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "#0DBD8B"
  })), _path$N || (_path$N = /*#__PURE__*/createElement("path", {
    d: "M13.721 10.375c.401 0 .547.042.694.12a.818.818 0 01.34.34c.078.147.12.293.12.694v8.942c0 .401-.042.547-.12.694a.818.818 0 01-.34.34c-.147.078-.293.12-.694.12h-1.067c-.401 0-.547-.042-.694-.12a.818.818 0 01-.34-.34c-.078-.147-.12-.293-.12-.694V11.53c0-.401.042-.547.12-.694a.818.818 0 01.34-.34c.147-.078.293-.12.694-.12h1.067zm5.625 0c.401 0 .547.042.694.12a.818.818 0 01.34.34c.078.147.12.293.12.694v8.942c0 .401-.042.547-.12.694a.818.818 0 01-.34.34c-.147.078-.293.12-.694.12H18.28c-.401 0-.547-.042-.694-.12a.818.818 0 01-.34-.34c-.078-.147-.12-.293-.12-.694V11.53c0-.401.042-.547.12-.694a.818.818 0 01.34-.34c.147-.078.293-.12.694-.12h1.067z",
    fill: "#fff"
  })));
}

var playingAudioId = '';
var setPlayingAudioId = function setPlayingAudioId(attachmentId) {
  playingAudioId = attachmentId;
};
var getPlayingAudioId = function getPlayingAudioId() {
  return playingAudioId;
};

var _templateObject$l, _templateObject2$j, _templateObject3$f, _templateObject4$c, _templateObject5$8, _templateObject6$8;
var Container$b = styled.div(_templateObject$l || (_templateObject$l = _taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  align-items: flex-start;\n  width: 230px;\n  padding: 8px 12px;\n"])));
var PlayPause = styled.div(_templateObject2$j || (_templateObject2$j = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n\n  & > svg {\n    display: flex;\n    width: 40px;\n    height: 40px;\n  }\n"])));
var AudioVisualization = styled.div(_templateObject3$f || (_templateObject3$f = _taggedTemplateLiteralLoose(["\n  width: 100%;\n"])));
var AudioRate = styled.div(_templateObject4$c || (_templateObject4$c = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background-color: ", ";\n  width: 30px;\n  min-width: 30px;\n  border-radius: 12px;\n  font-weight: 600;\n  font-size: 12px;\n  line-height: 14px;\n  color: ", ";\n  height: 18px;\n  box-sizing: border-box;\n  margin-left: 14px;\n  cursor: pointer;\n\n  & > span {\n    margin-top: auto;\n    line-height: 16px;\n    font-size: 9px;\n  }\n"])), colors.white, colors.gray9);
var WaveContainer = styled.div(_templateObject5$8 || (_templateObject5$8 = _taggedTemplateLiteralLoose(["\n  width: 100%;\n  display: flex;\n  margin-left: 8px;\n"])));
var Timer = styled.div(_templateObject6$8 || (_templateObject6$8 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  left: 59px;\n  bottom: 12px;\n  display: inline-block;\n  font-weight: 400;\n  font-size: 11px;\n  line-height: 12px;\n  color: ", ";\n"])), colors.gray9);

var AudioPlayer = function AudioPlayer(_ref) {
  var url = _ref.url,
      file = _ref.file;
  var recordingInitialState = {
    recordingSeconds: 0,
    recordingMilliseconds: 0,
    initRecording: false,
    mediaStream: null,
    mediaRecorder: null,
    audio: undefined
  };

  var _useState = useState(recordingInitialState),
      recording = _useState[0],
      setRecording = _useState[1];

  var _useState2 = useState(false),
      isRendered = _useState2[0],
      setIsRendered = _useState2[1];

  var _useState3 = useState(false),
      playAudio = _useState3[0],
      setPlayAudio = _useState3[1];

  var _useState4 = useState(false),
      payingAudioId = _useState4[0],
      setPayingAudioId = _useState4[1];

  var _useState5 = useState(''),
      currentTime = _useState5[0],
      setCurrentTime = _useState5[1];

  var _useState6 = useState(1),
      audioRate = _useState6[0],
      setAudioRate = _useState6[1];

  var wavesurfer = useRef(null);
  var wavesurferContainer = useRef(null);
  var intervalRef = useRef(null);

  var handleSetAudioRate = function handleSetAudioRate() {
    if (audioRate === 1) {
      setAudioRate(1.5);
      wavesurfer.current.setPlaybackRate(1.5);
    } else if (audioRate === 1.5) {
      setAudioRate(2);
      wavesurfer.current.audioRate = 2;
      wavesurfer.current.setPlaybackRate(2);
    } else {
      setAudioRate(1);
      wavesurfer.current.audioRate = 1;
      wavesurfer.current.setPlaybackRate(1);
    }
  };

  var handlePlayPause = function handlePlayPause() {
    if (wavesurfer.current) {
      if (!wavesurfer.current.isPlaying()) {
        setPlayAudio(true);
        setPlayingAudioId(file.id);
        var audioDuration = wavesurfer.current.getDuration();
        intervalRef.current = setInterval(function () {
          setPayingAudioId(getPlayingAudioId());
          var currentTime = wavesurfer.current.getCurrentTime();

          if (currentTime >= 0) {
            setCurrentTime(formatAudioVideoTime(audioDuration, currentTime));
          }
        }, 10);
      } else {
        if (payingAudioId === file.id) {
          setPayingAudioId('');
        }
      }

      wavesurfer.current.playPause();
    }
  };

  useDidUpdate(function () {
    if (recording.mediaStream) {
      setRecording(_extends({}, recording, {
        mediaRecorder: new MediaRecorder(recording.mediaStream, {
          mimeType: 'audio/webm'
        })
      }));
    }
  }, [recording.mediaStream]);
  useEffect(function () {
    var MAX_RECORDER_TIME = 15;
    var recordingInterval = null;

    if (recording.initRecording) {
      recordingInterval = setInterval(function () {
        setRecording(function (prevState) {
          if (prevState.recordingSeconds === MAX_RECORDER_TIME && prevState.recordingMilliseconds === 0) {
            clearInterval(recordingInterval);
            return prevState;
          }

          if (prevState.recordingMilliseconds >= 0 && prevState.recordingMilliseconds < 99) {
            return _extends({}, prevState, {
              recordingMilliseconds: prevState.recordingMilliseconds + 1
            });
          }

          if (prevState.recordingMilliseconds === 99) {
            return _extends({}, prevState, {
              recordingSeconds: prevState.recordingSeconds + 1,
              recordingMilliseconds: 0
            });
          }

          return prevState;
        });
      }, 10);
    } else clearInterval(recordingInterval);

    return function () {
      return clearInterval(recordingInterval);
    };
  }, [recording.initRecording]);
  useEffect(function () {
    if (url && !isRendered) {
      wavesurfer.current = WaveSurfer.create({
        container: wavesurferContainer.current,
        waveColor: colors.gray9,
        progressColor: colors.primary,
        splitChannelsOptions: {
          filterChannels: file.metadata.tmb
        },
        barWidth: 1.5,
        audioRate: audioRate,
        barHeight: 3,
        hideScrollbar: true,
        barRadius: 1.5,
        cursorWidth: 0,
        barGap: 2,
        barMinHeight: 8,
        height: 20
      });
      wavesurfer.current.load(url);
      wavesurfer.current.on('ready', function () {
        var audioDuration = wavesurfer.current.getDuration();
        var currentTime = wavesurfer.current.getCurrentTime();
        setCurrentTime(formatAudioVideoTime(audioDuration, currentTime));
      });
      wavesurfer.current.on('finish', function () {
        setPlayAudio(false);
        wavesurfer.current.seekTo(0);
        var audioDuration = wavesurfer.current.getDuration();
        var currentTime = wavesurfer.current.getCurrentTime();
        setCurrentTime(formatAudioVideoTime(audioDuration, currentTime));

        if (payingAudioId === file.id) {
          setPayingAudioId('');
        }

        clearInterval(intervalRef.current);
      });
      wavesurfer.current.on('pause', function () {
        setPlayAudio(false);

        if (payingAudioId === file.id) {
          setPayingAudioId('');
        }

        clearInterval(intervalRef.current);
      });
      wavesurfer.current.on('interaction', function () {
        var audioDuration = wavesurfer.current.getDuration();
        var currentTime = wavesurfer.current.getCurrentTime();
        setCurrentTime(formatAudioVideoTime(audioDuration, currentTime));
      });
      setIsRendered(true);
    }

    return function () {
      clearInterval(intervalRef.current);
    };
  }, [url]);
  useEffect(function () {
    if (payingAudioId && wavesurfer.current && payingAudioId !== file.id) {
      setPlayAudio(false);
      wavesurfer.current.pause();
    }
  }, [payingAudioId]);
  return React__default.createElement(Container$b, null, React__default.createElement(PlayPause, {
    onClick: handlePlayPause
  }, playAudio ? React__default.createElement(SvgPause, null) : React__default.createElement(SvgPlay, null)), React__default.createElement(WaveContainer, null, React__default.createElement(AudioVisualization, {
    ref: wavesurferContainer
  }), React__default.createElement(AudioRate, {
    onClick: handleSetAudioRate
  }, audioRate, React__default.createElement("span", null, "X"))), React__default.createElement(Timer, null, currentTime));
};

var _templateObject$m, _templateObject2$k, _templateObject3$g, _templateObject4$d, _templateObject5$9, _templateObject6$9, _templateObject7$7, _templateObject8$5, _templateObject9$4, _templateObject10$4, _templateObject11$3, _templateObject12$2;

var Attachment = function Attachment(_ref) {
  var attachment = _ref.attachment,
      _ref$isPrevious = _ref.isPrevious,
      isPrevious = _ref$isPrevious === void 0 ? false : _ref$isPrevious,
      removeSelected = _ref.removeSelected,
      isRepliedMessage = _ref.isRepliedMessage,
      borderRadius = _ref.borderRadius,
      handleMediaItemClick = _ref.handleMediaItemClick,
      setVideoIsReadyToSend = _ref.setVideoIsReadyToSend,
      selectedFileAttachmentsIcon = _ref.selectedFileAttachmentsIcon,
      backgroundColor = _ref.backgroundColor,
      selectedFileAttachmentsBoxBorder = _ref.selectedFileAttachmentsBoxBorder,
      selectedFileAttachmentsTitleColor = _ref.selectedFileAttachmentsTitleColor,
      selectedFileAttachmentsSizeColor = _ref.selectedFileAttachmentsSizeColor,
      isDetailsView = _ref.isDetailsView,
      fileNameMaxLength = _ref.fileNameMaxLength,
      imageMinWidth = _ref.imageMinWidth,
      closeMessageActions = _ref.closeMessageActions;
  var dispatch = useDispatch();
  var attachmentCompilationState = useSelector(attachmentCompilationStateSelector) || {};
  var imageContRef = useRef(null);

  var _useState = useState(false),
      imgIsLoaded = _useState[0],
      setImgIsLoaded = _useState[1];

  var _useState2 = useState(''),
      attachmentUrl = _useState2[0],
      setAttachmentUrl = _useState2[1];

  var _useState3 = useState(false),
      downloadIsCancelled = _useState3[0],
      setDownloadIsCancelled = _useState3[1];

  var fileNameRef = useRef(null);
  var customDownloader = getCustomDownloader();

  var _ref2 = attachment.metadata && attachment.metadata.szw && attachment.metadata.szh ? calculateRenderedImageWidth(attachment.metadata.szw, attachment.metadata.szh) : [],
      renderWidth = _ref2[0],
      renderHeight = _ref2[1];

  var downloadImage = function downloadImage(url) {
    var image = new Image();
    image.src = url;

    image.onload = function () {
      setAttachmentUrl(url);
    };

    image.onerror = function () {
      console.error('Error on download image');
    };
  };

  var handlePauseResumeDownload = function handlePauseResumeDownload(e) {
    e.stopPropagation();

    if (downloadIsCancelled) {
      setDownloadIsCancelled(false);

      if (customDownloader) {
        customDownloader(attachment.url).then(function (url) {
          downloadImage(url);
        });
      } else {
        downloadImage(attachment.url);
      }
    } else {
      setAttachmentUrl('');
      setDownloadIsCancelled(true);
    }
  };

  var handlePauseResumeUpload = function handlePauseResumeUpload(e) {
    e.stopPropagation();

    if (attachmentCompilationState[attachment.attachmentId]) {
      if (attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.UPLOADING) {
        dispatch(pauseAttachmentUploadingAC(attachment.attachmentId));
      } else {
        dispatch(resumeAttachmentUploadingAC(attachment.attachmentId));
      }
    }
  };

  useEffect(function () {
    if (downloadIsCancelled) {
      setAttachmentUrl('');
    }
  }, [attachmentUrl]);
  useEffect(function () {
    setAttachmentUrl('');

    if (!(attachment.type === attachmentTypes.file || attachment.type === attachmentTypes.link)) {
      getAttachmentUrlFromCache(attachment.id).then(function (cachedUrl) {
        if (attachment.type === 'image' && !isPrevious) {
          if (cachedUrl) {
            downloadImage(cachedUrl);
          } else {
            if (customDownloader) {
              customDownloader(attachment.url).then(function (url) {
                try {
                  return Promise.resolve(fetch(url)).then(function (response) {
                    setAttachmentToCache(attachment.id, response);
                    downloadImage(url);
                  });
                } catch (e) {
                  return Promise.reject(e);
                }
              });
            } else {
              downloadImage(attachment.url);
            }
          }
        } else {
          if (attachment.type === attachmentTypes.video && cachedUrl) {
            setAttachmentUrl(cachedUrl);
          } else {
            if (customDownloader) {
              customDownloader(attachment.url).then(function (url) {
                try {
                  var _temp3 = function _temp3() {
                    setAttachmentUrl(url);
                  };

                  var _temp4 = function () {
                    if (attachment.type === attachmentTypes.video) {
                      return Promise.resolve(fetch(url)).then(function (response) {
                        setAttachmentToCache(attachment.id, response);
                      });
                    }
                  }();

                  return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
                } catch (e) {
                  return Promise.reject(e);
                }
              });
            } else {
              setAttachmentUrl(attachment.url);
            }
          }
        }
      });
    }
  }, [attachment]);
  return React__default.createElement(React__default.Fragment, null, attachment.type === 'image' ? React__default.createElement(AttachmentImgCont, {
    draggable: false,
    onClick: function onClick() {
      return handleMediaItemClick && handleMediaItemClick(attachment);
    },
    isPrevious: isPrevious,
    ref: imageContRef,
    borderRadius: borderRadius,
    backgroundImage: attachment.metadata && attachment.metadata.tmb,
    isRepliedMessage: isRepliedMessage,
    imgIsLoaded: imgIsLoaded,
    fitTheContainer: isDetailsView
  }, (attachment.attachmentUrl || attachmentUrl) && React__default.createElement(AttachmentImg$1, {
    draggable: false,
    backgroundColor: backgroundColor,
    src: attachment.attachmentUrl || attachmentUrl,
    borderRadius: borderRadius,
    imageMinWidth: imageMinWidth,
    isPrevious: isPrevious,
    isRepliedMessage: isRepliedMessage,
    withBorder: !isPrevious && !isDetailsView,
    fitTheContainer: isDetailsView,
    onLoad: function onLoad() {
      return setImgIsLoaded(true);
    }
  }), !isPrevious && !(attachment.attachmentUrl || attachmentUrl) && React__default.createElement(UploadProgress, {
    positionStatic: true,
    backgroundImage: attachment.metadata && attachment.metadata.tmb,
    isRepliedMessage: isRepliedMessage,
    onClick: handlePauseResumeDownload,
    width: renderWidth,
    height: renderHeight,
    withBorder: !isPrevious && !isDetailsView,
    backgroundColor: backgroundColor,
    isDetailsView: isDetailsView,
    imageMinWidth: imageMinWidth
  }, React__default.createElement(UploadPercent, {
    isRepliedMessage: isRepliedMessage
  }, downloadIsCancelled ? React__default.createElement(SvgDownload, null) : React__default.createElement(SvgCancel, null)), !downloadIsCancelled && React__default.createElement(UploadingIcon, {
    isRepliedMessage: isRepliedMessage,
    className: 'rotate_cont'
  })), !isPrevious && attachmentCompilationState[attachment.attachmentId] && (attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.UPLOADING || attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.PAUSED) ? React__default.createElement(UploadProgress, {
    onClick: handlePauseResumeUpload
  }, React__default.createElement(UploadPercent, null, attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.UPLOADING ? React__default.createElement(SvgCancel, null) : React__default.createElement(SvgUpload, null)), attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.UPLOADING && React__default.createElement(UploadingIcon, {
    className: 'rotate_cont'
  })) : null, isPrevious && React__default.createElement(RemoveChosenFile, {
    onClick: function onClick() {
      return removeSelected && removeSelected(attachment.attachmentId);
    }
  })) : attachment.type === 'video' ? React__default.createElement(React__default.Fragment, null, !isPrevious ? React__default.createElement(VideoCont, {
    onClick: function onClick() {
      return handleMediaItemClick && (attachmentCompilationState[attachment.attachmentId] ? attachmentCompilationState[attachment.attachmentId] !== UPLOAD_STATE.FAIL || attachmentCompilationState[attachment.attachmentId] !== UPLOAD_STATE.UPLOADING : true) && handleMediaItemClick(attachment);
    },
    isDetailsView: isDetailsView
  }, attachmentCompilationState[attachment.attachmentId] && (attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.UPLOADING || attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.PAUSED) ? React__default.createElement(UploadProgress, {
    isDetailsView: isDetailsView,
    isRepliedMessage: isRepliedMessage,
    onClick: handlePauseResumeUpload
  }, React__default.createElement(UploadPercent, {
    isRepliedMessage: isRepliedMessage
  }, attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.UPLOADING ? React__default.createElement(SvgCancel, null) : React__default.createElement(SvgUpload, null)), attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.UPLOADING && React__default.createElement(UploadingIcon, {
    isRepliedMessage: isRepliedMessage,
    className: 'rotate_cont'
  })) : null, React__default.createElement(VideoPreview, {
    maxWidth: isRepliedMessage ? '40px' : isDetailsView ? '100%' : '320px',
    maxHeight: isRepliedMessage ? '40px' : isDetailsView ? '100%' : '240px',
    file: attachment,
    src: attachmentUrl,
    uploading: attachmentCompilationState[attachment.attachmentId] && (attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.UPLOADING || attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.PAUSED),
    borderRadius: isRepliedMessage ? '4px' : borderRadius,
    isRepliedMessage: isRepliedMessage,
    isDetailsView: isDetailsView,
    backgroundColor: backgroundColor
  })) : React__default.createElement(AttachmentImgCont, {
    isPrevious: isPrevious,
    backgroundColor: colors.defaultAvatarBackground
  }, React__default.createElement(VideoPreview, {
    maxWidth: '48px',
    maxHeight: '48px',
    file: attachment,
    src: attachment.attachmentUrl || attachmentUrl,
    borderRadius: borderRadius,
    setVideoIsReadyToSend: setVideoIsReadyToSend,
    backgroundColor: backgroundColor,
    isPreview: true
  }), React__default.createElement(RemoveChosenFile, {
    onClick: function onClick() {
      return removeSelected && removeSelected(attachment.attachmentId);
    }
  }))) : attachment.type === attachmentTypes.voice ? React__default.createElement(AudioPlayer, {
    url: attachment.attachmentUrl || attachmentUrl,
    file: attachment
  }) : attachment.type === attachmentTypes.link ? null : React__default.createElement(AttachmentFile$1, {
    draggable: false,
    isPrevious: isPrevious,
    isUploading: attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.UPLOADING || attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.PAUSED,
    borderRadius: borderRadius,
    background: backgroundColor,
    isRepliedMessage: isRepliedMessage,
    border: selectedFileAttachmentsBoxBorder
  }, attachment.metadata && attachment.metadata.tmb ? React__default.createElement(FileThumbnail, {
    src: "data:image/jpeg;base64," + attachment.metadata.tmb
  }) : React__default.createElement(AttachmentIconCont, {
    className: 'icon-warpper'
  }, selectedFileAttachmentsIcon || React__default.createElement(SvgFileIcon, null)), !isRepliedMessage && !isPrevious && React__default.createElement(DownloadFile$1, {
    backgroundColor: colors.primary,
    onClick: function onClick() {
      return downloadFile(attachment);
    },
    onMouseEnter: function onMouseEnter() {
      return closeMessageActions && closeMessageActions(false);
    },
    onMouseLeave: function onMouseLeave() {
      return closeMessageActions && closeMessageActions(true);
    }
  }, React__default.createElement(SvgDownload, null)), !isPrevious && attachmentCompilationState[attachment.attachmentId] && (attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.UPLOADING || attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.PAUSED) ? React__default.createElement(UploadProgress, {
    fileAttachment: true,
    onClick: handlePauseResumeUpload
  }, React__default.createElement(UploadPercent, {
    fileAttachment: true,
    borderRadius: attachment.metadata && attachment.metadata.tmb ? undefined : '50%'
  }, attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.UPLOADING ? React__default.createElement(SvgCancel, null) : React__default.createElement(SvgUpload, null)), React__default.createElement(UploadingIcon, {
    fileAttachment: true,
    className: 'rotate_cont'
  })) : attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.FAIL ? React__default.createElement(React__default.Fragment, null, React__default.createElement(UploadProgress, {
    isFailedAttachment: true
  }, React__default.createElement(RemoveFailed, {
    onClick: function onClick() {
      return removeSelected && removeSelected(attachment.attachmentId);
    }
  }))) : null, !isRepliedMessage && React__default.createElement(AttachmentFileInfo, {
    isPrevious: isPrevious
  }, React__default.createElement(AttachmentName, {
    color: selectedFileAttachmentsTitleColor,
    ref: fileNameRef
  }, formatLargeText(isPrevious ? attachment.data.name : attachment.name, fileNameMaxLength || isPrevious ? 18 : 30)), React__default.createElement(AttachmentSize, {
    color: selectedFileAttachmentsSizeColor
  }, (attachment.data && attachment.data.size || attachment.fileSize) && bytesToSize(isPrevious ? attachment.data.size : +attachment.fileSize), React__default.createElement("span", null, attachmentCompilationState[attachment.attachmentId] === UPLOAD_STATE.FAIL && 'Upload error'))), isPrevious && React__default.createElement(RemoveChosenFile, {
    onClick: function onClick() {
      return removeSelected && removeSelected(attachment.attachmentId);
    }
  })));
};
var DownloadImage = styled.div(_templateObject$m || (_templateObject$m = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  visibility: hidden;\n  opacity: 0;\n  width: 28px;\n  height: 28px;\n  top: 12px;\n  right: 17px;\n  border-radius: 50%;\n  line-height: 35px;\n  text-align: center;\n  cursor: pointer;\n  background: #ffffff;\n  box-shadow: 0 4px 4px rgba(6, 10, 38, 0.2);\n  transition: all 0.1s;\n\n  & > svg {\n    width: 16px;\n  }\n"])));
var AttachmentImgCont = styled.div(_templateObject2$k || (_templateObject2$k = _taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n  //flex-direction: column;\n  margin-right: ", ";\n  //max-width: 420px;\n  //max-height: 400px;\n  min-width: ", ";\n  height: ", ";\n\n  cursor: pointer;\n  & > img.thumbnail {\n    position: ", ";\n    object-fit: cover;\n    max-width: 420px;\n    max-height: 400px;\n    min-width: 120px;\n    border-radius: ", ";\n  }\n  ", "\n  //background-image: ", ";\n  &:hover ", " {\n    visibility: visible;\n    opacity: 1;\n  }\n\n  ", "\n"])), function (props) {
  return props.isPrevious ? '16px' : props.isRepliedMessage ? '8px' : '';
}, function (props) {
  return !props.isRepliedMessage && !props.fitTheContainer && '130px';
}, function (props) {
  return props.fitTheContainer && '100%';
}, function (props) {
  return props.imgIsLoaded && 'absolute';
}, function (props) {
  return props.borderRadius || '4px';
}, function (props) {
  return props.backgroundColor && "\n    background-color: " + props.backgroundColor + ";\n    border-radius: 8px;\n    justify-content: center;\n    align-items: center;\n     & > svg:first-child {\n      width: 40px;\n      height: 40px;\n      transform: translate(2px, 3px);\n    }\n  ";
}, function (props) {
  return props.backgroundImage && "url(data:image/jpeg;base64," + props.backgroundImage + ")";
}, DownloadImage, function (props) {
  return props.isPrevious && "\n      width: 48px;\n      min-width: 48px;\n      height: 48px;\n  ";
});
var FileThumbnail = styled.img(_templateObject3$g || (_templateObject3$g = _taggedTemplateLiteralLoose(["\n  min-width: 40px;\n  max-width: 40px;\n  height: 40px;\n  object-fit: cover;\n  border-radius: 8px;\n"])));
var DownloadFile$1 = styled.span(_templateObject4$d || (_templateObject4$d = _taggedTemplateLiteralLoose(["\n  display: none;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  background-color: ", ";\n  min-width: 40px;\n  max-width: 40px;\n  height: 40px;\n  border-radius: 50%;\n\n  & > svg {\n    width: 20px;\n    height: 20px;\n  }\n"])), function (props) {
  return props.backgroundColor || colors.primary;
});
var AttachmentFile$1 = styled.div(_templateObject5$9 || (_templateObject5$9 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  position: relative;\n  align-items: center;\n  padding: ", ";\n  width: ", ";\n  //height: 70px;\n  background: ", ";\n  border: ", ";\n  box-sizing: border-box;\n  margin-right: ", ";\n  border-radius: ", ";\n\n  ", "\n\n  & > ", " svg {\n    width: 40px;\n    height: 40px;\n  }\n"])), function (props) {
  return !props.isRepliedMessage && '8px 12px;';
}, function (props) {
  return !props.isRepliedMessage && '350px';
}, function (props) {
  return props.background || '#ffffff';
}, function (props) {
  return props.border || "1px solid  " + colors.gray1;
}, function (props) {
  return props.isPrevious ? '16px' : props.isRepliedMessage ? '8px' : '';
}, function (props) {
  return props.borderRadius || '6px';
}, function (props) {
  return !props.isRepliedMessage && !props.isPrevious && !props.isUploading && "\n      &:hover " + DownloadFile$1 + " {\n        display: flex;\n      }\n\n      &:hover " + UploadPercent + " {\n        border-radius: 50%\n      }\n\n      &:hover " + FileThumbnail + " {\n        display: none;\n      }\n        &:hover " + AttachmentIconCont + " {\n    display: none;\n  }\n  ";
}, AttachmentIconCont);
var RemoveChosenFile = styled(SvgDeleteUpload)(_templateObject6$9 || (_templateObject6$9 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  width: 20px;\n  height: 20px !important;\n  top: -11px;\n  right: -11px;\n  padding: 2px;\n  cursor: pointer;\n  z-index: 4;\n"])));
var RemoveFailed = styled(SvgDeleteFailed)(_templateObject7$7 || (_templateObject7$7 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  top: calc(50% - 11px);\n  right: 18px;\n  padding: 2px;\n  cursor: pointer;\n"])));
var AttachmentName = styled.h3(_templateObject8$5 || (_templateObject8$5 = _taggedTemplateLiteralLoose(["\n  font-size: 15px;\n  font-weight: 500;\n  line-height: 18px;\n  color: ", ";\n  max-width: 275px;\n  white-space: nowrap;\n  margin: 0;\n"])), function (props) {
  return props.color || colors.blue6;
});
var AttachmentSize = styled.span(_templateObject9$4 || (_templateObject9$4 = _taggedTemplateLiteralLoose(["\n  font-size: 13px;\n  color: ", ";\n  & > span {\n    color: ", ";\n    margin-left: 8px;\n  }\n"])), function (props) {
  return props.color || colors.blue6;
}, colors.red1);
var AttachmentFileInfo = styled.div(_templateObject10$4 || (_templateObject10$4 = _taggedTemplateLiteralLoose(["\n  margin-left: 12px;\n  ", "\n"])), function (props) {
  return props.isPrevious && "line-height: 14px;\n      max-width: calc(100% - 44px);\n  ";
});
var AttachmentImg$1 = styled.img(_templateObject11$3 || (_templateObject11$3 = _taggedTemplateLiteralLoose(["\n  position: ", ";\n  border-radius: ", ";\n  border: ", ";\n  box-sizing: border-box;\n  max-width: 100%;\n  max-height: 400px;\n  width: ", ";\n  height: ", ";\n  min-height: ", ";\n  min-width: ", ";\n  object-fit: cover;\n  z-index: 2;\n"])), function (props) {
  return props.absolute && 'absolute';
}, function (props) {
  return props.isRepliedMessage ? '4px' : props.borderRadius || '6px';
}, function (props) {
  return props.isRepliedMessage ? '0.5px solid rgba(0, 0, 0, 0.1)' : props.withBorder && "2px solid " + props.backgroundColor;
}, function (props) {
  return props.isRepliedMessage ? '40px' : props.isPrevious ? '48px' : props.fitTheContainer ? '100%' : '';
}, function (props) {
  return props.isRepliedMessage ? '40px' : props.isPrevious ? '48px' : props.fitTheContainer ? '100%' : '';
}, function (props) {
  return !props.isRepliedMessage && !props.isPrevious && !props.fitTheContainer ? '90px' : props.isRepliedMessage ? '40px' : '';
}, function (props) {
  return !props.isRepliedMessage && !props.isPrevious && !props.fitTheContainer ? props.imageMinWidth || '130px' : props.isRepliedMessage ? '40px' : '';
});
var VideoCont = styled.div(_templateObject12$2 || (_templateObject12$2 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  cursor: pointer;\n  height: ", ";\n"])), function (props) {
  return props.isDetailsView && '100%';
});

var _templateObject$n, _templateObject2$l;

var CustomRadio$1 = function CustomRadio(_ref) {
  var index = _ref.index,
      state = _ref.state,
      _onChange = _ref.onChange,
      checkedBorder = _ref.checkedBorder,
      border = _ref.border,
      borderRadius = _ref.borderRadius,
      size = _ref.size,
      disabled = _ref.disabled;
  return React__default.createElement(React__default.Fragment, null, React__default.createElement(CustomLabel$1, {
    isChecked: state,
    size: size,
    checkedBorder: checkedBorder,
    border: border,
    borderRadius: borderRadius,
    htmlFor: "radio-" + index
  }), React__default.createElement(Radio, {
    disabled: disabled,
    type: 'radio',
    id: "radio-" + index,
    checked: state,
    onChange: function onChange(e) {
      return _onChange(e);
    }
  }));
};
var CustomLabel$1 = styled.label(_templateObject$n || (_templateObject$n = _taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: ", ";\n  height: ", ";\n  cursor: pointer;\n  border: ", ";\n  border-radius: ", ";\n"])), function (props) {
  return props.size || '12px';
}, function (props) {
  return props.size || '12px';
}, function (props) {
  return props.isChecked ? props.checkedBorder || "6px solid " + colors.primary : props.border || "1px solid " + colors.gray4;
}, function (props) {
  return props.borderRadius || '50%';
});
var Radio = styled.input(_templateObject2$l || (_templateObject2$l = _taggedTemplateLiteralLoose(["\n  display: none;\n"])));

var _templateObject$o, _templateObject2$m;

function ConfirmPopup(_ref) {
  var title = _ref.title,
      description = _ref.description,
      buttonText = _ref.buttonText,
      buttonTextColor = _ref.buttonTextColor,
      buttonBackground = _ref.buttonBackground,
      togglePopup = _ref.togglePopup,
      handleFunction = _ref.handleFunction,
      isDeleteMessage = _ref.isDeleteMessage,
      isIncomingMessage = _ref.isIncomingMessage,
      allowDeleteIncoming = _ref.allowDeleteIncoming,
      isDirectChannel = _ref.isDirectChannel,
      _ref$myRole = _ref.myRole,
      myRole = _ref$myRole === void 0 ? '' : _ref$myRole,
      loading = _ref.loading;

  var _usePermissions = usePermissions(myRole),
      checkActionPermission = _usePermissions[0];

  var _useState = useState(true),
      initialRender = _useState[0],
      setInitialRender = _useState[1];

  var deleteForEveryoneIsPermitted = isIncomingMessage ? allowDeleteIncoming && !isDirectChannel && checkActionPermission('deleteAnyMessage') : checkActionPermission('deleteOwnMessage');

  var _useState2 = useState(deleteForEveryoneIsPermitted ? 'forEveryone' : 'forMe'),
      deleteMessageOption = _useState2[0],
      setDeleteMessageOption = _useState2[1];

  var handleDelete = function handleDelete() {
    handleFunction(isDeleteMessage && deleteMessageOption);
    togglePopup();
  };

  var handleChoseDeleteOption = function handleChoseDeleteOption(e, option) {
    if (e.target.checked) {
      setDeleteMessageOption(option);
    }
  };

  useEffect(function () {
    setInitialRender(false);
  }, []);
  return React__default.createElement(PopupContainer, null, React__default.createElement(Popup, {
    maxWidth: '520px',
    minWidth: '520px',
    isLoading: loading,
    padding: '0'
  }, React__default.createElement(PopupBody, {
    padding: 24
  }, React__default.createElement(CloseIcon, {
    onClick: function onClick() {
      return togglePopup();
    }
  }), React__default.createElement(PopupName, {
    isDelete: true,
    marginBottom: '20px'
  }, title), React__default.createElement(PopupDescription, null, description), isDeleteMessage && React__default.createElement(DeleteMessageOptions, null, deleteForEveryoneIsPermitted && React__default.createElement(DeleteOptionItem, {
    onClick: function onClick() {
      return setDeleteMessageOption('forEveryone');
    }
  }, React__default.createElement(CustomRadio$1, {
    index: '1',
    size: '18px',
    state: deleteMessageOption === 'forEveryone',
    onChange: function onChange(e) {
      return handleChoseDeleteOption(e, 'forEveryone');
    }
  }), "Delete for everyone"), React__default.createElement(DeleteOptionItem, {
    onClick: function onClick() {
      return setDeleteMessageOption('forMe');
    }
  }, React__default.createElement(CustomRadio$1, {
    index: '2',
    size: '18px',
    state: deleteMessageOption === 'forMe',
    onChange: function onChange(e) {
      return handleChoseDeleteOption(e, 'forMe');
    }
  }), "Delete for me"))), React__default.createElement(PopupFooter, {
    backgroundColor: colors.gray5
  }, React__default.createElement(Button, {
    type: 'button',
    color: colors.gray6,
    backgroundColor: 'transparent',
    onClick: function onClick() {
      return togglePopup();
    }
  }, "Cancel"), React__default.createElement(Button, {
    type: 'button',
    backgroundColor: buttonBackground || colors.red1,
    color: buttonTextColor,
    borderRadius: '8px',
    onClick: handleDelete,
    disabled: initialRender
  }, buttonText || 'Delete'))));
}
var DeleteMessageOptions = styled.div(_templateObject$o || (_templateObject$o = _taggedTemplateLiteralLoose(["\n  margin-top: 14px;\n"])));
var DeleteOptionItem = styled.div(_templateObject2$m || (_templateObject2$m = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  font-size: 15px;\n  line-height: 160%;\n  color: ", ";\n  margin-bottom: 12px;\n\n  & > label {\n    margin-right: 10px;\n  }\n"])), colors.gray8);

function useOnScreen(ref) {
  var _useState = useState(false),
      isIntersecting = _useState[0],
      setIntersecting = _useState[1];

  var observer = new IntersectionObserver(function (_ref) {
    var entry = _ref[0];
    return setIntersecting(entry.isIntersecting);
  });
  useEffect(function () {
    observer.observe(ref.current);
    return function () {
      observer.disconnect();
    };
  }, []);
  return isIntersecting;
}

var _templateObject$p, _templateObject2$n, _templateObject3$h, _templateObject4$e, _templateObject5$a, _templateObject6$a, _templateObject7$8, _templateObject8$6, _templateObject9$5;

function ForwardMessagePopup(_ref) {
  var title = _ref.title,
      buttonText = _ref.buttonText,
      togglePopup = _ref.togglePopup,
      handleForward = _ref.handleForward,
      loading = _ref.loading;
  var dispatch = useDispatch();
  var channels = useSelector(channelsForForwardSelector) || [];
  var contactsMap = useSelector(contactsMapSelector);
  var getFromContacts = getShowOnlyContactUsers();
  var channelsLoading = useSelector(channelsLoadingState);
  var channelsHasNext = useSelector(channelsForForwardHasNextSelector);

  var _useState = useState(''),
      searchValue = _useState[0],
      setSearchValue = _useState[1];

  var _useState2 = useState(0),
      selectedChannelsContHeight = _useState2[0],
      setSelectedChannelsHeight = _useState2[1];

  var _useState3 = useState([]),
      selectedChannels = _useState3[0],
      setSelectedChannels = _useState3[1];

  var _useState4 = useState([]),
      channelIds = _useState4[0],
      setChannelIds = _useState4[1];

  var selectedChannelsContRef = useRef();

  var handleForwardMessage = function handleForwardMessage() {
    handleForward(channelIds);
    togglePopup();
  };

  var handleChannelListScroll = function handleChannelListScroll(event) {
    if (event.target.scrollTop >= event.target.scrollHeight - event.target.offsetHeight - 100) {
      if (channelsLoading === LOADING_STATE.LOADED && channelsHasNext) {
        dispatch(loadMoreChannelsForForward(15));
      }
    }
  };

  var handleChoseChannel = function handleChoseChannel(e, channelId) {
    if (e.target.checked) {
      setChannelIds(function (prevState) {
        return [].concat(prevState, [channelId]);
      });
    }
  };

  var handleSearchValueChange = function handleSearchValueChange(e) {
    var value = e.target.value;
    setSearchValue(value);
  };

  var getMyChannels = function getMyChannels() {
    setSearchValue('');
  };

  var handleChannelSelect = function handleChannelSelect(event, channel) {
    var newSelectedChannels = [].concat(selectedChannels);

    if (event.target.checked) {
      newSelectedChannels.push({
        id: channel.id,
        displayName: channel.subject || (channel.type === CHANNEL_TYPE.DIRECT ? makeUserName(contactsMap[channel.peer.id], channel.peer, getFromContacts) : '')
      });
    } else {
      var itemToDeleteIndex = newSelectedChannels.findIndex(function (chan) {
        return channel.id === chan.id;
      });

      if (itemToDeleteIndex >= 0) {
        newSelectedChannels.splice(itemToDeleteIndex, 1);
      }
    }

    setSearchValue('');
    setSelectedChannels(newSelectedChannels);
  };

  var removeChannel = function removeChannel(channel) {
    var newSelectedChannels = [].concat(selectedChannels);
    var itemToDeleteIndex = newSelectedChannels.findIndex(function (c) {
      return channel.id === c.id;
    });

    if (itemToDeleteIndex >= 0) {
      newSelectedChannels.splice(itemToDeleteIndex, 1);
    }

    setSelectedChannels(newSelectedChannels);
  };

  useEffect(function () {
    if (selectedChannelsContRef.current) {
      setSelectedChannelsHeight(selectedChannelsContRef.current.offsetHeight);
    } else {
      setSelectedChannelsHeight(0);
    }
  }, [selectedChannels]);
  useEffect(function () {
    dispatch(getChannelsForForwardAC());
  }, []);
  useEffect(function () {
    dispatch(getChannelsForForwardAC(searchValue));
  }, [searchValue]);
  return React__default.createElement(PopupContainer, null, React__default.createElement(Popup, {
    maxWidth: '522px',
    minWidth: '522px',
    height: '540px',
    isLoading: loading,
    padding: '0'
  }, React__default.createElement(PopupBody, {
    padding: 24,
    withFooter: true
  }, React__default.createElement(CloseIcon, {
    onClick: function onClick() {
      return togglePopup();
    }
  }), React__default.createElement(PopupName, {
    isDelete: true,
    marginBottom: '20px'
  }, title), React__default.createElement(ChannelSearch, {
    searchValue: searchValue,
    handleSearchValueChange: handleSearchValueChange,
    getMyChannels: getMyChannels
  }), React__default.createElement(SelectedChannelsContainer, {
    ref: selectedChannelsContRef
  }, selectedChannels.map(function (channel) {
    return React__default.createElement(SelectedChannelBuble, {
      key: "selected-" + channel.id
    }, React__default.createElement(SelectedChannelName, null, channel.displayName), React__default.createElement(StyledSubtractSvg$1, {
      onClick: function onClick() {
        return removeChannel(channel);
      }
    }));
  })), React__default.createElement(ForwardChannelsCont, {
    onScroll: handleChannelListScroll,
    selectedChannelsHeight: selectedChannelsContHeight
  }, channels.map(function (channel) {
    var isDirectChannel = channel.type === CHANNEL_TYPE.DIRECT;
    var isSelected = selectedChannels.findIndex(function (chan) {
      return chan.id === channel.id;
    }) >= 0;
    return React__default.createElement(ChannelItem, {
      key: channel.id,
      onClick: function onClick(e) {
        return handleChoseChannel(e, channel.id);
      }
    }, React__default.createElement(Avatar, {
      name: channel.subject || (isDirectChannel ? channel.peer.firstName || channel.peer.id : ''),
      image: channel.avatarUrl || (isDirectChannel ? channel.peer.avatarUrl : ''),
      size: 40,
      textSize: 12,
      setDefaultAvatar: isDirectChannel
    }), React__default.createElement(ChannelInfo$2, null, React__default.createElement(ChannelTitle, null, channel.subject || (isDirectChannel ? makeUserName(contactsMap[channel.peer.id], channel.peer, getFromContacts) : '')), React__default.createElement(ChannelMembers, null, isDirectChannel ? (hideUserPresence(channel.peer) ? '' : channel.peer.presence && channel.peer.presence.state === PRESENCE_STATUS.ONLINE) ? 'Online' : channel.peer.presence.lastActiveAt && userLastActiveDateFormat(channel.peer.presence.lastActiveAt) : channel.memberCount + " " + (channel.type === CHANNEL_TYPE.PUBLIC ? channel.memberCount > 1 ? 'subscribers' : 'subscriber' : channel.memberCount > 1 ? 'members' : 'member') + " ")), React__default.createElement(CustomCheckbox, {
      index: channel.id,
      state: isSelected,
      onChange: function onChange(e) {
        return handleChannelSelect(e, channel);
      },
      size: '18px'
    }));
  }))), React__default.createElement(PopupFooter, {
    backgroundColor: colors.gray5
  }, React__default.createElement(Button, {
    type: 'button',
    color: colors.gray6,
    backgroundColor: 'transparent',
    onClick: function onClick() {
      return togglePopup();
    }
  }, "Cancel"), React__default.createElement(Button, {
    type: 'button',
    backgroundColor: colors.primary,
    borderRadius: '8px',
    onClick: handleForwardMessage
  }, buttonText || 'Forward'))));
}
var ForwardChannelsCont = styled.div(_templateObject$p || (_templateObject$p = _taggedTemplateLiteralLoose(["\n  overflow-y: auto;\n  margin-top: 16px;\n  max-height: ", ";\n  padding-right: 14px;\n"])), function (props) {
  return "calc(100% - " + (props.selectedChannelsHeight + 64) + "px)";
});
var ChannelItem = styled.div(_templateObject2$n || (_templateObject2$n = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  margin-bottom: 8px;\n"])));
var ChannelInfo$2 = styled.div(_templateObject3$h || (_templateObject3$h = _taggedTemplateLiteralLoose(["\n  margin-left: 12px;\n  margin-right: auto;\n  max-width: calc(100% - 74px);\n"])));
var ChannelTitle = styled.h3(_templateObject4$e || (_templateObject4$e = _taggedTemplateLiteralLoose(["\n  margin: 0 0 2px;\n  font-weight: 500;\n  font-size: 15px;\n  line-height: 18px;\n  letter-spacing: -0.2px;\n  color: ", ";\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n"])), colors.gray6);
var ChannelMembers = styled.h4(_templateObject5$a || (_templateObject5$a = _taggedTemplateLiteralLoose(["\n  margin: 0;\n  font-weight: 400;\n  font-size: 14px;\n  line-height: 16px;\n  letter-spacing: -0.078px;\n  color: ", ";\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n"])), colors.gray9);
var SelectedChannelsContainer = styled.div(_templateObject6$a || (_templateObject6$a = _taggedTemplateLiteralLoose(["\n  display: flex;\n  justify-content: flex-start;\n  flex-wrap: wrap;\n  width: 100%;\n  max-height: 85px;\n  overflow-x: hidden;\n  padding-top: 2px;\n  box-sizing: border-box;\n  //flex: 0 0 auto;\n"])));
var SelectedChannelBuble = styled.div(_templateObject7$8 || (_templateObject7$8 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  justify-content: space-between;\n  background: ", ";\n  border-radius: 16px;\n  align-items: center;\n  padding: 4px 10px;\n  height: 26px;\n  margin: 8px 8px 0 0;\n  box-sizing: border-box;\n"])), colors.gray5);
var SelectedChannelName = styled.span(_templateObject8$6 || (_templateObject8$6 = _taggedTemplateLiteralLoose(["\n  font-style: normal;\n  font-weight: 500;\n  font-size: 14px;\n  line-height: 16px;\n  color: ", ";\n"])), colors.blue6);
var StyledSubtractSvg$1 = styled(SvgCross)(_templateObject9$5 || (_templateObject9$5 = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n  margin-left: 4px;\n  transform: translate(2px, 0);\n"])));

var _templateObject$q, _templateObject2$o, _templateObject3$i, _templateObject4$f, _templateObject5$b, _templateObject6$b, _templateObject7$9, _templateObject8$7, _templateObject9$6, _templateObject10$5, _templateObject11$4, _templateObject12$3, _templateObject13$2, _templateObject14$2, _templateObject15$2, _templateObject16$1, _templateObject17$1, _templateObject18$1, _templateObject19$1;

var Message = function Message(_ref) {
  var message = _ref.message,
      channel = _ref.channel,
      handleScrollToRepliedMessage = _ref.handleScrollToRepliedMessage,
      handleMediaItemClick = _ref.handleMediaItemClick,
      prevMessage = _ref.prevMessage,
      nextMessage = _ref.nextMessage,
      firstMessage = _ref.firstMessage,
      setLastVisibleMessageId = _ref.setLastVisibleMessageId,
      isUnreadMessage = _ref.isUnreadMessage,
      isThreadMessage = _ref.isThreadMessage,
      fontFamily = _ref.fontFamily,
      ownMessageOnRightSide = _ref.ownMessageOnRightSide,
      messageWidthPercent = _ref.messageWidthPercent,
      _ref$showSenderNameOn = _ref.showSenderNameOnDirectChannel,
      showSenderNameOnDirectChannel = _ref$showSenderNameOn === void 0 ? false : _ref$showSenderNameOn,
      _ref$showSenderNameOn2 = _ref.showSenderNameOnOwnMessages,
      showSenderNameOnOwnMessages = _ref$showSenderNameOn2 === void 0 ? true : _ref$showSenderNameOn2,
      _ref$messageTimePosit = _ref.messageTimePosition,
      messageTimePosition = _ref$messageTimePosit === void 0 ? 'onMessage' : _ref$messageTimePosit,
      _ref$ownMessageBackgr = _ref.ownMessageBackground,
      ownMessageBackground = _ref$ownMessageBackgr === void 0 ? '' : _ref$ownMessageBackgr,
      _ref$incomingMessageB = _ref.incomingMessageBackground,
      incomingMessageBackground = _ref$incomingMessageB === void 0 ? '' : _ref$incomingMessageB,
      _ref$showOwnAvatar = _ref.showOwnAvatar,
      showOwnAvatar = _ref$showOwnAvatar === void 0 ? true : _ref$showOwnAvatar,
      _ref$showMessageStatu = _ref.showMessageStatus,
      showMessageStatus = _ref$showMessageStatu === void 0 ? true : _ref$showMessageStatu,
      _ref$hoverBackground = _ref.hoverBackground,
      hoverBackground = _ref$hoverBackground === void 0 ? true : _ref$hoverBackground,
      _ref$messageReaction = _ref.messageReaction,
      messageReaction = _ref$messageReaction === void 0 ? true : _ref$messageReaction,
      _ref$editMessage = _ref.editMessage,
      editMessage = _ref$editMessage === void 0 ? true : _ref$editMessage,
      _ref$copyMessage = _ref.copyMessage,
      copyMessage = _ref$copyMessage === void 0 ? true : _ref$copyMessage,
      _ref$replyMessage = _ref.replyMessage,
      replyMessage = _ref$replyMessage === void 0 ? true : _ref$replyMessage,
      _ref$replyMessageInTh = _ref.replyMessageInThread,
      replyMessageInThread = _ref$replyMessageInTh === void 0 ? true : _ref$replyMessageInTh,
      _ref$deleteMessage = _ref.deleteMessage,
      deleteMessage = _ref$deleteMessage === void 0 ? true : _ref$deleteMessage,
      allowEditDeleteIncomingMessage = _ref.allowEditDeleteIncomingMessage,
      _ref$forwardMessage = _ref.forwardMessage,
      forwardMessage = _ref$forwardMessage === void 0 ? true : _ref$forwardMessage,
      _ref$reportMessage = _ref.reportMessage,
      reportMessage = _ref$reportMessage === void 0 ? true : _ref$reportMessage,
      reactionIcon = _ref.reactionIcon,
      editIcon = _ref.editIcon,
      copyIcon = _ref.copyIcon,
      replyIcon = _ref.replyIcon,
      replyInThreadIcon = _ref.replyInThreadIcon,
      forwardIcon = _ref.forwardIcon,
      deleteIcon = _ref.deleteIcon,
      starIcon = _ref.starIcon,
      staredIcon = _ref.staredIcon,
      reportIcon = _ref.reportIcon,
      reactionIconOrder = _ref.reactionIconOrder,
      editIconOrder = _ref.editIconOrder,
      copyIconOrder = _ref.copyIconOrder,
      replyIconOrder = _ref.replyIconOrder,
      replyInThreadIconOrder = _ref.replyInThreadIconOrder,
      forwardIconOrder = _ref.forwardIconOrder,
      deleteIconOrder = _ref.deleteIconOrder,
      starIconOrder = _ref.starIconOrder,
      reportIconOrder = _ref.reportIconOrder,
      reactionIconTooltipText = _ref.reactionIconTooltipText,
      editIconTooltipText = _ref.editIconTooltipText,
      copyIconTooltipText = _ref.copyIconTooltipText,
      replyIconTooltipText = _ref.replyIconTooltipText,
      replyInThreadIconTooltipText = _ref.replyInThreadIconTooltipText,
      forwardIconTooltipText = _ref.forwardIconTooltipText,
      deleteIconTooltipText = _ref.deleteIconTooltipText,
      starIconTooltipText = _ref.starIconTooltipText,
      reportIconTooltipText = _ref.reportIconTooltipText,
      messageActionIconsColor = _ref.messageActionIconsColor,
      fileAttachmentsIcon = _ref.fileAttachmentsIcon,
      _ref$reactionsDisplay = _ref.reactionsDisplayCount,
      reactionsDisplayCount = _ref$reactionsDisplay === void 0 ? 5 : _ref$reactionsDisplay,
      _ref$showEachReaction = _ref.showEachReactionCount,
      showEachReactionCount = _ref$showEachReaction === void 0 ? true : _ref$showEachReaction,
      reactionItemBorder = _ref.reactionItemBorder,
      reactionItemBorderRadius = _ref.reactionItemBorderRadius,
      reactionItemBackground = _ref.reactionItemBackground,
      reactionItemPadding = _ref.reactionItemPadding,
      reactionItemMargin = _ref.reactionItemMargin,
      reactionsFontSize = _ref.reactionsFontSize,
      reactionsContainerBoxShadow = _ref.reactionsContainerBoxShadow,
      reactionsContainerBorder = _ref.reactionsContainerBorder,
      reactionsContainerBorderRadius = _ref.reactionsContainerBorderRadius,
      reactionsContainerBackground = _ref.reactionsContainerBackground,
      reactionsContainerPadding = _ref.reactionsContainerPadding,
      reactionsContainerTopPosition = _ref.reactionsContainerTopPosition,
      fileAttachmentsBoxBorder = _ref.fileAttachmentsBoxBorder,
      fileAttachmentsTitleColor = _ref.fileAttachmentsTitleColor,
      fileAttachmentsSizeColor = _ref.fileAttachmentsSizeColor;
  var dispatch = useDispatch();
  var ChatClient = getClient();
  var user = ChatClient.user;
  var getFromContacts = getShowOnlyContactUsers();
  var connectionStatus = useSelector(connectionStatusSelector, shallowEqual);
  var contactsMap = useSelector(contactsMapSelector, shallowEqual);

  var _useState = useState(false),
      deletePopupOpen = _useState[0],
      setDeletePopupOpen = _useState[1];

  var _useState2 = useState(false),
      forwardPopupOpen = _useState2[0],
      setForwardPopupOpen = _useState2[1];

  var _useState3 = useState(false),
      reportPopupOpen = _useState3[0],
      setReportPopupOpen = _useState3[1];

  var _useState4 = useState(false),
      messageActionsShow = _useState4[0],
      setMessageActionsShow = _useState4[1];

  var reactionsList = message.reactionScores && Object.keys(message.reactionScores);
  var reactionsCount = message.reactionScores && Object.values(message.reactionScores).reduce(function (prevValue, currentValue) {
    return prevValue + currentValue;
  }, 0);
  var messageTextRef = useRef(null);
  var messageActionsTimeout = useRef(null);
  var messageUserID = message.user ? message.user.id : 'deleted';
  var prevMessageUserID = prevMessage ? prevMessage.user ? prevMessage.user.id : 'deleted' : null;
  var nextMessageUserID = nextMessage ? nextMessage.user ? nextMessage.user.id : 'deleted' : null;
  var current = moment(message.createdAt).startOf('day');
  var firstMessageInInterval = !(prevMessage && current.diff(moment(prevMessage.createdAt).startOf('day'), 'days') === 0) || (prevMessage === null || prevMessage === void 0 ? void 0 : prevMessage.type) === 'system';
  var lastMessageInInterval = !(nextMessage && current.diff(moment(nextMessage.createdAt).startOf('day'), 'days') === 0) || nextMessage.type === 'system';
  var withAttachments = message.attachments && message.attachments.length > 0;
  var withMediaAttachment = withAttachments && (message.attachments[0].type === attachmentTypes.video || message.attachments[0].type === attachmentTypes.image);
  var renderAvatar = (isUnreadMessage || prevMessageUserID !== messageUserID || firstMessageInInterval) && !(channel.type === CHANNEL_TYPE.DIRECT && !showSenderNameOnDirectChannel) && !(!message.incoming && !showOwnAvatar);
  var borderRadius = !message.incoming && ownMessageOnRightSide ? prevMessageUserID !== messageUserID || firstMessageInInterval ? '16px 16px 4px 16px' : nextMessageUserID !== messageUserID || lastMessageInInterval ? '16px 4px 16px 16px' : '16px 4px 4px 16px' : prevMessageUserID !== messageUserID || firstMessageInInterval ? '16px 16px 16px 4px' : nextMessageUserID !== messageUserID || lastMessageInInterval ? '4px 16px 16px 16px' : '4px 16px 16px 4px';
  var showMessageSenderName = (isUnreadMessage || prevMessageUserID !== messageUserID || firstMessageInInterval) && !(channel.type === CHANNEL_TYPE.DIRECT && !showSenderNameOnDirectChannel) && (message.incoming || showSenderNameOnOwnMessages);

  var toggleEditMode = function toggleEditMode() {
    dispatch(setMessageToEditAC(message));
  };

  var handleToggleDeleteMessagePopup = function handleToggleDeleteMessagePopup() {
    setDeletePopupOpen(!deletePopupOpen);
  };

  var handleToggleForwardMessagePopup = function handleToggleForwardMessagePopup() {
    setForwardPopupOpen(!forwardPopupOpen);
  };

  var handleReplyMessage = function handleReplyMessage(threadReply) {
    if (threadReply) ; else {
      dispatch(setMessageForReplyAC(message));
    }
  };

  var handleToggleReportPopupOpen = function handleToggleReportPopupOpen() {
    setReportPopupOpen(!reportPopupOpen);
  };

  var handleDeleteMessage = function handleDeleteMessage(deleteOption) {
    dispatch(deleteMessageAC(channel.id, message.id, deleteOption));
  };

  var handleResendMessage = function handleResendMessage() {
    var messageToResend = _extends({}, message);

    if (message.attachments && message.attachments.length) {
      messageToResend.attachments = message.attachments.map(function (att) {
        var pendingAttachment = getPendingAttachment(att.attachmentId);
        return _extends({}, att, {
          data: new File([pendingAttachment], att.data.name)
        });
      });
    }

    dispatch(resendMessageAC(messageToResend, channel.id, connectionStatus));
  };

  var handleCopyMessage = function handleCopyMessage() {
    navigator.clipboard.writeText(messageTextRef.current.innerText);
    setMessageActionsShow(false);
  };

  var handleRemoveFailedAttachment = function handleRemoveFailedAttachment(attachmentId) {
    console.log('remove attachment .. ', attachmentId);
  };

  var handleMouseEnter = function handleMouseEnter() {
    messageActionsTimeout.current = setTimeout(function () {
      return setMessageActionsShow(true);
    }, 450);
  };

  var handleMouseLeave = function handleMouseLeave() {
    clearTimeout(messageActionsTimeout.current);
    setMessageActionsShow(false);
  };

  var handleDeletePendingMessage = function handleDeletePendingMessage() {
    if (message.attachments && message.attachments.length) {
      var customUploader = getCustomUploader();
      message.attachments.forEach(function (att) {
        if (customUploader) {
          cancelUpload(att.attachmentId);
          deletePendingAttachment(att.attachmentId);
        }
      });
    }

    removeMessageFromMap(channel.id, message.id || message.tid);
    removeMessageFromAllMessages(message.id || message.tid);
    dispatch(deleteMessageFromListAC(message.id || message.tid));
  };

  var handleReactionAddDelete = function handleReactionAddDelete(selectedEmoji) {
    if (message.selfReactions && message.selfReactions.some(function (item) {
      return item.key === selectedEmoji;
    })) {
      dispatch(deleteReactionAC(channel.id, message.id, selectedEmoji));
    } else {
      var score = 1;
      var reason = 'mmm';
      var enforceUnique = false;
      dispatch(addReactionAC(channel.id, message.id, selectedEmoji, score, reason, enforceUnique));
    }
  };

  var handleSendReadMarker = function handleSendReadMarker() {
    if (message.incoming && !(message.selfMarkers.length && message.selfMarkers.includes(MESSAGE_DELIVERY_STATUS.READ))) {
      dispatch(markMessagesAsReadAC(channel.id, [message.id]));
    }
  };

  var handleForwardMessage = function handleForwardMessage(channelIds) {
    if (channelIds && channelIds.length) {
      channelIds.forEach(function (channelId) {
        dispatch(forwardMessageAC(message, channelId, connectionStatus));
      });
    }
  };

  var messageItemRef = useRef();
  var isVisible = useOnScreen(messageItemRef);

  var MessageActionsCont = function MessageActionsCont() {
    return React__default.createElement(MessageActions, {
      messageFrom: message.user,
      channel: channel,
      editModeToggle: toggleEditMode,
      messageStatus: message.deliveryStatus || MESSAGE_DELIVERY_STATUS.PENDING,
      handleOpenDeleteMessage: handleToggleDeleteMessagePopup,
      handleCopyMessage: handleCopyMessage,
      handleDeletePendingMessage: handleDeletePendingMessage,
      handleOpenForwardMessage: handleToggleForwardMessagePopup,
      handleResendMessage: handleResendMessage,
      handleReplyMessage: handleReplyMessage,
      handleReportMessage: handleToggleReportPopupOpen,
      handleAddEmoji: handleReactionAddDelete,
      selfMessage: message.user && messageUserID === user.id,
      isThreadMessage: !!isThreadMessage,
      rtlDirection: ownMessageOnRightSide && !message.incoming,
      showMessageReaction: messageReaction,
      showEditMessage: editMessage && !(message.attachments && message.attachments.length && message.attachments[0].type === attachmentTypes.voice || !message.body),
      showCopyMessage: copyMessage && message.body,
      showReplyMessage: replyMessage,
      showReplyMessageInThread: replyMessageInThread,
      showForwardMessage: forwardMessage,
      showDeleteMessage: deleteMessage,
      showReportMessage: reportMessage,
      reactionIcon: reactionIcon,
      editIcon: editIcon,
      copyIcon: copyIcon,
      replyIcon: replyIcon,
      replyInThreadIcon: replyInThreadIcon,
      forwardIcon: forwardIcon,
      deleteIcon: deleteIcon,
      allowEditDeleteIncomingMessage: allowEditDeleteIncomingMessage,
      starIcon: starIcon,
      staredIcon: staredIcon,
      reportIcon: reportIcon,
      reactionIconOrder: reactionIconOrder,
      editIconOrder: editIconOrder,
      copyIconOrder: copyIconOrder,
      replyIconOrder: replyIconOrder,
      replyInThreadIconOrder: replyInThreadIconOrder,
      forwardIconOrder: forwardIconOrder,
      deleteIconOrder: deleteIconOrder,
      starIconOrder: starIconOrder,
      reportIconOrder: reportIconOrder,
      reactionIconTooltipText: reactionIconTooltipText,
      editIconTooltipText: editIconTooltipText,
      copyIconTooltipText: copyIconTooltipText,
      replyIconTooltipText: replyIconTooltipText,
      replyInThreadIconTooltipText: replyInThreadIconTooltipText,
      forwardIconTooltipText: forwardIconTooltipText,
      deleteIconTooltipText: deleteIconTooltipText,
      starIconTooltipText: starIconTooltipText,
      reportIconTooltipText: reportIconTooltipText,
      messageActionIconsColor: messageActionIconsColor,
      myRole: channel.role,
      isIncoming: message.incoming
    });
  };

  var MessageHeader = function MessageHeader() {
    return React__default.createElement(MessageHeaderCont, null, showMessageSenderName && React__default.createElement(MessageOwner, {
      withPadding: withAttachments || message.parent && message.parent.attachments && !!message.parent.attachments.length,
      isForwarded: message.forwardingDetails,
      messageBody: !!message.body,
      color: colors.primary,
      rtlDirection: ownMessageOnRightSide && !message.incoming
    }, message.user.id === user.id && message.user.firstName ? message.user.firstName + " " + message.user.lastName : makeUserName(contactsMap[message.user.id], message.user, getFromContacts)), messageTimePosition === 'topOfMessage' && React__default.createElement(MessageTime, null, "" + moment(message.createdAt).format('HH:mm')));
  };

  useEffect(function () {
    if (isVisible) {
      setLastVisibleMessageId(message.id);
      handleSendReadMarker();
    }
  }, [isVisible]);
  return React__default.createElement(MessageItem, {
    key: message.id || message.tid,
    rtl: ownMessageOnRightSide && !message.incoming,
    withAvatar: renderAvatar,
    hoverBackground: hoverBackground ? message.incoming ? incomingMessageBackground || 'rgb(238, 245, 255)' : ownMessageBackground || 'rgb(238, 245, 255)' : '',
    topMargin: (prevMessage === null || prevMessage === void 0 ? void 0 : prevMessage.type) === 'system' ? '0' : prevMessageUserID !== messageUserID || firstMessageInInterval ? '16px' : '8px',
    bottomMargin: reactionsList && reactionsList.length ? reactionsContainerTopPosition : '',
    ref: messageItemRef,
    className: 'MessageItem'
  }, renderAvatar && React__default.createElement(Avatar, {
    name: message.user && (message.user.firstName || messageUserID),
    image: message.user && message.user.avatarUrl,
    size: 32,
    textSize: 14,
    setDefaultAvatar: true
  }), React__default.createElement(MessageContent, {
    messageWidthPercent: messageWidthPercent,
    rtl: ownMessageOnRightSide && !message.incoming,
    withAvatar: renderAvatar,
    className: 'messageContent'
  }, message.state === MESSAGE_STATUS.FAILED && React__default.createElement(FailedMessageIcon, {
    rtl: ownMessageOnRightSide && !message.incoming
  }), React__default.createElement(MessageBody, {
    className: 'messageBody',
    isSelfMessage: !message.incoming,
    isReplyMessage: !!(message.parent && message.parent.id && !isThreadMessage),
    parentMessageAttachmentType: message.parent && message.parent.attachments && message.parent.attachments[0] && message.parent.attachments[0].type,
    ownMessageBackground: ownMessageBackground,
    incomingMessageBackground: incomingMessageBackground,
    borderRadius: borderRadius,
    withAttachments: withAttachments && message.attachments[0].type !== attachmentTypes.link,
    attachmentWidth: withAttachments ? message.attachments[0].type === attachmentTypes.image ? message.attachments[0].metadata && message.attachments[0].metadata.szw && calculateRenderedImageWidth(message.attachments[0].metadata.szw, message.attachments[0].metadata.szh)[0] : message.attachments[0].type === attachmentTypes.voice ? 254 : message.attachments[0].type === attachmentTypes.video ? 320 : undefined : undefined,
    noBody: !message.body && !withAttachments,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    showMessageActions: messageActionsShow
  }, (showMessageSenderName || messageTimePosition === 'topOfMessage') && React__default.createElement(MessageHeader, null), !isThreadMessage && messageActionsShow && React__default.createElement(MessageActionsCont, null), message.parent && message.parent.id && !isThreadMessage && React__default.createElement(ReplyMessageContainer, {
    withAttachments: withAttachments,
    leftBorderColor: colors.primary,
    onClick: function onClick() {
      return handleScrollToRepliedMessage && handleScrollToRepliedMessage(message.parent.id);
    }
  }, message.parent.attachments && !!message.parent.attachments.length && message.parent.attachments[0].type !== attachmentTypes.voice && message.parent.attachments[0].type !== attachmentTypes.link && message.parent.attachments.map(function (attachment, index) {
    return React__default.createElement(Attachment, {
      key: attachment.attachmentId || attachment.url,
      backgroundColor: message.incoming ? incomingMessageBackground : ownMessageBackground,
      attachment: attachment,
      removeSelected: handleRemoveFailedAttachment,
      attachments: message.parent.attachments,
      selectedFileAttachmentsIcon: fileAttachmentsIcon,
      isRepliedMessage: true,
      borderRadius: index === message.parent.attachments.length - 1 ? borderRadius : '16px',
      selectedFileAttachmentsBoxBorder: fileAttachmentsBoxBorder,
      selectedFileAttachmentsTitleColor: fileAttachmentsTitleColor,
      selectedFileAttachmentsSizeColor: fileAttachmentsSizeColor
    });
  }), React__default.createElement(ReplyMessageBody, null, React__default.createElement(MessageOwner, {
    color: colors.primary,
    fontSize: '12px',
    rtlDirection: ownMessageOnRightSide && !message.incoming
  }, message.parent.user.id === user.id ? 'You' : makeUserName(contactsMap[message.parent.user.id], message.parent.user, getFromContacts)), React__default.createElement(ReplyMessageText, {
    fontSize: '14px',
    lineHeight: '16px'
  }, !!message.parent.attachments.length && message.parent.attachments[0].type === attachmentTypes.voice && React__default.createElement(VoiceIconWrapper, {
    color: colors.primary
  }), message.parent.body ? MessageTextFormat({
    text: message.parent.body,
    message: message.parent,
    contactsMap: contactsMap,
    getFromContacts: getFromContacts
  }) : message.parent.attachments.length && message.parent.attachments[0].type !== attachmentTypes.link && (message.parent.attachments[0].type === attachmentTypes.image ? 'Photo' : message.parent.attachments[0].type === attachmentTypes.video ? 'Video' : message.parent.attachments[0].type === attachmentTypes.voice ? ' Voice' : 'File')))), message.forwardingDetails && React__default.createElement(ForwardedTitle, {
    withAttachments: withAttachments,
    withMediaAttachment: withMediaAttachment,
    withBody: !!message.body,
    showSenderName: showMessageSenderName,
    color: colors.primary
  }, React__default.createElement(SvgForward, null), "Forwarded message"), React__default.createElement(MessageText, {
    draggable: false,
    showMessageSenderName: showMessageSenderName,
    withAttachment: withAttachments && message.attachments[0].type !== attachmentTypes.link && !!message.body,
    withMediaAttachment: withMediaAttachment,
    fontFamily: fontFamily,
    isForwarded: !!message.forwardingDetails
  }, React__default.createElement("span", {
    ref: messageTextRef
  }, MessageTextFormat({
    text: message.body,
    message: message,
    contactsMap: contactsMap,
    getFromContacts: getFromContacts
  })), !withAttachments && message.state === MESSAGE_STATUS.DELETE ? React__default.createElement(MessageStatusDeleted, null, " Message was deleted. ") : '', !withAttachments || withAttachments && message.attachments[0].type === attachmentTypes.link ? React__default.createElement(MessageStatusAndTime, null, message.state === MESSAGE_STATUS.EDIT ? React__default.createElement(MessageStatusUpdated, null, "edited") : '', messageTimePosition === 'onMessage' && React__default.createElement(HiddenMessageTime, null, "" + moment(message.createdAt).format('HH:mm')), !message.incoming && showMessageStatus && message.state !== MESSAGE_STATUS.DELETE && React__default.createElement(MessageStatus, {
    iconColor: colors.primary,
    lastMessage: !firstMessage
  }, messageStatusIcon(message.deliveryStatus))) : null), withAttachments && message.attachments[0].type !== attachmentTypes.link && React__default.createElement(MessageStatusAndTime, {
    withAttachment: true,
    fileAttachment: message.attachments[0].type === 'file' || message.attachments[0].type === 'voice'
  }, message.state === MESSAGE_STATUS.EDIT ? React__default.createElement(MessageStatusUpdated, {
    color: message.attachments[0].type !== 'voice' && message.attachments[0].type !== 'file' ? colors.white : ''
  }, "edited") : '', messageTimePosition === 'onMessage' && React__default.createElement(HiddenMessageTime, null, "" + moment(message.createdAt).format('HH:mm')), !message.incoming && showMessageStatus && message.state !== MESSAGE_STATUS.DELETE && messageStatusIcon(message.deliveryStatus, message.attachments[0].type !== 'voice' && message.attachments[0].type !== 'file' ? colors.white : '')), withAttachments && message.attachments.map(function (attachment) {
    return React__default.createElement(Attachment, {
      key: attachment.attachmentId || attachment.url,
      handleMediaItemClick: handleMediaItemClick,
      attachment: attachment,
      removeSelected: handleRemoveFailedAttachment,
      attachments: message.attachments,
      imageMinWidth: message.parent && message.parent.attachments && message.parent.attachments[0] && message.parent.attachments[0].type === attachmentTypes.voice ? '210px' : undefined,
      borderRadius: ownMessageOnRightSide ? borderRadius : '16px',
      selectedFileAttachmentsIcon: fileAttachmentsIcon,
      backgroundColor: message.incoming ? incomingMessageBackground : ownMessageBackground,
      selectedFileAttachmentsBoxBorder: fileAttachmentsBoxBorder,
      selectedFileAttachmentsTitleColor: fileAttachmentsTitleColor,
      selectedFileAttachmentsSizeColor: fileAttachmentsSizeColor,
      closeMessageActions: function closeMessageActions(state) {
        return setMessageActionsShow(state);
      }
    });
  })), message.replyCount && message.replyCount > 0 && !isThreadMessage && React__default.createElement(ThreadMessageCountContainer, {
    onClick: function onClick() {
      return handleReplyMessage(true);
    }
  }, message.replyCount + " replies"), reactionsList && reactionsList.length && React__default.createElement(ReactionsContainer, {
    border: reactionsContainerBorder,
    boxShadow: reactionsContainerBoxShadow,
    borderRadius: reactionsContainerBorderRadius,
    topPosition: reactionsContainerTopPosition,
    padding: reactionsContainerPadding,
    backgroundColor: reactionsContainerBackground,
    rtlDirection: ownMessageOnRightSide && !message.incoming
  }, React__default.createElement(MessageReactionsCont, {
    rtlDirection: ownMessageOnRightSide && !message.incoming
  }, reactionsList.slice(0, reactionsDisplayCount || 5).map(function (key) {
    return React__default.createElement(MessageReaction, {
      key: key,
      onClick: function onClick() {
        return handleReactionAddDelete(key);
      },
      self: !!message.selfReactions.find(function (selfReaction) {
        return selfReaction.key === key;
      }),
      border: reactionItemBorder,
      borderRadius: reactionItemBorderRadius,
      backgroundColor: reactionItemBackground,
      padding: reactionItemPadding,
      margin: reactionItemMargin,
      isLastReaction: reactionsCount === 1,
      fontSize: reactionsFontSize
    }, key + " " + (showEachReactionCount ? message.reactionScores[key] : ''));
  }), reactionsCount && reactionsCount > 1 && React__default.createElement(MessageReaction, {
    border: reactionItemBorder,
    borderRadius: reactionItemBorderRadius,
    backgroundColor: reactionItemBackground,
    padding: reactionItemPadding,
    margin: '0',
    fontSize: '12px'
  }, reactionsCount)))), deletePopupOpen && React__default.createElement(ConfirmPopup, {
    handleFunction: handleDeleteMessage,
    togglePopup: handleToggleDeleteMessagePopup,
    buttonText: 'Delete',
    description: 'Who do you want to remove this message for?',
    isDeleteMessage: true,
    isIncomingMessage: message.incoming,
    myRole: channel.role,
    allowDeleteIncoming: allowEditDeleteIncomingMessage,
    isDirectChannel: channel.type === CHANNEL_TYPE.DIRECT,
    title: 'Delete message'
  }), forwardPopupOpen && React__default.createElement(ForwardMessagePopup, {
    handleForward: handleForwardMessage,
    togglePopup: handleToggleForwardMessagePopup,
    buttonText: 'Forward',
    title: 'Forward message'
  }));
};
var MessageReaction = styled.span(_templateObject$q || (_templateObject$q = _taggedTemplateLiteralLoose(["\n  display: inline-flex;\n  //min-width: 23px;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  margin: ", ";\n  margin-right: ", ";\n  border: ", ";\n  border-color: ", ";\n  color: ", ";\n  box-sizing: border-box;\n  border-radius: ", ";\n  font-size: ", ";\n  line-height: ", ";\n  padding: ", ";\n  background-color: ", ";\n  white-space: nowrap;\n"])), function (props) {
  return props.margin || '0 6px 0 0';
}, function (props) {
  return props.isLastReaction && '0';
}, function (props) {
  return props.border || "1px solid " + colors.gray3;
}, function (props) {
  return props.self && colors.primary;
}, function (props) {
  return props.self ? colors.primary : '';
}, function (props) {
  return props.borderRadius || '16px';
}, function (props) {
  return props.fontSize || '13px';
}, function (props) {
  return props.fontSize || '13px';
}, function (props) {
  return props.padding || '2px 6px';
}, function (props) {
  return props.backgroundColor || colors.white;
});
var ThreadMessageCountContainer = styled.div(_templateObject2$o || (_templateObject2$o = _taggedTemplateLiteralLoose(["\n  position: relative;\n  color: ", ";\n  font-weight: 500;\n  font-size: 13px;\n  line-height: 15px;\n  margin: 12px;\n  cursor: pointer;\n\n  &::before {\n    content: '';\n    position: absolute;\n    left: -25px;\n    top: -21px;\n    width: 16px;\n    height: 26px;\n    border-left: 2px solid #cdcdcf;\n    border-bottom: 2px solid #cdcdcf;\n    border-radius: 0 0 0 14px;\n  }\n"])), colors.cobalt1);
var FailedMessageIcon = styled.div(_templateObject3$i || (_templateObject3$i = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  bottom: 0;\n  left: ", ";\n  right: ", ";\n  width: 20px;\n  height: 20px;\n"])), function (props) {
  return !props.rtl && '-24px';
}, function (props) {
  return props.rtl && '-24px';
});
var ReactionsContainer = styled.div(_templateObject4$f || (_templateObject4$f = _taggedTemplateLiteralLoose(["\n  display: inline-flex;\n  margin-left: ", ";\n  margin-right: ", ";\n\n  margin-top: 4px;\n  justify-content: flex-end;\n  border: ", ";\n  box-shadow: ", ";\n  border-radius: ", ";\n  background-color: ", ";\n  padding: ", ";\n  z-index: 9;\n  ", ";\n"])), function (props) {
  return !props.rtlDirection && 'auto';
}, function (props) {
  return props.rtlDirection && 'auto';
}, function (props) {
  return props.border;
}, function (props) {
  return props.boxShadow;
}, function (props) {
  return props.borderRadius;
}, function (props) {
  return props.backgroundColor;
}, function (props) {
  return props.padding;
}, function (props) {
  return props.topPosition && "\n      position: relative;\n      top: " + props.topPosition + ";\n  ";
});
var MessageReactionsCont = styled.div(_templateObject5$b || (_templateObject5$b = _taggedTemplateLiteralLoose(["\n  display: inline-flex;\n  max-width: 300px;\n  //overflow-x: auto;\n  direction: ", ";\n"])), function (props) {
  return props.rtlDirection && 'ltr';
});
var MessageHeaderCont = styled.div(_templateObject6$b || (_templateObject6$b = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n"])));
var MessageTime = styled.span(_templateObject7$9 || (_templateObject7$9 = _taggedTemplateLiteralLoose(["\n  font-weight: 400;\n  font-size: 12px;\n  margin-right: 4px;\n  color: ", ";\n"])), colors.gray6);
var ReplyMessageContainer = styled.div(_templateObject8$7 || (_templateObject8$7 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  border-left: 2px solid ", ";\n  padding: 0 6px;\n  position: relative;\n  margin: ", ";\n  cursor: pointer;\n"])), function (props) {
  return props.leftBorderColor || '#b8b9c2';
}, function (props) {
  return props.withAttachments ? '8px 8px' : '0 0 8px';
});
var ReplyMessageBody = styled.div(_templateObject9$6 || (_templateObject9$6 = _taggedTemplateLiteralLoose(["\n  margin-top: auto;\n  margin-bottom: auto;\n  max-width: 100%;\n"])));
var ForwardedTitle = styled.h3(_templateObject10$5 || (_templateObject10$5 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  font-weight: 500;\n  font-size: 13px;\n  line-height: 16px;\n  color: ", ";\n  //margin: ", ";\n  margin: 0;\n  padding: ", ";\n  padding-top: ", ";\n  padding-bottom: ", ";\n  & > svg {\n    margin-right: 4px;\n    width: 16px;\n    height: 16px;\n    color: ", ";\n  }\n"])), function (props) {
  return props.color || colors.primary;
}, function (props) {
  return props.withAttachments && props.withBody ? '0' : '0 0 4px';
}, function (props) {
  return props.withAttachments && '8px 0 0 12px';
}, function (props) {
  return props.showSenderName && (props.withBody ? '2px' : '0');
}, function (props) {
  return props.withBody ? (!props.withAttachments || props.showSenderName) && '4px' : props.withAttachments ? props.withMediaAttachment ? '8px' : '2px' : '4px';
}, function (props) {
  return props.color || colors.primary;
});
var MessageStatus = styled.span(_templateObject11$4 || (_templateObject11$4 = _taggedTemplateLiteralLoose(["\n  display: inline-block;\n  margin-left: 4px;\n  text-align: right;\n  transform: translate(0px, -1px);\n  height: 14px;\n  //visibility: ", ";\n"])), function (_ref2) {
  var lastMessage = _ref2.lastMessage;
  return lastMessage ? 'visible' : 'hidden';
});
var HiddenMessageTime = styled.span(_templateObject12$3 || (_templateObject12$3 = _taggedTemplateLiteralLoose(["\n  display: ", ";\n  font-weight: 400;\n  font-size: 12px;\n  color: ", ";\n"])), function (props) {
  return props.hide && 'none';
}, colors.gray9);
var MessageStatusAndTime = styled.div(_templateObject13$2 || (_templateObject13$2 = _taggedTemplateLiteralLoose(["\n  display: ", ";\n  align-items: flex-end;\n  border-radius: 16px;\n  padding: ", ";\n  background-color: ", ";\n  float: right;\n  line-height: 14px;\n  margin-left: 12px;\n  transform: translate(0px, 4px);\n  & > svg {\n    margin-left: 4px;\n    transform: translate(0px, -1px);\n    height: 14px;\n  }\n  & > ", " {\n    color: ", ";\n  }\n\n  ", "\n"])), function (props) {
  return props.hide ? 'none' : 'flex';
}, function (props) {
  return props.withAttachment && '4px 6px';
}, function (props) {
  return props.withAttachment && !props.fileAttachment && 'rgba(1, 1, 1, 0.3)';
}, HiddenMessageTime, function (props) {
  return props.fileAttachment ? colors.gray9 : props.withAttachment ? colors.white : '';
}, function (props) {
  return props.withAttachment && "\n    position: absolute;\n    z-index: 3;\n    right: " + (props.fileAttachment ? '6px' : '10px') + ";\n    bottom: " + (props.fileAttachment ? '9px' : '14px') + ";\n  ";
});
var MessageStatusUpdated = styled.span(_templateObject14$2 || (_templateObject14$2 = _taggedTemplateLiteralLoose(["\n  margin-right: 4px;\n  font-style: italic;\n  font-weight: 400;\n  font-size: 12px;\n  color: ", ";\n"])), function (props) {
  return props.color || colors.gray4;
});
var MessageStatusDeleted = styled.span(_templateObject15$2 || (_templateObject15$2 = _taggedTemplateLiteralLoose(["\n  color: ", ";\n  font-style: italic;\n"])), colors.gray9);
var MessageBody = styled.div(_templateObject16$1 || (_templateObject16$1 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  background-color: ", ";\n  //display: inline-block;\n  border-radius: ", ";\n  max-width: ", ";\n  padding: ", ";\n  direction: ", ";\n  overflow: ", ";\n  transition: all 0.3s;\n  transform-origin: right;\n  &:hover .message_actions_cont {\n      visibility: visible;\n      opacity: 1;\n    }\n  }\n"])), function (props) {
  return props.isSelfMessage ? props.ownMessageBackground : props.incomingMessageBackground;
}, function (props) {
  return props.borderRadius || '4px 16px 16px 4px';
}, function (props) {
  return props.withAttachments ? props.attachmentWidth && props.attachmentWidth < 420 ? props.attachmentWidth < 130 ? props.parentMessageAttachmentType && props.parentMessageAttachmentType === attachmentTypes.voice ? '210px' : '130px' : props.attachmentWidth + "px" : '420px' : '100%';
}, function (props) {
  return props.withAttachments ? props.isReplyMessage ? '1px 0 0 ' : '0' : props.isSelfMessage ? '8px 12px' : '8px 12px 8px 12px';
}, function (props) {
  return props.isSelfMessage ? 'initial' : '';
}, function (props) {
  return props.noBody && 'hidden';
});
var MessageContent = styled.div(_templateObject17$1 || (_templateObject17$1 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  margin-left: 13px;\n  margin-right: 13px;\n  //transform: ", ";\n  max-width: ", ";\n\n  display: flex;\n  flex-direction: column;\n"])), function (props) {
  return !props.withAvatar && (props.rtl ? 'translate(-32px,0)  ' : 'translate(32px,0)');
}, function (props) {
  return props.messageWidthPercent ? props.messageWidthPercent + "%" : '100%';
});
var VoiceIconWrapper = styled(SvgVoiceIcon)(_templateObject18$1 || (_templateObject18$1 = _taggedTemplateLiteralLoose(["\n  transform: translate(0px, 3.5px);\n  color: ", ";\n"])), function (props) {
  return props.color || colors.primary;
});
var MessageItem = styled.div(_templateObject19$1 || (_templateObject19$1 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  position: relative;\n  margin-top: ", ";\n  margin-bottom: ", ";\n  padding: 0 40px;\n  padding-left: ", ";\n  padding-right: ", ";\n  transition: all 0.2s;\n  width: 100%;\n  box-sizing: border-box;\n\n  ", "\n  /* &:last-child {\n    margin-bottom: 0;\n  }*/\n\n  &:hover {\n    background-color: ", ";\n  }\n\n  &:hover ", " {\n    display: inline-block;\n  }\n  &:hover ", " {\n    display: flex;\n  }\n\n  &:hover ", " {\n    visibility: visible;\n  }\n"])), function (props) {
  return props.topMargin || '12px';
}, function (props) {
  return props.bottomMargin;
}, function (props) {
  return !props.withAvatar && !props.rtl && '72px';
}, function (props) {
  return !props.withAvatar && props.rtl && '72px';
}, function (props) {
  return props.rtl && 'direction: rtl;';
}, function (props) {
  return props.hoverBackground || '';
}, HiddenMessageTime, MessageStatusAndTime, MessageStatus);

var _path$O;

function _extends$R() {
  _extends$R = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$R.apply(this, arguments);
}

function SvgSliderButtonRight(props) {
  return /*#__PURE__*/createElement("svg", _extends$R({
    width: 28,
    height: 28,
    viewBox: "0 0 28.01 28.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$O || (_path$O = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M9.846 5.763a1.75 1.75 0 012.475 0l7 7a1.75 1.75 0 010 2.474l-7 7a1.75 1.75 0 11-2.475-2.474L15.61 14 9.846 8.237a1.75 1.75 0 010-2.474z",
    fill: "#fff"
  })));
}

var _path$P;

function _extends$S() {
  _extends$S = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$S.apply(this, arguments);
}

function SvgSliderButtonLeft(props) {
  return /*#__PURE__*/createElement("svg", _extends$S({
    width: 28,
    height: 28,
    viewBox: "0 0 28.01 28.01",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$P || (_path$P = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M18.154 5.763a1.75 1.75 0 00-2.475 0l-7 7a1.75 1.75 0 000 2.474l7 7a1.75 1.75 0 102.475-2.474L12.392 14l5.762-5.763a1.75 1.75 0 000-2.474z",
    fill: "#fff"
  })));
}

var _path$Q;

function _extends$T() {
  _extends$T = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$T.apply(this, arguments);
}

function SvgVideoPlayerPlay(props) {
  return /*#__PURE__*/createElement("svg", _extends$T({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$Q || (_path$Q = /*#__PURE__*/createElement("path", {
    d: "M16.28 8.913c.793.48.793 1.692 0 2.172l-8.265 4.997c-.787.475-1.765-.126-1.765-1.086V5.002c0-.96.979-1.561 1.765-1.086l8.265 4.997z",
    fill: "#fff"
  })));
}

var _path$R;

function _extends$U() {
  _extends$U = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$U.apply(this, arguments);
}

function SvgVideoPlayerPause(props) {
  return /*#__PURE__*/createElement("svg", _extends$U({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$R || (_path$R = /*#__PURE__*/createElement("path", {
    d: "M7.468 3.75c.446 0 .607.046.77.134.163.087.291.215.378.378.088.163.134.324.134.77v9.936c0 .446-.046.607-.134.77a.908.908 0 01-.378.378c-.163.088-.324.134-.77.134H6.282c-.446 0-.607-.046-.77-.134a.908.908 0 01-.378-.378c-.088-.162-.134-.324-.134-.77V5.032c0-.446.046-.607.134-.77a.909.909 0 01.378-.378c.163-.088.324-.134.77-.134h1.186zm6.25 0c.446 0 .607.046.77.134.163.087.291.215.378.378.088.163.134.324.134.77v9.936c0 .446-.046.607-.134.77a.908.908 0 01-.378.378c-.162.088-.324.134-.77.134h-1.186c-.446 0-.607-.046-.77-.134a.908.908 0 01-.378-.378c-.088-.162-.134-.324-.134-.77V5.032c0-.446.046-.607.134-.77a.908.908 0 01.378-.378c.162-.088.324-.134.77-.134h1.186z",
    fill: "#fff"
  })));
}

var _path$S;

function _extends$V() {
  _extends$V = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$V.apply(this, arguments);
}

function SvgVolume(props) {
  return /*#__PURE__*/createElement("svg", _extends$V({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$S || (_path$S = /*#__PURE__*/createElement("path", {
    d: "M11.667 2.5c.46 0 .833.373.833.833v13.334c0 .46-.373.833-.833.833a2.062 2.062 0 01-1.433-.579L5.66 12.5H3.334c-.92 0-1.667-.746-1.667-1.667V9.167c0-.92.746-1.667 1.667-1.667h2.304l4.595-4.422c.385-.37.9-.578 1.434-.578zm4.487 2.786a.75.75 0 011.06 0 6.667 6.667 0 010 9.428.75.75 0 01-1.06-1.06 5.167 5.167 0 000-7.307.75.75 0 010-1.061zm-2.122 2.121a.75.75 0 011.061 0 3.667 3.667 0 010 5.186.75.75 0 01-1.06-1.06 2.167 2.167 0 000-3.065.75.75 0 010-1.06z",
    fill: "#fff"
  })));
}

var _path$T;

function _extends$W() {
  _extends$W = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$W.apply(this, arguments);
}

function SvgVolumeMute(props) {
  return /*#__PURE__*/createElement("svg", _extends$W({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$T || (_path$T = /*#__PURE__*/createElement("path", {
    d: "M4.763 2.746l11.655 11.658a.833.833 0 01-1.1 1.248l-.078-.07-2.74-2.74v3.825c0 .427-.321.78-.736.827l-.097.006a2.062 2.062 0 01-1.433-.579L5.66 12.5H3.334c-.92 0-1.667-.746-1.667-1.667V9.167c0-.92.746-1.667 1.667-1.667h2.304l.775-.747-2.829-2.828a.833.833 0 011.179-1.179zm6.904-.246c.46 0 .833.373.833.833v4.8L8.812 4.445l1.421-1.367a2.068 2.068 0 011.274-.572l.16-.006z",
    fill: "#fff"
  })));
}

var _path$U;

function _extends$X() {
  _extends$X = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$X.apply(this, arguments);
}

function SvgFullscreen(props) {
  return /*#__PURE__*/createElement("svg", _extends$X({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$U || (_path$U = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M11.875 3.344c0-.466.378-.844.844-.844h3.937c.466 0 .844.378.844.844V7.28a.844.844 0 01-1.688 0v-1.9l-3.434 3.434a.844.844 0 01-1.193-1.193l3.434-3.434h-1.9a.844.844 0 01-.844-.844zM8.815 11.185c.33.33.33.863 0 1.193l-3.434 3.434H7.28a.844.844 0 010 1.688H3.344a.844.844 0 01-.844-.844V12.72a.844.844 0 111.688 0v1.9l3.434-3.434a.844.844 0 011.193 0z",
    fill: "#fff"
  })));
}

var _path$V;

function _extends$Y() {
  _extends$Y = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$Y.apply(this, arguments);
}

function SvgFullscreenExit(props) {
  return /*#__PURE__*/createElement("svg", _extends$Y({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$V || (_path$V = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M3.438 11.781c0-.466.377-.844.843-.844H8.22c.466 0 .844.378.844.844v3.938a.844.844 0 01-1.688 0v-1.9L3.94 17.252a.844.844 0 11-1.193-1.193l3.435-3.435h-1.9a.844.844 0 01-.844-.844zM17.253 2.747c.33.33.33.864 0 1.193l-3.435 3.435h1.899a.844.844 0 110 1.688h-3.936a.844.844 0 01-.844-.844V4.28a.844.844 0 011.688 0v1.9l3.435-3.434a.844.844 0 011.193 0z",
    fill: "#fff"
  })));
}

var _templateObject$r, _templateObject2$p, _templateObject3$j, _templateObject4$g, _templateObject5$c, _templateObject6$c, _templateObject7$a, _templateObject8$8, _templateObject9$7, _templateObject10$6;
var timerInterval;

var VideoPlayer = function VideoPlayer(_ref) {
  var src = _ref.src,
      videoFileId = _ref.videoFileId,
      activeFileId = _ref.activeFileId;
  var containerRef = useRef(null);
  var videoRef = useRef(null);
  var progressRef = useRef(null);
  var volumeRef = useRef(null);

  var _useState = useState(false),
      playing = _useState[0],
      setPlaying = _useState[1];

  var _useState2 = useState(0),
      currentTime = _useState2[0],
      setCurrentTime = _useState2[1];

  var _useState3 = useState(0),
      videoTime = _useState3[0],
      setVideoTime = _useState3[1];

  var _useState4 = useState(0),
      progress = _useState4[0],
      setProgress = _useState4[1];

  var _useState5 = useState(0),
      volume = _useState5[0],
      setVolume = _useState5[1];

  var _useState6 = useState(0),
      volumePrevValue = _useState6[0],
      setVolumePrevValue = _useState6[1];

  var _useState7 = useState(false),
      isMuted = _useState7[0],
      setIsMuted = _useState7[1];

  var _useState8 = useState(false),
      isFullScreen = _useState8[0],
      setIsFullScreen = _useState8[1];

  var videoHandler = function videoHandler(control) {
    if (control === 'play') {
      videoRef.current && videoRef.current.play();
      setPlaying(true);
    } else if (control === 'pause') {
      videoRef.current && videoRef.current.pause();
      setPlaying(false);
    }
  };

  var handleProgressInputChange = function handleProgressInputChange(e) {
    var target = e.target;
    var val = target.value;
    setProgress(val);

    if (videoRef.current) {
      videoRef.current.currentTime = val / 100 * videoTime;
    }
  };

  var handleMuteUnmute = function handleMuteUnmute() {
    if (videoRef.current) {
      if (!isMuted) {
        setVolumePrevValue(volume);
        videoRef.current.volume = 0;
        setVolume(0);
      } else {
        videoRef.current.volume = volumePrevValue;
        setVolume(volumePrevValue);
      }

      setIsMuted(!isMuted);
    }
  };

  var handleVolumeInputChange = function handleVolumeInputChange(e) {
    var target = e.target;
    var val = target.value;

    if (val === '0') {
      setIsMuted(true);
    } else {
      setIsMuted(false);
    }

    setVolume(val);

    if (videoRef.current) {
      videoRef.current.volume = parseFloat(val);
    }
  };

  var handleOpenFullScreen = function handleOpenFullScreen() {
    if (containerRef.current) {
      if (isFullScreen) {
        document.exitFullscreen().then(function () {
          setIsFullScreen(false);
        });
      } else {
        containerRef.current.requestFullscreen().then(function () {
          setIsFullScreen(true);
        });
      }
    }
  };

  useEffect(function () {
    if (progressRef.current) {
      progressRef.current.style.backgroundSize = progress + "%";
    }
  }, [progress]);
  useEffect(function () {
    if (volumeRef.current) {
      volumeRef.current.style.backgroundSize = volume * 100 + "%";
    }
  }, [volume]);
  useEffect(function () {
    if (playing) {
      var vid = document.getElementById('video1');
      var videoDuration = vid ? vid.duration : '';
      timerInterval = setInterval(function () {
        if (videoRef.current && videoDuration) {
          var _videoRef$current, _videoRef$current2;

          setCurrentTime((_videoRef$current = videoRef.current) === null || _videoRef$current === void 0 ? void 0 : _videoRef$current.currentTime);
          setProgress(((_videoRef$current2 = videoRef.current) === null || _videoRef$current2 === void 0 ? void 0 : _videoRef$current2.currentTime) / videoDuration * 100);

          if (videoRef.current.paused) {
            videoRef.current.currentTime = 0;
            setProgress(0);
            setCurrentTime(videoRef.current.currentTime);
            setPlaying(false);
            clearInterval(timerInterval);
          }
        }
      }, 100);
    } else {
      clearInterval(timerInterval);
    }
  }, [playing]);
  useEffect(function () {
    if (videoFileId !== activeFileId) {
      if (videoRef.current) {
        videoRef.current.pause();
        setPlaying(false);
      }
    }
  }, [activeFileId]);
  useEffect(function () {
    var checkVideoInterval;

    if (videoRef.current) {
      checkVideoInterval = setInterval(function () {
        if (videoRef.current && videoRef.current.readyState > 0) {
          setVideoTime(videoRef.current.duration);
          setVolume(videoRef.current.volume);
          setPlaying(true);
          videoRef.current.play();
          clearInterval(checkVideoInterval);
        }
      }, 500);
    }

    return function () {
      clearInterval(timerInterval);
      clearInterval(checkVideoInterval);
    };
  }, []);
  return React__default.createElement(Component$1, {
    ref: containerRef,
    fullScreen: isFullScreen
  }, React__default.createElement("video", {
    onClick: function onClick() {
      return videoHandler(playing ? 'pause' : 'play');
    },
    id: 'video1',
    ref: videoRef,
    className: 'video',
    src: src
  }), React__default.createElement(ControlsContainer, null, React__default.createElement(ProgressBlock, null, React__default.createElement(Progress, {
    ref: progressRef,
    onMouseDown: function onMouseDown(e) {
      return e.stopPropagation();
    },
    onChange: handleProgressInputChange,
    type: 'range',
    value: progress,
    min: '0',
    max: '100'
  })), playing ? React__default.createElement(PlayPauseWrapper, {
    onClick: function onClick() {
      return videoHandler('pause');
    }
  }, React__default.createElement(SvgVideoPlayerPause, null)) : React__default.createElement(PlayPauseWrapper, {
    onClick: function onClick() {
      return videoHandler('play');
    }
  }, React__default.createElement(SvgVideoPlayerPlay, null)), React__default.createElement(ControlTime, null, Math.floor(currentTime / 60) + ':' + ('0' + Math.floor(currentTime % 60)).slice(-2), " /", ' ', Math.floor(videoTime / 60) + ':' + ('0' + Math.floor(videoTime % 60)).slice(-2)), React__default.createElement(VolumeController, null, React__default.createElement(VolumeIconWrapper, {
    onClick: handleMuteUnmute
  }, isMuted ? React__default.createElement(SvgVolumeMute, null) : React__default.createElement(SvgVolume, null)), React__default.createElement(VolumeSlide, {
    ref: volumeRef,
    onMouseDown: function onMouseDown(e) {
      return e.stopPropagation();
    },
    onChange: handleVolumeInputChange,
    type: 'range',
    value: volume,
    min: '0',
    max: '1',
    step: 'any'
  })), React__default.createElement(FullScreenWrapper, {
    onClick: handleOpenFullScreen
  }, isFullScreen ? React__default.createElement(SvgFullscreenExit, null) : React__default.createElement(SvgFullscreen, null))));
};
var Component$1 = styled.div(_templateObject$r || (_templateObject$r = _taggedTemplateLiteralLoose(["\n  display: inline-flex;\n  & > video {\n    ", "\n  }\n"])), function (props) {
  return props.fullScreen && "\n        max-width: inherit !important;\n        max-height: inherit !important;\n        width: 100%;\n        height: 100%;\n        object-fit: contain;\n    ";
});
var PlayPauseWrapper = styled.span(_templateObject2$p || (_templateObject2$p = _taggedTemplateLiteralLoose(["\n  display: inline-block;\n  width: 20px;\n  height: 20px;\n  margin-right: 16px;\n  cursor: pointer;\n  @media (max-width: 768px) {\n    margin-right: 8px;\n    & > svg {\n      width: 18px;\n      height: 18px;\n    }\n  }\n"])));
var ControlsContainer = styled.div(_templateObject3$j || (_templateObject3$j = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  bottom: 16px;\n  left: 0;\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  width: calc(100% - 32px);\n  background-color: transparent;\n  padding: 0 16px;\n  z-index: 20;\n\n  @media (max-width: 768px) {\n    width: calc(100% - 16px);\n    padding: 0 8px;\n  }\n"])));
var ControlTime = styled.span(_templateObject4$g || (_templateObject4$g = _taggedTemplateLiteralLoose(["\n  color: ", ";\n  font-weight: 400;\n  font-size: 15px;\n  line-height: 20px;\n  letter-spacing: -0.2px;\n  @media (max-width: 768px) {\n    font-size: 14px;\n  }\n"])), colors.white);
var ProgressBlock = styled.div(_templateObject5$c || (_templateObject5$c = _taggedTemplateLiteralLoose(["\n  //background-color: rgba(255, 255, 255, 0.4);\n  margin-bottom: 6px;\n  border-radius: 15px;\n  width: 100%;\n  //height: 4px;\n  z-index: 30;\n  position: relative;\n"])));
var VolumeController = styled.div(_templateObject6$c || (_templateObject6$c = _taggedTemplateLiteralLoose(["\n  margin-left: auto;\n  display: flex;\n  align-items: center;\n"])));
var VolumeIconWrapper = styled.span(_templateObject7$a || (_templateObject7$a = _taggedTemplateLiteralLoose(["\n  display: flex;\n  cursor: pointer;\n  @media (max-width: 768px) {\n    & > svg {\n      width: 18px;\n      height: 18px;\n    }\n  }\n"])));
var VolumeSlide = styled.input(_templateObject8$8 || (_templateObject8$8 = _taggedTemplateLiteralLoose(["\n  -webkit-appearance: none;\n  margin-left: 8px;\n  width: 60px;\n  height: 4px;\n  background: rgba(255, 255, 255, 0.6);\n  border-radius: 5px;\n  background-image: linear-gradient(#fff, #fff);\n  //background-size: 70% 100%;\n  background-repeat: no-repeat;\n  cursor: pointer;\n\n  &::-webkit-slider-thumb {\n    visibility: hidden;\n    -webkit-appearance: none;\n    height: 1px;\n    width: 1px;\n    background: #fff;\n    cursor: pointer;\n    box-shadow: 0 0 2px 0 #555;\n    transition: all 0.3s ease-in-out;\n  }\n  &::-moz-range-thumb {\n    visibility: hidden;\n    -webkit-appearance: none;\n    height: 16px;\n    width: 16px;\n    border-radius: 50%;\n    background: #fff;\n    cursor: pointer;\n    box-shadow: 0 0 2px 0 #555;\n    transition: all 0.3s ease-in-out;\n  }\n\n  &::-ms-thumb {\n    visibility: hidden;\n    -webkit-appearance: none;\n    height: 1px;\n    width: 1px;\n    border-radius: 50%;\n    background: #fff;\n    cursor: pointer;\n    box-shadow: 0 0 2px 0 #555;\n    transition: all 0.3s ease-in-out;\n  }\n  &::-webkit-slider-runnable-track {\n    -webkit-appearance: none;\n    box-shadow: none;\n    border: none;\n    background: transparent;\n    transition: all 0.3s ease-in-out;\n  }\n\n  &::-moz-range-track {\n    -webkit-appearance: none;\n    box-shadow: none;\n    border: none;\n    background: transparent;\n    transition: all 0.3s ease-in-out;\n  }\n  &::-ms-track {\n    -webkit-appearance: none;\n    box-shadow: none;\n    border: none;\n    background: transparent;\n    transition: all 0.3s ease-in-out;\n  }\n\n  @media (max-width: 768px) {\n    width: 50px;\n  }\n"])));
var Progress = styled.input(_templateObject9$7 || (_templateObject9$7 = _taggedTemplateLiteralLoose(["\n  -webkit-appearance: none;\n  margin-right: 15px;\n  width: 100%;\n  height: 4px;\n  background: rgba(255, 255, 255, 0.6);\n  border-radius: 5px;\n  background-image: linear-gradient(#fff, #fff);\n  //background-size: 70% 100%;\n  background-repeat: no-repeat;\n  cursor: pointer;\n\n  &::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    height: 16px;\n    width: 16px;\n    border-radius: 50%;\n    background: #fff;\n    cursor: pointer;\n    box-shadow: 0 0 2px 0 #555;\n    transition: all 0.3s ease-in-out;\n  }\n  &::-moz-range-thumb {\n    -webkit-appearance: none;\n    height: 16px;\n    width: 16px;\n    border-radius: 50%;\n    background: #fff;\n    cursor: pointer;\n    box-shadow: 0 0 2px 0 #555;\n    transition: all 0.3s ease-in-out;\n  }\n\n  &::-ms-thumb {\n    -webkit-appearance: none;\n    height: 16px;\n    width: 16px;\n    border-radius: 50%;\n    background: #fff;\n    cursor: pointer;\n    box-shadow: 0 0 2px 0 #555;\n    transition: all 0.3s ease-in-out;\n  }\n\n  &::-webkit-slider-thumb:hover {\n    background: #fff;\n  }\n  &::-moz-range-thumb:hover {\n    background: #fff;\n  }\n  &::-ms-thumb:hover {\n    background: #fff;\n  }\n\n  &::-webkit-slider-runnable-track {\n    -webkit-appearance: none;\n    box-shadow: none;\n    border: none;\n    background: transparent;\n    transition: all 0.3s ease-in-out;\n  }\n\n  &::-moz-range-track {\n    -webkit-appearance: none;\n    box-shadow: none;\n    border: none;\n    background: transparent;\n    transition: all 0.3s ease-in-out;\n  }\n  &::-ms-track {\n    -webkit-appearance: none;\n    box-shadow: none;\n    border: none;\n    background: transparent;\n    transition: all 0.3s ease-in-out;\n  }\n"])));
var FullScreenWrapper = styled.div(_templateObject10$6 || (_templateObject10$6 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  margin-left: 16px;\n  cursor: pointer;\n  @media (max-width: 768px) {\n    margin-left: 12px;\n    & > svg {\n      width: 18px;\n      height: 18px;\n    }\n  }\n"])));

var _templateObject$s, _templateObject2$q, _templateObject3$k, _templateObject4$h, _templateObject5$d, _templateObject6$d, _templateObject7$b, _templateObject8$9, _templateObject9$8, _templateObject10$7, _templateObject11$5, _templateObject12$4, _templateObject13$3, _templateObject14$3;

var SliderPopup = function SliderPopup(_ref) {
  var channelId = _ref.channelId,
      setIsSliderOpen = _ref.setIsSliderOpen,
      mediaFiles = _ref.mediaFiles,
      currentMediaFile = _ref.currentMediaFile;
  var dispatch = useDispatch();
  console.log('media files .... ', mediaFiles);
  var getFromContacts = getShowOnlyContactUsers();
  var ChatClient = getClient();
  var user = ChatClient.user;

  var _useState = useState(currentMediaFile),
      currentFile = _useState[0],
      setCurrentFile = _useState[1];

  var _useState2 = useState([]),
      attachmentsList = _useState2[0],
      setAttachmentsList = _useState2[1];

  var _useState3 = useState(true),
      imageLoading = _useState3[0],
      setImageLoading = _useState3[1];

  var _useState4 = useState({}),
      downloadedFiles = _useState4[0],
      setDownloadedFiles = _useState4[1];

  var _useState5 = useState(),
      playedVideo = _useState5[0],
      setPlayedVideo = _useState5[1];

  var _useState6 = useState(true),
      nextButtonDisabled = _useState6[0],
      setNextButtonDisabled = _useState6[1];

  var _useState7 = useState(true),
      prevButtonDisabled = _useState7[0],
      setPrevButtonDisabled = _useState7[1];

  var customUploader = getCustomUploader();
  var customDownloader = getCustomDownloader();
  var contactsMap = useSelector(contactsMapSelector);
  var attachments = useSelector(attachmentsForPopupSelector, shallowEqual) || [];
  var attachmentUserName = currentFile ? currentFile.user && makeUserName(contactsMap[currentFile.user.id], currentFile.user, getFromContacts && user.id !== currentFile.user.id) : '';

  var handleClosePopup = function handleClosePopup() {
    setAttachmentsList([]);
    setIsSliderOpen(false);
  };

  var downloadImage = function downloadImage(src) {
    var image = new Image();
    image.src = src;

    image.onload = function () {
      var _extends2;

      setDownloadedFiles(_extends({}, downloadedFiles, (_extends2 = {}, _extends2[currentFile.id] = src, _extends2)));
      setImageLoading(false);
    };
  };

  useDidUpdate(function () {
    if (customUploader && currentFile) {
      if (playedVideo) {
        var videoElem = document.getElementById(playedVideo);

        if (videoElem) {
          videoElem.pause();
        }
      }

      getAttachmentUrlFromCache(currentFile.id).then(function (cachedUrl) {
        if (cachedUrl) {
          if (!downloadedFiles[currentFile.id]) {
            if (currentFile.type === 'image') {
              downloadImage(cachedUrl);
            } else {
              var _extends3;

              setDownloadedFiles(_extends({}, downloadedFiles, (_extends3 = {}, _extends3[currentFile.id] = cachedUrl, _extends3)));
              setPlayedVideo(currentFile.id);
            }
          }

          setImageLoading(false);
        } else {
          if (customDownloader) {
            customDownloader(currentFile.url).then(function (url) {
              try {
                return Promise.resolve(fetch(url)).then(function (response) {
                  setAttachmentToCache(currentFile.id, response);

                  if (currentFile.type === 'image') {
                    downloadImage(url);
                  } else {
                    var _extends4;

                    setDownloadedFiles(_extends({}, downloadedFiles, (_extends4 = {}, _extends4[currentFile.id] = url, _extends4)));
                    setPlayedVideo(currentFile.id);
                  }
                });
              } catch (e) {
                return Promise.reject(e);
              }
            });
          } else {
            if (currentFile.type === 'image') {
              downloadImage(currentFile.url);
            } else {
              var _extends5;

              setDownloadedFiles(_extends({}, downloadedFiles, (_extends5 = {}, _extends5[currentFile.id] = currentFile.url, _extends5)));
              setPlayedVideo(currentFile.id);
            }
          }
        }
      });
    }
  }, [currentFile]);
  useDidUpdate(function () {
    var currentMedia = attachmentsList.find(function (att) {
      return att.id === currentMediaFile.id;
    });
    setCurrentFile(currentMedia);

    if (currentMedia) {
      var indexOnList = attachmentsList.findIndex(function (item) {
        return item.id === currentMedia.id;
      });

      if (!attachmentsList[indexOnList + 1]) {
        setNextButtonDisabled(true);
      } else {
        setNextButtonDisabled(false);
      }

      if (!attachmentsList[indexOnList - 1]) {
        setPrevButtonDisabled(true);
      } else {
        setPrevButtonDisabled(false);
      }
    }
  }, [attachmentsList]);
  useDidUpdate(function () {
    setAttachmentsList(attachments || []);
  }, [attachments]);
  useEffect(function () {
    if (customDownloader && currentMediaFile) {
      getAttachmentUrlFromCache(currentMediaFile.id).then(function (cachedUrl) {
        if (cachedUrl) {
          if (currentMediaFile.type === 'image') {
            downloadImage(cachedUrl);
          } else {
            var _extends6;

            setDownloadedFiles(_extends({}, downloadedFiles, (_extends6 = {}, _extends6[currentMediaFile.id] = cachedUrl, _extends6)));
            setPlayedVideo(currentMediaFile.id);
          }
        } else {
          if (customDownloader) {
            customDownloader(currentMediaFile.url).then(function (url) {
              try {
                return Promise.resolve(fetch(url)).then(function (response) {
                  setAttachmentToCache(currentMediaFile.id, response);

                  if (currentMediaFile.type === 'image') {
                    downloadImage(url);
                  } else {
                    var _extends7;

                    setDownloadedFiles(_extends({}, downloadedFiles, (_extends7 = {}, _extends7[currentMediaFile.id] = url, _extends7)));
                    setPlayedVideo(currentMediaFile.id);
                  }
                });
              } catch (e) {
                return Promise.reject(e);
              }
            });
          } else {
            downloadImage(currentMediaFile.url);
          }
        }
      });
    }

    if (currentMediaFile) {
      if (mediaFiles) {
        setAttachmentsList(mediaFiles);
      } else {
        dispatch(getAttachmentsAC(channelId, channelDetailsTabs.media, 35, queryDirection.NEAR, currentMediaFile.id, true));
      }
    }

    return function () {
      setAttachmentsList([]);
    };
  }, []);
  return React__default.createElement(Container$c, null, React__default.createElement(SliderHeader, null, React__default.createElement(FileInfo, null, React__default.createElement(Avatar, {
    name: attachmentUserName,
    setDefaultAvatar: true,
    size: 36,
    image: currentFile && currentFile.user && currentFile.user.avatarUrl
  }), React__default.createElement(Info, null, React__default.createElement(UserName, null, attachmentUserName), React__default.createElement(FileDateAndSize, null, moment(currentFile && currentFile.updatedAt).format('DD.MM.YYYY HH:mm'), ' ', React__default.createElement(FileSize, null, currentFile && currentFile.fileSize && currentFile.fileSize > 0 ? bytesToSize(currentFile.fileSize, 1) : '')))), React__default.createElement(ActionDownload, {
    onClick: function onClick() {
      return downloadFile(currentFile);
    }
  }, React__default.createElement(SvgDownload, null)), React__default.createElement(Actions, null, React__default.createElement(ActionItem, {
    onClick: handleClosePopup
  }, React__default.createElement(SvgClose, null)))), React__default.createElement(SliderBody, null, !!(attachmentsList && attachmentsList.length) && React__default.createElement(Carousel, {
    draggable: false,
    pagination: false,
    className: 'custom_carousel',
    initialActiveIndex: currentFile && attachmentsList.findIndex(function (item) {
      return item.id === currentFile.id;
    }),
    onChange: function onChange(_currentItem, pageIndex) {
      setImageLoading(true);
      setCurrentFile(attachmentsList[pageIndex]);

      if (!attachmentsList[pageIndex + 1]) {
        setNextButtonDisabled(true);
      } else {
        setNextButtonDisabled(false);
      }

      if (!attachmentsList[pageIndex - 1]) {
        setPrevButtonDisabled(true);
      } else {
        setPrevButtonDisabled(false);
      }
    },
    renderArrow: function renderArrow(_ref2) {
      var type = _ref2.type,
          _onClick = _ref2.onClick,
          isEdge = _ref2.isEdge;
      var pointer = type === 'PREV' ? React__default.createElement(SvgSliderButtonLeft, null) : React__default.createElement(SvgSliderButtonRight, null);
      var disabled = type === 'PREV' ? prevButtonDisabled : nextButtonDisabled;
      return React__default.createElement(ArrowButton, {
        leftButton: type === 'PREV',
        type: 'button',
        onClick: function onClick(e) {
          e.preventDefault();

          _onClick();
        },
        disabled: isEdge,
        hide: disabled
      }, pointer);
    },
    isRTL: false
  }, attachmentsList.map(function (file) {
    return React__default.createElement(CarouselItem, {
      key: file.id,
      draggable: false
    }, downloadedFiles[file.id] ? React__default.createElement(React__default.Fragment, null, file.type === 'image' ? React__default.createElement(React__default.Fragment, null, imageLoading ? React__default.createElement(UploadCont, null, React__default.createElement(UploadingIcon, null)) : React__default.createElement("img", {
      draggable: false,
      src: downloadedFiles[file.id],
      alt: file.name
    })) : React__default.createElement(React__default.Fragment, null, React__default.createElement(VideoPlayer, {
      activeFileId: currentFile.id,
      videoFileId: file.id,
      src: downloadedFiles[file.id]
    }))) : React__default.createElement(UploadingIcon, null));
  }))));
};
var Container$c = styled.div(_templateObject$s || (_templateObject$s = _taggedTemplateLiteralLoose(["\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  height: 100vh;\n  z-index: 999;\n"])));
var SliderHeader = styled.div(_templateObject2$q || (_templateObject2$q = _taggedTemplateLiteralLoose(["\n  height: 60px;\n  background: ", ";\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0 16px;\n"])), colors.gray6);
var SliderBody = styled.div(_templateObject3$k || (_templateObject3$k = _taggedTemplateLiteralLoose(["\n  width: 100%;\n  height: calc(100% - 60px);\n  background: rgba(0, 0, 0, 0.8);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  & .rec-carousel-item {\n    display: flex;\n    align-items: center;\n  }\n"])));
var FileInfo = styled.div(_templateObject4$h || (_templateObject4$h = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  width: 40%;\n  font-style: normal;\n  font-weight: normal;\n  font-size: 14px;\n  line-height: 14px;\n  color: ", ";\n"])), colors.white);
var Info = styled.div(_templateObject5$d || (_templateObject5$d = _taggedTemplateLiteralLoose(["\n  margin-left: 12px;\n"])));
var Actions = styled.div(_templateObject6$d || (_templateObject6$d = _taggedTemplateLiteralLoose(["\n  width: 40%;\n  display: flex;\n  justify-content: flex-end;\n  color: ", ";\n"])), colors.white);
var FileDateAndSize = styled.span(_templateObject7$b || (_templateObject7$b = _taggedTemplateLiteralLoose(["\n  font-weight: 400;\n  font-size: 13px;\n  line-height: 16px;\n  letter-spacing: -0.078px;\n  color: ", ";\n"])), colors.gray9);
var FileSize = styled.span(_templateObject8$9 || (_templateObject8$9 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  margin-left: 12px;\n\n  &:after {\n    content: '';\n    position: absolute;\n    left: -10px;\n    top: 6px;\n    width: 4px;\n    height: 4px;\n    border-radius: 50%;\n    background-color: ", ";\n  }\n"])), colors.gray9);
var UserName = styled.h4(_templateObject9$8 || (_templateObject9$8 = _taggedTemplateLiteralLoose(["\n  margin: 0;\n  color: ", "\n  font-weight: 500;\n  font-size: 15px;\n  line-height: 18px;\n  letter-spacing: -0.2px;\n"])), colors.white);
var ActionItem = styled.span(_templateObject10$7 || (_templateObject10$7 = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n"])));
var ActionDownload = styled.div(_templateObject11$5 || (_templateObject11$5 = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n  color: ", ";\n\n  & > svg {\n    width: 28px;\n    height: 28px;\n  }\n"])), colors.white);
var CarouselItem = styled.div(_templateObject12$4 || (_templateObject12$4 = _taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  img,\n  video {\n    //max-width: calc(100vw - 300px);\n    min-width: 280px;\n    max-width: 100%;\n    max-height: calc(100vh - 200px);\n  }\n"])));
var UploadCont = styled.div(_templateObject13$3 || (_templateObject13$3 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  min-height: 100px;\n  min-width: 100px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n"])));
var ArrowButton = styled.button(_templateObject14$3 || (_templateObject14$3 = _taggedTemplateLiteralLoose(["\n  min-width: 60px;\n  max-width: 60px;\n  height: 60px;\n  margin-right: ", ";\n  margin-left: ", ";\n  background: ", ";\n  border: 1px solid rgba(0, 0, 0, 0.1);\n  box-sizing: border-box;\n  border-radius: 50%;\n  line-height: 1px;\n  align-self: center;\n  outline: none;\n  cursor: pointer;\n  visibility: ", ";\n  @media (max-width: 768px) {\n    min-width: 36px;\n    max-width: 36px;\n    height: 36px;\n    margin-right: ", ";\n    margin-left: ", ";\n\n    & > svg {\n      width: 22px;\n      height: 22px;\n    }\n  }\n  @media (max-width: 450px) {\n    min-width: 32px;\n    max-width: 32px;\n    height: 32px;\n\n    & > svg {\n      width: 20px;\n      height: 20px;\n    }\n  }\n"])), function (props) {
  return !props.leftButton && '24px';
}, function (props) {
  return props.leftButton && '24px';
}, colors.gray6, function (props) {
  return props.hide && 'hidden';
}, function (props) {
  return !props.leftButton && '4px';
}, function (props) {
  return props.leftButton && '4px';
});

var _path$W;

function _extends$Z() {
  _extends$Z = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$Z.apply(this, arguments);
}

function SvgChoseMedia(props) {
  return /*#__PURE__*/createElement("svg", _extends$Z({
    width: 18,
    height: 18,
    viewBox: "0 0 19 19",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$W || (_path$W = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M3.614 2.052C4.366 1.65 5.107 1.5 6.798 1.5h4.404c1.691 0 2.432.15 3.184.552.672.36 1.203.89 1.562 1.562.402.752.552 1.493.552 3.184v4.404c0 1.691-.15 2.432-.552 3.184a3.763 3.763 0 01-1.562 1.562c-.752.402-1.493.552-3.184.552H6.798c-1.691 0-2.432-.15-3.184-.552a3.764 3.764 0 01-1.562-1.562c-.402-.752-.552-1.493-.552-3.184V6.798c0-1.691.15-2.432.552-3.184.36-.672.89-1.203 1.562-1.562zm7.16 7.07a.297.297 0 01.482.004l3.04 4.193c.101.139.074.335-.06.44a.297.297 0 01-.183.062h-9.57a.309.309 0 01-.304-.314c0-.07.022-.137.064-.192l2.22-2.954a.297.297 0 01.473-.008l1.528 1.861 2.31-3.092zM5.785 6.857a1.071 1.071 0 100-2.143 1.071 1.071 0 000 2.143z",
    fill: "CurrentColor"
  })));
}

var _templateObject$t, _templateObject2$r, _templateObject3$l, _templateObject4$i, _templateObject5$e, _templateObject6$e, _templateObject7$c, _templateObject8$a, _templateObject9$9;
var loading = false;
var loadFromServer = false;
var loadDirection = '';
var nextDisable = false;
var prevDisable = false;
var prevMessageId = '';

var CreateMessageDateDivider = function CreateMessageDateDivider(_ref) {
  var lastIndex = _ref.lastIndex,
      currentMessageDate = _ref.currentMessageDate,
      nextMessageDate = _ref.nextMessageDate,
      messagesHasNext = _ref.messagesHasNext,
      dateDividerFontSize = _ref.dateDividerFontSize,
      dateDividerTextColor = _ref.dateDividerTextColor,
      dateDividerBorder = _ref.dateDividerBorder,
      dateDividerBackgroundColor = _ref.dateDividerBackgroundColor,
      dateDividerBorderRadius = _ref.dateDividerBorderRadius,
      noMargin = _ref.noMargin;
  var today = moment().endOf('day');
  var current = moment(currentMessageDate).endOf('day');
  var differentDays = !(nextMessageDate && current.diff(moment(nextMessageDate).endOf('day'), 'days') === 0);
  var dividerText = '';

  if (differentDays && !today.diff(current, 'days')) {
    dividerText = 'Today';
  } else if (differentDays) {
    dividerText = moment().year() === moment(current).year() ? current.format('MMMM D') : current.format('MMMM D YYYY');
  }

  return !differentDays ? null : React__default.createElement(MessageDivider, {
    dividerText: dividerText,
    visibility: messagesHasNext && lastIndex,
    dateDividerFontSize: dateDividerFontSize,
    dateDividerTextColor: dateDividerTextColor,
    dateDividerBorder: dateDividerBorder,
    dateDividerBackgroundColor: dateDividerBackgroundColor,
    dateDividerBorderRadius: dateDividerBorderRadius,
    noMargin: noMargin
  });
};

var MessageList = function MessageList(_ref2) {
  var fontFamily = _ref2.fontFamily,
      _ref2$ownMessageOnRig = _ref2.ownMessageOnRightSide,
      ownMessageOnRightSide = _ref2$ownMessageOnRig === void 0 ? true : _ref2$ownMessageOnRig,
      messageWidthPercent = _ref2.messageWidthPercent,
      messageTimePosition = _ref2.messageTimePosition,
      ownMessageBackground = _ref2.ownMessageBackground,
      incomingMessageBackground = _ref2.incomingMessageBackground,
      showMessageStatus = _ref2.showMessageStatus,
      hoverBackground = _ref2.hoverBackground,
      _ref2$showSenderNameO = _ref2.showSenderNameOnDirectChannel,
      showSenderNameOnDirectChannel = _ref2$showSenderNameO === void 0 ? false : _ref2$showSenderNameO,
      _ref2$showSenderNameO2 = _ref2.showSenderNameOnOwnMessages,
      showSenderNameOnOwnMessages = _ref2$showSenderNameO2 === void 0 ? false : _ref2$showSenderNameO2,
      _ref2$showOwnAvatar = _ref2.showOwnAvatar,
      showOwnAvatar = _ref2$showOwnAvatar === void 0 ? false : _ref2$showOwnAvatar,
      _ref2$messageReaction = _ref2.messageReaction,
      messageReaction = _ref2$messageReaction === void 0 ? false : _ref2$messageReaction,
      _ref2$editMessage = _ref2.editMessage,
      editMessage = _ref2$editMessage === void 0 ? false : _ref2$editMessage,
      _ref2$copyMessage = _ref2.copyMessage,
      copyMessage = _ref2$copyMessage === void 0 ? false : _ref2$copyMessage,
      _ref2$replyMessage = _ref2.replyMessage,
      replyMessage = _ref2$replyMessage === void 0 ? false : _ref2$replyMessage,
      _ref2$replyMessageInT = _ref2.replyMessageInThread,
      replyMessageInThread = _ref2$replyMessageInT === void 0 ? false : _ref2$replyMessageInT,
      _ref2$forwardMessage = _ref2.forwardMessage,
      forwardMessage = _ref2$forwardMessage === void 0 ? false : _ref2$forwardMessage,
      _ref2$deleteMessage = _ref2.deleteMessage,
      deleteMessage = _ref2$deleteMessage === void 0 ? false : _ref2$deleteMessage,
      _ref2$reportMessage = _ref2.reportMessage,
      reportMessage = _ref2$reportMessage === void 0 ? false : _ref2$reportMessage,
      reactionIcon = _ref2.reactionIcon,
      editIcon = _ref2.editIcon,
      copyIcon = _ref2.copyIcon,
      replyIcon = _ref2.replyIcon,
      replyInThreadIcon = _ref2.replyInThreadIcon,
      forwardIcon = _ref2.forwardIcon,
      deleteIcon = _ref2.deleteIcon,
      _ref2$allowEditDelete = _ref2.allowEditDeleteIncomingMessage,
      allowEditDeleteIncomingMessage = _ref2$allowEditDelete === void 0 ? true : _ref2$allowEditDelete,
      starIcon = _ref2.starIcon,
      staredIcon = _ref2.staredIcon,
      reportIcon = _ref2.reportIcon,
      reactionIconOrder = _ref2.reactionIconOrder,
      reactionsDisplayCount = _ref2.reactionsDisplayCount,
      showEachReactionCount = _ref2.showEachReactionCount,
      reactionItemBorder = _ref2.reactionItemBorder,
      reactionItemBorderRadius = _ref2.reactionItemBorderRadius,
      reactionItemBackground = _ref2.reactionItemBackground,
      reactionItemPadding = _ref2.reactionItemPadding,
      reactionItemMargin = _ref2.reactionItemMargin,
      reactionsFontSize = _ref2.reactionsFontSize,
      reactionsContainerBoxShadow = _ref2.reactionsContainerBoxShadow,
      reactionsContainerBorder = _ref2.reactionsContainerBorder,
      reactionsContainerBorderRadius = _ref2.reactionsContainerBorderRadius,
      reactionsContainerBackground = _ref2.reactionsContainerBackground,
      reactionsContainerPadding = _ref2.reactionsContainerPadding,
      reactionsContainerTopPosition = _ref2.reactionsContainerTopPosition,
      editIconOrder = _ref2.editIconOrder,
      copyIconOrder = _ref2.copyIconOrder,
      replyIconOrder = _ref2.replyIconOrder,
      replyInThreadIconOrder = _ref2.replyInThreadIconOrder,
      forwardIconOrder = _ref2.forwardIconOrder,
      deleteIconOrder = _ref2.deleteIconOrder,
      starIconOrder = _ref2.starIconOrder,
      reportIconOrder = _ref2.reportIconOrder,
      reactionIconTooltipText = _ref2.reactionIconTooltipText,
      editIconTooltipText = _ref2.editIconTooltipText,
      copyIconTooltipText = _ref2.copyIconTooltipText,
      replyIconTooltipText = _ref2.replyIconTooltipText,
      replyInThreadIconTooltipText = _ref2.replyInThreadIconTooltipText,
      forwardIconTooltipText = _ref2.forwardIconTooltipText,
      deleteIconTooltipText = _ref2.deleteIconTooltipText,
      starIconTooltipText = _ref2.starIconTooltipText,
      reportIconTooltipText = _ref2.reportIconTooltipText,
      messageActionIconsColor = _ref2.messageActionIconsColor,
      dateDividerFontSize = _ref2.dateDividerFontSize,
      dateDividerTextColor = _ref2.dateDividerTextColor,
      dateDividerBorder = _ref2.dateDividerBorder,
      dateDividerBackgroundColor = _ref2.dateDividerBackgroundColor,
      dateDividerBorderRadius = _ref2.dateDividerBorderRadius,
      _ref2$showTopFixedDat = _ref2.showTopFixedDate,
      showTopFixedDate = _ref2$showTopFixedDat === void 0 ? true : _ref2$showTopFixedDat,
      inlineReactionIcon = _ref2.inlineReactionIcon,
      newMessagesSeparatorText = _ref2.newMessagesSeparatorText,
      newMessagesSeparatorFontSize = _ref2.newMessagesSeparatorFontSize,
      newMessagesSeparatorTextColor = _ref2.newMessagesSeparatorTextColor,
      newMessagesSeparatorWidth = _ref2.newMessagesSeparatorWidth,
      newMessagesSeparatorBorder = _ref2.newMessagesSeparatorBorder,
      newMessagesSeparatorBorderRadius = _ref2.newMessagesSeparatorBorderRadius,
      newMessagesSeparatorBackground = _ref2.newMessagesSeparatorBackground,
      newMessagesSeparatorTextLeftRightSpacesWidth = _ref2.newMessagesSeparatorTextLeftRightSpacesWidth,
      fileAttachmentsIcon = _ref2.fileAttachmentsIcon,
      fileAttachmentsBoxWidth = _ref2.fileAttachmentsBoxWidth,
      fileAttachmentsBoxBackground = _ref2.fileAttachmentsBoxBackground,
      fileAttachmentsBoxBorder = _ref2.fileAttachmentsBoxBorder,
      fileAttachmentsTitleColor = _ref2.fileAttachmentsTitleColor,
      fileAttachmentsSizeColor = _ref2.fileAttachmentsSizeColor;
  var dispatch = useDispatch();
  var getFromContacts = getShowOnlyContactUsers();
  var channel = useSelector(activeChannelSelector);
  var ChatClient = getClient();
  var user = ChatClient.user;
  var contactsMap = useSelector(contactsMapSelector);
  var scrollToNewMessage = useSelector(scrollToNewMessageSelector, shallowEqual);
  var scrollToRepliedMessage = useSelector(scrollToMessageSelector, shallowEqual);
  var browserTabIsActive = useSelector(browserTabIsActiveSelector, shallowEqual);
  var hasNextMessages = useSelector(messagesHasNextSelector, shallowEqual);
  var hasPrevMessages = useSelector(messagesHasPrevSelector, shallowEqual);
  var messagesLoading = useSelector(messagesLoadingState);
  var draggingSelector = useSelector(isDraggingSelector, shallowEqual);

  var _useState = useState(''),
      unreadMessageId = _useState[0],
      setUnreadMessageId = _useState[1];

  var _useState2 = useState(null),
      mediaFile = _useState2[0],
      setMediaFile = _useState2[1];

  var _useState3 = useState(null),
      isDragging = _useState3[0],
      setIsDragging = _useState3[1];

  var _useState4 = useState(''),
      lastVisibleMessageId = _useState4[0],
      _setLastVisibleMessageId = _useState4[1];

  var _useState5 = useState(null),
      scrollToReply = _useState5[0],
      setScrollToReply = _useState5[1];

  var messages = useSelector(activeChannelMessagesSelector) || [];
  var currentChannelPendingMessages = [];
  var messageForReply = {};
  var attachmentsSelected = false;
  var messagesBoxRef = useRef(null);
  var messageTopDateRef = useRef(null);
  var scrollRef = useRef(null);

  var renderTopDate = function renderTopDate() {
    var dateLabels = document.querySelectorAll('.divider');
    var messageTopDate = messageTopDateRef.current;
    var text = '';

    for (var i = dateLabels.length - 1; i >= 0; i--) {
      var _dateLabel$firstChild;

      var dateLabel = dateLabels[i];
      var span = dateLabel === null || dateLabel === void 0 ? void 0 : (_dateLabel$firstChild = dateLabel.firstChild) === null || _dateLabel$firstChild === void 0 ? void 0 : _dateLabel$firstChild.firstChild;

      if (!text && scrollRef.current.scrollTop > dateLabel.offsetTop) {
        text = span && span.innerText;
        span.style.display = 'none';
      } else {
        span.style.display = 'block';
      }
    }

    if (text) {
      messageTopDate.innerText = text;
      messageTopDate.style.display = 'inline';
    } else {
      messageTopDate.style.display = 'none';
    }
  };

  var handleMessagesListScroll = function handleMessagesListScroll(event) {
    try {
      var lastVisibleMessage = document.getElementById(lastVisibleMessageId);
      renderTopDate();
      var target = event.target;
      var lastVisibleMessagePos = lastVisibleMessage && lastVisibleMessage.offsetTop;

      if (scrollToReply) {
        target.scrollTop = scrollToReply;
      } else {
        if (target.scrollTop <= -50) {
          dispatch(showScrollToNewMessageButtonAC(true));
        } else {
          dispatch(showScrollToNewMessageButtonAC(false));
        }

        var scrollHeightQuarter = target.scrollHeight * 20 / 100;

        if (!prevDisable && messagesLoading !== LOADING_STATE.LOADING && !scrollToRepliedMessage && -target.scrollTop >= target.scrollHeight - target.offsetHeight - scrollHeightQuarter && !loading && !scrollToNewMessage.scrollToBottom) {
          loadDirection = 'prev';
          prevMessageId = messages[0].id;
          handleLoadMoreMessages(MESSAGE_LOAD_DIRECTION.PREV, LOAD_MAX_MESSAGE_COUNT);

          if (!getHasPrevCached()) {
            loadFromServer = true;
          }

          nextDisable = true;
        }

        if (lastVisibleMessagePos - 420 > target.scrollTop) {
          nextDisable = false;
        } else {
          prevDisable = false;
        }

        if (!nextDisable && messagesLoading !== LOADING_STATE.LOADING && (hasNextMessages || getHasNextCached()) && -target.scrollTop <= 400 && !loading && !scrollToNewMessage.scrollToBottom) {
          loadDirection = 'next';
          prevDisable = true;
          handleLoadMoreMessages(MESSAGE_LOAD_DIRECTION.NEXT, LOAD_MAX_MESSAGE_COUNT);
        }
      }

      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var handleScrollToRepliedMessage = function handleScrollToRepliedMessage(messageId) {
    try {
      prevDisable = true;
      nextDisable = true;

      if (messages.findIndex(function (msg) {
        return msg.id === messageId;
      }) >= 10) {
        console.log('handle scroll to reply message .... ');
        var repliedMessage = document.getElementById(messageId);
        console.log(' scroll to message .... ', repliedMessage);

        if (repliedMessage) {
          scrollRef.current.scrollTop = repliedMessage.offsetTop - scrollRef.current.offsetHeight / 2;
          repliedMessage.classList.add('highlight');
          setTimeout(function () {
            repliedMessage.classList.remove('highlight');
            prevDisable = false;
            nextDisable = false;
          }, 1000);
        }
      } else {
        dispatch(getMessagesAC(channel, undefined, messageId));
      }

      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var handleLoadMoreMessages = function handleLoadMoreMessages(direction, limit) {
    var lastMessageId = messages.length && messages[messages.length - 1].id;
    var firstMessageId = messages.length && messages[0].id;
    var hasPrevCached = getHasPrevCached();
    var hasNextCached = getHasNextCached();

    if (!loading) {
      if (direction === MESSAGE_LOAD_DIRECTION.PREV && firstMessageId && (hasPrevMessages || hasPrevCached)) {
        loading = true;
        dispatch(loadMoreMessagesAC(channel.id, limit, direction, firstMessageId, hasPrevMessages));
      } else if (direction === MESSAGE_LOAD_DIRECTION.NEXT && lastMessageId && (hasNextMessages || hasNextCached)) {
        loading = true;
        dispatch(loadMoreMessagesAC(channel.id, limit, direction, lastMessageId, hasNextMessages));
      }
    }
  };

  var handleDragIn = function handleDragIn(e) {
    e.preventDefault();

    if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
      var filesType = 'file';
      var fileList = Array.from(e.dataTransfer.items);
      fileList.forEach(function (file) {
        var fileType = file.type.split('/')[0];

        if (fileType === 'image' || fileType === 'video') {
          filesType = 'media';
        }
      });
      setIsDragging(filesType);
    }
  };

  var handleDragOver = function handleDragOver(e) {
    e.preventDefault();
    e.target && e.target.classList.add('dragover');
  };

  var handleDragOut = function handleDragOut(e) {
    if (e.target.classList.contains('dragover')) {
      e.target.classList.remove('dragover');
    }

    if (!e.relatedTarget || !e.relatedTarget.draggable) {
      setIsDragging(false);
    }
  };

  var handleDropFile = function handleDropFile(e) {
    e.preventDefault();
    e.stopPropagation();
    console.log('e.dataTransfer.files ********************* .. . .', e.dataTransfer.files);
    setIsDragging(false);

    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      var fileList = Object.values(e.dataTransfer.files);
      var attachmentsFiles = [];
      new Promise(function (resolve) {
        fileList.forEach(function (attachment, index) {
          var fileReader = new FileReader();

          fileReader.onload = function (event) {
            var file = event.target.result;
            attachmentsFiles.push({
              name: attachment.name,
              data: file,
              type: attachment.type
            });

            if (fileList.length - 1 === index) {
              resolve();
            }
          };

          fileReader.readAsDataURL(attachment);
        });
      }).then(function () {
        dispatch(setDraggedAttachments(attachmentsFiles, 'file'));
      });
      e.dataTransfer.clearData();
    }
  };

  var handleDropMedia = function handleDropMedia(e) {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
    console.log('e.dataTransfer.files ********************* .. . .', e.dataTransfer.files);
    var fileList = Array.from(e.dataTransfer.items);
    fileList.forEach(function (file) {
      var fileType = file.type.split('/')[0];
      console.log('file. .. . ', file.getAsFile());
      console.log('fileType. .. . ', fileType);
    });

    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      var _fileList = Object.values(e.dataTransfer.files);

      var attachmentsFiles = [];
      new Promise(function (resolve) {
        _fileList.forEach(function (attachment, index) {
          var fileReader = new FileReader();

          fileReader.onload = function (event) {
            var file = event.target.result;
            attachmentsFiles.push({
              name: attachment.name,
              data: file,
              type: attachment.type
            });

            if (_fileList.length - 1 === index) {
              resolve();
            }
          };

          fileReader.readAsDataURL(attachment);
        });
      }).then(function () {
        dispatch(setDraggedAttachments(attachmentsFiles, 'media'));
      });
      e.dataTransfer.clearData();
    }
  };

  useEffect(function () {
    if (scrollToRepliedMessage) {
      loading = false;
      scrollRef.current.style.scrollBehavior = 'inherit';
      var repliedMessage = document.getElementById(scrollToRepliedMessage);

      if (repliedMessage) {
        setScrollToReply(repliedMessage && repliedMessage.offsetTop - 200);
        scrollRef.current.scrollTop = repliedMessage && repliedMessage.offsetTop - 200;
        repliedMessage && repliedMessage.classList.add('highlight');
        setTimeout(function () {
          var repliedMessage = document.getElementById(scrollToRepliedMessage);
          repliedMessage && repliedMessage.classList.remove('highlight');
          setScrollToReply(null);
          scrollRef.current.style.scrollBehavior = 'smooth';
        }, 800);
      }

      dispatch(setScrollToMessagesAC(null));
    }
  }, [scrollToRepliedMessage]);
  useEffect(function () {
    if (scrollToNewMessage.scrollToBottom) {
      dispatch(showScrollToNewMessageButtonAC(false));
      loading = false;

      if (scrollToNewMessage.updateMessageList) {
        dispatch(getMessagesAC(channel, !hasNextMessages));
      }
    }
  }, [scrollToNewMessage]);
  useDidUpdate(function () {
    if (isDragging) {
      setIsDragging(false);
    }
  }, [browserTabIsActive]);
  useDidUpdate(function () {
    if (!draggingSelector) {
      setIsDragging(false);
    }
  }, [draggingSelector]);
  useEffect(function () {
    setHasNextCached(false);
    setHasPrevCached(false);
    dispatch(getMessagesAC(channel));

    if (channel.id) {
      if (channel.unreadMessageCount && channel.unreadMessageCount > 0) {
        setUnreadMessageId(channel.lastReadMessageId);
      } else {
        setUnreadMessageId('');
      }
    }

    nextDisable = false;
    prevDisable = false;
  }, [channel.id]);
  useDidUpdate(function () {
    if (!isDragging) {
      renderTopDate();
    }
  }, [isDragging]);
  useEffect(function () {
    if (loading) {
      if (loadDirection !== 'next') {
        var lastVisibleMessage = document.getElementById(lastVisibleMessageId);

        if (prevMessageId) {
          var i = 0;
          var messagesHeight = 0;

          while (i !== prevMessageId) {
            if (messages[i].id === prevMessageId) {
              i = prevMessageId;
            } else {
              var currentMessage = document.getElementById(messages[i].id);
              currentMessage ? messagesHeight += currentMessage.getBoundingClientRect().height : messagesHeight;
              i++;
            }
          }

          scrollRef.current.style.scrollBehavior = 'inherit';

          if (lastVisibleMessage && -lastVisibleMessage.offsetTop > messagesHeight) {
            scrollRef.current.scrollTop = lastVisibleMessage.offsetTop;
          } else {
            scrollRef.current.scrollTop = -messagesHeight;
          }

          scrollRef.current.style.scrollBehavior = 'smooth';
        }

        if (loadFromServer) {
          setTimeout(function () {
            loading = false;
            loadFromServer = false;
          }, 50);
        } else {
          loading = false;
        }
      } else {
        if (scrollRef.current.scrollTop > -5 && (hasNextMessages || getHasNextCached())) {
          scrollRef.current.scrollTop = -200;
        }

        loading = false;
      }
    }

    if (scrollToNewMessage.scrollToBottom && messages.length) {
      scrollRef.current.scrollTop = 0;
      setTimeout(function () {
        dispatch(scrollToNewMessageAC(false));
      }, 500);
    }

    renderTopDate();
  }, [messages]);
  useEffect(function () {
    if (channel.unreadMessageCount && channel.unreadMessageCount > 0 && getUnreadScrollTo()) {
      if (scrollRef.current) {
        scrollRef.current.style.scrollBehavior = 'inherit';
      }

      var lastReadMessageNode = document.getElementById(channel.lastReadMessageId);

      if (lastReadMessageNode) {
        scrollRef.current.scrollTop = lastReadMessageNode.offsetTop;

        if (scrollRef.current) {
          scrollRef.current.style.scrollBehavior = 'smooth';
        }

        setUnreadScrollTo(false);
      }
    }
  });
  return React__default.createElement(React__default.Fragment, null, isDragging && React__default.createElement(DragAndDropContainer, {
    id: 'draggingContainer',
    draggable: true,
    onDragLeave: handleDragOut,
    topOffset: scrollRef && scrollRef.current && scrollRef.current.offsetTop,
    height: scrollRef && scrollRef.current && scrollRef.current.offsetHeight
  }, React__default.createElement(DropAttachmentArea, {
    margin: '32px 32px 12px',
    draggable: true,
    onDrop: handleDropFile,
    onDragOver: handleDragOver
  }, React__default.createElement(IconWrapper$1, {
    draggable: true,
    iconColor: colors.primary
  }, React__default.createElement(SvgChoseFile, null)), "Drag & drop to send as file"), isDragging === 'media' && React__default.createElement(DropAttachmentArea, {
    draggable: true,
    onDrop: handleDropMedia,
    onDragOver: handleDragOver
  }, React__default.createElement(IconWrapper$1, {
    draggable: true,
    iconColor: colors.primary
  }, React__default.createElement(SvgChoseMedia, null)), "Drag & drop to send as media")), React__default.createElement(React__default.Fragment, null, showTopFixedDate && React__default.createElement(MessageTopDate, {
    dateDividerFontSize: dateDividerFontSize,
    dateDividerTextColor: dateDividerTextColor,
    dateDividerBorder: dateDividerBorder,
    dateDividerBackgroundColor: dateDividerBackgroundColor,
    dateDividerBorderRadius: dateDividerBorderRadius,
    topOffset: scrollRef && scrollRef.current && scrollRef.current.offsetTop
  }, React__default.createElement("span", {
    ref: messageTopDateRef
  })), React__default.createElement(Container$d, {
    id: 'scrollableDiv',
    ref: scrollRef,
    onScroll: handleMessagesListScroll,
    onDragEnter: handleDragIn
  }, messages.length && messages.length > 0 ? React__default.createElement(MessagesBox, {
    enableResetScrollToCoords: false,
    replyMessage: messageForReply && messageForReply.id,
    attachmentsSelected: attachmentsSelected,
    ref: messagesBoxRef,
    className: 'messageBox'
  }, messages.map(function (message, index) {
    var prevMessage = messages[index - 1];
    var nextMessage = messages[index + 1] || currentChannelPendingMessages.length > 0 && currentChannelPendingMessages[0];
    var isUnreadMessage = !!(unreadMessageId && unreadMessageId === message.id);
    return React__default.createElement(React__default.Fragment, {
      key: message.id || message.tid
    }, React__default.createElement(CreateMessageDateDivider, {
      noMargin: prevMessage && prevMessage.type === 'system',
      lastIndex: false,
      currentMessageDate: message.createdAt,
      nextMessageDate: prevMessage && prevMessage.createdAt,
      messagesHasNext: hasPrevMessages,
      dateDividerFontSize: dateDividerFontSize,
      dateDividerTextColor: dateDividerTextColor,
      dateDividerBorder: dateDividerBorder,
      dateDividerBackgroundColor: dateDividerBackgroundColor,
      dateDividerBorderRadius: dateDividerBorderRadius
    }), message.type === 'system' ? React__default.createElement(MessageTopDate, {
      systemMessage: true,
      marginTop: message.type === 'system',
      marginBottom: message.type === 'system' && nextMessage.type !== 'system',
      visible: showTopFixedDate,
      dividerText: message.body,
      dateDividerFontSize: dateDividerFontSize,
      dateDividerTextColor: dateDividerTextColor,
      dateDividerBorder: dateDividerBorder,
      dateDividerBackgroundColor: dateDividerBackgroundColor,
      dateDividerBorderRadius: dateDividerBorderRadius
    }, React__default.createElement("span", null, message.incoming ? makeUserName(message.user && contactsMap[message.user.id], message.user, getFromContacts) : 'You', message.body === 'CC' ? ' created this channel ' : message.body === 'CG' ? ' created this group' : message.body === 'AM' ? " added " + (message.metadata && message.metadata.m && message.metadata.m.slice(0, 5).map(function (mem) {
      return mem === user.id ? 'You' : " " + systemMessageUserName(contactsMap[mem], mem);
    })) + " " + (message.metadata && message.metadata.m && message.metadata.m.length > 5 ? "and " + (message.metadata.m.length - 5) + " more" : '') : message.body === 'RM' ? " removed " + (message.metadata && message.metadata.m && message.metadata.m.slice(0, 5).map(function (mem) {
      return mem === user.id ? 'You' : " " + systemMessageUserName(contactsMap[mem], mem);
    })) + " " + (message.metadata && message.metadata.m && message.metadata.m.length > 5 ? "and " + (message.metadata.m.length - 5) + " more" : '') : message.body === 'LG' ? ' left the group' : '')) : React__default.createElement(MessageWrapper, {
      id: message.id
    }, React__default.createElement(Message, {
      message: message,
      channel: channel,
      handleMediaItemClick: function handleMediaItemClick(attachment) {
        return setMediaFile(attachment);
      },
      handleScrollToRepliedMessage: handleScrollToRepliedMessage,
      prevMessage: prevMessage,
      nextMessage: nextMessage,
      firstMessage: index,
      isUnreadMessage: isUnreadMessage,
      setLastVisibleMessageId: function setLastVisibleMessageId(msgId) {
        return _setLastVisibleMessageId(msgId);
      },
      isThreadMessage: false,
      fontFamily: fontFamily,
      ownMessageOnRightSide: ownMessageOnRightSide,
      messageWidthPercent: messageWidthPercent,
      messageTimePosition: messageTimePosition,
      ownMessageBackground: ownMessageBackground,
      incomingMessageBackground: incomingMessageBackground,
      showMessageStatus: showMessageStatus,
      hoverBackground: hoverBackground,
      showOwnAvatar: showOwnAvatar,
      showSenderNameOnDirectChannel: showSenderNameOnDirectChannel,
      showSenderNameOnOwnMessages: showSenderNameOnOwnMessages,
      messageReaction: messageReaction,
      editMessage: editMessage,
      copyMessage: copyMessage,
      replyMessage: replyMessage,
      replyMessageInThread: replyMessageInThread,
      deleteMessage: deleteMessage,
      allowEditDeleteIncomingMessage: allowEditDeleteIncomingMessage,
      reportMessage: reportMessage,
      reactionIcon: reactionIcon,
      editIcon: editIcon,
      copyIcon: copyIcon,
      replyIcon: replyIcon,
      replyInThreadIcon: replyInThreadIcon,
      forwardIcon: forwardIcon,
      deleteIcon: deleteIcon,
      forwardMessage: forwardMessage,
      starIcon: starIcon,
      staredIcon: staredIcon,
      reportIcon: reportIcon,
      reactionIconOrder: reactionIconOrder,
      editIconOrder: editIconOrder,
      copyIconOrder: copyIconOrder,
      replyIconOrder: replyIconOrder,
      replyInThreadIconOrder: replyInThreadIconOrder,
      forwardIconOrder: forwardIconOrder,
      deleteIconOrder: deleteIconOrder,
      starIconOrder: starIconOrder,
      reportIconOrder: reportIconOrder,
      reactionIconTooltipText: reactionIconTooltipText,
      editIconTooltipText: editIconTooltipText,
      copyIconTooltipText: copyIconTooltipText,
      replyIconTooltipText: replyIconTooltipText,
      replyInThreadIconTooltipText: replyInThreadIconTooltipText,
      forwardIconTooltipText: forwardIconTooltipText,
      deleteIconTooltipText: deleteIconTooltipText,
      starIconTooltipText: starIconTooltipText,
      reportIconTooltipText: reportIconTooltipText,
      messageActionIconsColor: messageActionIconsColor,
      inlineReactionIcon: inlineReactionIcon,
      fileAttachmentsIcon: fileAttachmentsIcon,
      fileAttachmentsBoxWidth: fileAttachmentsBoxWidth,
      fileAttachmentsBoxBackground: fileAttachmentsBoxBackground,
      fileAttachmentsBoxBorder: fileAttachmentsBoxBorder,
      fileAttachmentsTitleColor: fileAttachmentsTitleColor,
      fileAttachmentsSizeColor: fileAttachmentsSizeColor,
      reactionsDisplayCount: reactionsDisplayCount,
      showEachReactionCount: showEachReactionCount,
      reactionItemBorder: reactionItemBorder,
      reactionItemBorderRadius: reactionItemBorderRadius,
      reactionItemBackground: reactionItemBackground,
      reactionItemPadding: reactionItemPadding,
      reactionItemMargin: reactionItemMargin,
      reactionsFontSize: reactionsFontSize,
      reactionsContainerBoxShadow: reactionsContainerBoxShadow,
      reactionsContainerBorder: reactionsContainerBorder,
      reactionsContainerBorderRadius: reactionsContainerBorderRadius,
      reactionsContainerPadding: reactionsContainerPadding,
      reactionsContainerBackground: reactionsContainerBackground,
      reactionsContainerTopPosition: reactionsContainerTopPosition
    })), isUnreadMessage ? React__default.createElement(MessageDivider, {
      newMessagesSeparatorTextColor: newMessagesSeparatorTextColor,
      newMessagesSeparatorFontSize: newMessagesSeparatorFontSize,
      newMessagesSeparatorWidth: newMessagesSeparatorWidth,
      newMessagesSeparatorBorder: newMessagesSeparatorBorder,
      newMessagesSeparatorBorderRadius: newMessagesSeparatorBorderRadius,
      newMessagesSeparatorBackground: newMessagesSeparatorBackground,
      newMessagesSeparatorLeftRightSpaceWidth: newMessagesSeparatorTextLeftRightSpacesWidth,
      dividerText: newMessagesSeparatorText || 'Unread Messages',
      unread: true
    }) : null);
  })) : messagesLoading === LOADING_STATE.LOADED && React__default.createElement(NoMessagesContainer, null, "No messages in this", channel.type === CHANNEL_TYPE.DIRECT ? ' chat' : channel.type === CHANNEL_TYPE.PRIVATE ? ' group chat' : ' channel'), mediaFile && React__default.createElement(SliderPopup, {
    channelId: channel.id,
    setIsSliderOpen: setMediaFile,
    currentMediaFile: mediaFile
  }))));
};
var Container$d = styled.div(_templateObject$t || (_templateObject$t = _taggedTemplateLiteralLoose(["\n  display: flex;\n  flex-direction: column-reverse;\n  //flex-direction: column;\n  flex-grow: 1;\n  position: relative;\n  overflow: auto;\n  scroll-behavior: smooth;\n"])));
var EmptyDiv = styled.div(_templateObject2$r || (_templateObject2$r = _taggedTemplateLiteralLoose(["\n  height: 300px;\n"])));
var MessagesBox = styled.div(_templateObject3$l || (_templateObject3$l = _taggedTemplateLiteralLoose(["\n  //height: auto;\n  display: flex;\n  //flex-direction: column-reverse;\n  flex-direction: column;\n  padding-bottom: 20px;\n  //overflow: auto;\n  //scroll-behavior: unset;\n"])));
var MessageTopDate = styled.div(_templateObject4$i || (_templateObject4$i = _taggedTemplateLiteralLoose(["\n  position: ", ";\n  width: 100%;\n  top: ", ";\n  left: 0;\n  margin-top: ", ";\n  margin-bottom: ", ";\n  text-align: center;\n  z-index: 10;\n  background: transparent;\n  span {\n    //display: ", ";\n    display: inline-block;\n    max-width: 380px;\n    font-style: normal;\n    font-weight: normal;\n    font-size: ", ";\n    color: ", ";\n    background: ", ";\n    border: ", ";\n    box-sizing: border-box;\n    border-radius: ", ";\n    padding: 5px 16px;\n    box-shadow: 0 0 2px rgba(0, 0, 0, 0.08), 0 2px 24px rgba(0, 0, 0, 0.08);\n  }\n"])), function (props) {
  return props.systemMessage ? '' : 'absolute';
}, function (props) {
  return props.topOffset ? props.topOffset + 22 + "px" : '22px';
}, function (props) {
  return props.marginTop && '16px';
}, function (props) {
  return props.marginBottom && '16px';
}, function (props) {
  return !props.systemMessage && 'none';
}, function (props) {
  return props.dateDividerFontSize || '14px';
}, function (props) {
  return props.dateDividerTextColor || colors.blue6;
}, function (props) {
  return props.dateDividerBackgroundColor || '#ffffff';
}, function (props) {
  return props.dateDividerBorder || "1px solid " + colors.gray1;
}, function (props) {
  return props.dateDividerBorderRadius || '14px';
});
var DragAndDropContainer = styled.div(_templateObject5$e || (_templateObject5$e = _taggedTemplateLiteralLoose(["\n  display: flex;\n  flex-direction: column;\n  flex-grow: 1;\n  margin-bottom: -31px;\n  margin-top: -2px;\n\n  position: absolute;\n  left: 0;\n  top: ", ";\n  width: 100%;\n  height: ", ";\n  background-color: ", ";\n  z-index: 999;\n"])), function (props) {
  return props.topOffset ? props.topOffset + 2 + "px" : 0;
}, function (props) {
  return props.height ? props.height + 30 + "px" : '100%';
}, colors.white);
var IconWrapper$1 = styled.span(_templateObject6$e || (_templateObject6$e = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 64px;\n  width: 64px;\n  background-color: ", ";\n  border-radius: 50%;\n  text-align: center;\n  margin-bottom: 16px;\n  transition: all 0.3s;\n  pointer-events: none;\n  & > svg {\n    color: ", ";\n    width: 32px;\n    height: 32px;\n  }\n"])), colors.gray5, function (props) {
  return props.iconColor || colors.primary;
});
var DropAttachmentArea = styled.div(_templateObject7$c || (_templateObject7$c = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  height: 100%;\n  border: 1px dashed ", ";\n  border-radius: 16px;\n  margin: ", ";\n  font-weight: 400;\n  font-size: 15px;\n  line-height: 18px;\n  letter-spacing: -0.2px;\n  color: ", ";\n  transition: all 0.1s;\n\n  &.dragover {\n    background-color: ", ";\n\n    ", " {\n      background-color: ", ";\n    }\n  }\n"])), colors.gray3, function (props) {
  return props.margin || '12px 32px 32px';
}, colors.gray6, colors.gray5, IconWrapper$1, colors.white);
var MessageWrapper = styled.div(_templateObject8$a || (_templateObject8$a = _taggedTemplateLiteralLoose(["\n  &.highlight {\n    & .messageBody {\n      transform: scale(1.1);\n      background-color: #d5d5d5;\n    }\n  }\n"])));
var NoMessagesContainer = styled.div(_templateObject9$9 || (_templateObject9$9 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  height: 100%;\n  width: 100%;\n  font-weight: 400;\n  font-size: 15px;\n  line-height: 18px;\n  letter-spacing: -0.2px;\n  color: ", ";\n"])), colors.gray6);

var _circle$5, _path$X;

function _extends$_() {
  _extends$_ = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$_.apply(this, arguments);
}

function SvgSend(props) {
  return /*#__PURE__*/createElement("svg", _extends$_({
    width: 32,
    height: 32,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _circle$5 || (_circle$5 = /*#__PURE__*/createElement("circle", {
    cx: 16,
    cy: 16,
    r: 16,
    fill: "currentColor"
  })), _path$X || (_path$X = /*#__PURE__*/createElement("path", {
    d: "M10.953 18.945c-.545 1.46-.888 2.485-1.028 3.076-.439 1.856-.758 2.274.879 1.392 1.637-.882 9.56-5.251 11.329-6.222 2.304-1.266 2.335-1.167-.124-2.511-1.873-1.024-9.704-5.279-11.205-6.115-1.501-.835-1.318-.464-.879 1.392.142.6.49 1.634 1.043 3.105a3.143 3.143 0 002.35 1.98l4.595.88a.079.079 0 010 .155l-4.606.88a3.143 3.143 0 00-2.354 1.988z",
    fill: "#fff"
  })));
}

var _path$Y;

function _extends$$() {
  _extends$$ = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$$.apply(this, arguments);
}

function SvgEye(props) {
  return /*#__PURE__*/createElement("svg", _extends$$({
    width: 25,
    height: 24,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$Y || (_path$Y = /*#__PURE__*/createElement("path", {
    d: "M12.5 5c6 0 10 5.6 10 7 0 1.4-4 7-10 7s-10-5.6-10-7c0-1.4 4-7 10-7zm0 2a5 5 0 100 10 5 5 0 000-10zm.001 2.5a2.5 2.5 0 110 5 2.5 2.5 0 010-5z",
    fill: "CurrentColor"
  })));
}

var _path$Z;

function _extends$10() {
  _extends$10 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$10.apply(this, arguments);
}

function SvgEdit(props) {
  return /*#__PURE__*/createElement("svg", _extends$10({
    width: 24,
    height: 24,
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$Z || (_path$Z = /*#__PURE__*/createElement("path", {
    d: "M13.92 6.768l3.312 3.312-7.934 7.925a6.229 6.229 0 01-2.586 1.554l-2.71.827a.312.312 0 01-.388-.389l.827-2.71a6.231 6.231 0 011.553-2.586l7.926-7.933zm4.746-2.758l1.324 1.324a1.4 1.4 0 01.096 1.874l-.096.106-1.414 1.41-3.3-3.3 1.41-1.414a1.4 1.4 0 011.98 0z",
    fill: "CurrentColor"
  })));
}

var _path$_;

function _extends$11() {
  _extends$11 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$11.apply(this, arguments);
}

function SvgAttachment(props) {
  return /*#__PURE__*/createElement("svg", _extends$11({
    width: 24,
    height: 24,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$_ || (_path$_ = /*#__PURE__*/createElement("path", {
    d: "M12.162 9.34a.857.857 0 011.212 1.213l-3.576 3.576a1.29 1.29 0 000 1.818 1.29 1.29 0 001.818 0l6.667-6.667c1.373-1.373 1.298-3.55 0-4.849-1.298-1.297-3.476-1.372-4.849 0l-6.667 6.667c-2.186 2.187-2.145 5.734 0 7.88 2.146 2.145 5.693 2.186 7.88 0l3.575-3.576a.857.857 0 111.213 1.212l-3.576 3.576c-2.862 2.862-7.495 2.809-10.304 0-2.809-2.81-2.862-7.442 0-10.304l6.667-6.667c2.062-2.061 5.324-1.949 7.273 0 1.95 1.95 2.062 5.212 0 7.273l-6.667 6.667c-1.137 1.138-3.04 1.203-4.242 0-1.203-1.203-1.138-3.105 0-4.242L12.16 9.34z",
    fill: "currentColor"
  })));
}

var _path$$;

function _extends$12() {
  _extends$12 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$12.apply(this, arguments);
}

function SvgErrorCircle(props) {
  return /*#__PURE__*/createElement("svg", _extends$12({
    width: 25,
    height: 24,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$$ || (_path$$ = /*#__PURE__*/createElement("path", {
    d: "M12.5 1.714c5.68 0 10.286 4.605 10.286 10.286 0 5.68-4.605 10.285-10.286 10.285C6.82 22.285 2.214 17.68 2.214 12 2.214 6.319 6.82 1.714 12.5 1.714zm0 1.714a8.571 8.571 0 100 17.143 8.571 8.571 0 000-17.143zm0 11.657a1.2 1.2 0 110 2.4 1.2 1.2 0 010-2.4zm.063-8.228c.204 0 .332.032.443.091.112.06.2.148.26.26.06.111.091.24.091.443v5.269c0 .204-.032.331-.091.443a.623.623 0 01-.26.26c-.111.059-.24.09-.443.09h-.126c-.204 0-.332-.031-.443-.09a.624.624 0 01-.26-.26c-.06-.112-.091-.24-.091-.443V7.65c0-.203.032-.33.091-.442.06-.112.148-.2.26-.26.111-.06.24-.091.443-.091h.126z",
    fill: "#FFB73D"
  })));
}

var activeChannelMembersSelector = function activeChannelMembersSelector(store) {
  return store.MembersReducer.activeChannelMembers;
};
var rolesSelector = function rolesSelector(store) {
  return store.MembersReducer.roles;
};
var membersLoadingStateSelector = function membersLoadingStateSelector(store) {
  return store.MembersReducer.membersLoadingState;
};

var LOADING_STATE$1 = {
  LOADING: 1,
  LOADED: 2
};
var PRESENCE_STATUS$1 = {
  OFFLINE: 'Offline',
  ONLINE: 'Online'
};

var _templateObject$u, _templateObject2$s, _templateObject3$m, _templateObject4$j, _templateObject5$f;
function MentionMembersPopup(_ref) {
  var channelId = _ref.channelId,
      addMentionMember = _ref.addMentionMember,
      handleMentionsPopupClose = _ref.handleMentionsPopupClose,
      searchMention = _ref.searchMention;
  var members = useSelector(activeChannelMembersSelector, shallowEqual);
  var contactsMap = useSelector(contactsMapSelector);
  var getFromContacts = getShowOnlyContactUsers();

  var _useState = useState([]),
      filteredMembers = _useState[0],
      setFilteredMembers = _useState[1];

  var filteredMembersLength = useRef(0);

  var _useState2 = useState(0),
      activeIndex = _useState2[0],
      setActiveIndex = _useState2[1];

  var user = getClient().chatClient.user;
  var membersLoading = useSelector(membersLoadingStateSelector, shallowEqual) || {};
  var dispatch = useDispatch();

  var handleMembersListScroll = function handleMembersListScroll(event) {
    if (event.target.scrollTop >= event.target.scrollHeight - event.target.offsetHeight - 100) {
      if (membersLoading === LOADING_STATE$1.LOADED) {
        dispatch(loadMoreMembersAC(15));
      }
    }
  };

  var handleMentionMember = function handleMentionMember() {
    addMentionMember(filteredMembers[activeIndex]);
    handleMentionsPopupClose();
  };

  var sortMembers = function sortMembers(membersList) {
    return [].concat(membersList).sort(function (a, b) {
      var aDisplayName = makeUserName(a.id === user.id ? a : contactsMap[a.id], a, getFromContacts);
      var bDisplayName = makeUserName(b.id === user.id ? b : contactsMap[b.id], b, getFromContacts);

      if (aDisplayName < bDisplayName) {
        return -1;
      }

      if (aDisplayName > bDisplayName) {
        return 1;
      }

      return 0;
    });
  };

  var handleKeyDown = function handleKeyDown(e) {
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      setActiveIndex(function (prevState) {
        return prevState < filteredMembersLength.current - 1 ? prevState + 1 : prevState;
      });
    }

    if (e.key === 'ArrowUp') {
      e.preventDefault();
      setActiveIndex(function (prevState) {
        return prevState > 0 ? prevState - 1 : prevState;
      });
    }

    if (e.key === 'Enter') {
      e.preventDefault();
      handleMentionMember();
    }
  };

  var handleClicks = function handleClicks(e) {
    if (e.target.closest('.mention_member_popup')) {
      return;
    }

    handleMentionsPopupClose();
  };

  useEventListener('click', handleClicks);
  useEffect(function () {
    dispatch(getMembersAC(channelId));
  }, [channelId]);
  useEffect(function () {
    window.addEventListener('keydown', handleKeyDown);
    return function () {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [filteredMembers, activeIndex]);
  useEffect(function () {
    if (members && members.length && !searchMention) {
      var sortedMembers = sortMembers(members.filter(function (member) {
        return member.id !== user.id;
      }));
      filteredMembersLength.current = sortedMembers.length;
      setFilteredMembers(sortedMembers);
    }
  }, [members]);
  useDidUpdate(function () {
    if (searchMention) {
      var searchedMembers = [].concat(members).filter(function (member) {
        var displayName = makeUserName(contactsMap[member.id], member, getFromContacts);
        return displayName && member.id !== user.id && displayName.toLowerCase().includes(searchMention.toLowerCase());
      });
      filteredMembersLength.current = searchedMembers.length;
      setFilteredMembers(sortMembers(searchedMembers));
    } else {
      var _searchedMembers = [].concat(members).filter(function (member) {
        return member.id !== user.id;
      });

      filteredMembersLength.current = _searchedMembers.length || 0;
      setFilteredMembers(sortMembers(_searchedMembers || []));
    }
  }, [searchMention]);
  return React__default.createElement(Container$e, {
    className: 'mention_member_popup',
    height: filteredMembers && filteredMembers.length * 44
  }, React__default.createElement(MembersList, {
    onScroll: handleMembersListScroll
  }, filteredMembers.map(function (member, index) {
    return React__default.createElement(MemberItem, {
      key: member.id,
      onClick: function onClick() {
        handleMentionMember();
      },
      isActiveItem: activeIndex === index,
      onMouseEnter: function onMouseEnter() {
        return setActiveIndex(index);
      }
    }, React__default.createElement(AvatarWrapper, null, React__default.createElement(Avatar, {
      name: member.firstName || member.id,
      image: member.avatarUrl,
      size: 32,
      textSize: 14,
      setDefaultAvatar: true
    }), member.presence && member.presence.state === PRESENCE_STATUS$1.ONLINE && React__default.createElement(UserStatus, null)), React__default.createElement(MemberName$1, null, makeUserName(member.id === user.id ? member : contactsMap[member.id], member, getFromContacts)));
  })));
}
MentionMembersPopup.defaultProps = {
  activeItemIndex: null,
  searchMention: ''
};
var Container$e = styled.div(_templateObject$u || (_templateObject$u = _taggedTemplateLiteralLoose(["\n  width: 300px;\n  height: ", "px;\n  max-height: 240px;\n  background: #ffffff;\n  border: 1px solid #dfe0eb;\n  box-sizing: border-box;\n  box-shadow: 0px 0px 12px rgba(0, 0, 0, 0.08);\n  border-radius: 6px;\n"])), function (props) {
  return props.height && props.height + 22;
});
var MemberName$1 = styled.span(_templateObject2$s || (_templateObject2$s = _taggedTemplateLiteralLoose(["\n  margin: 0 0 0 12px;\n  max-width: calc(100% - 30px);\n  font-weight: 400;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n\n  & > span {\n    color: #abadb7;\n  }\n"])));
var EditMemberIcon = styled.span(_templateObject3$m || (_templateObject3$m = _taggedTemplateLiteralLoose(["\n  margin-left: auto;\n  cursor: pointer;\n  padding: 2px;\n  opacity: 0;\n  visibility: hidden;\n  transition: all 0.2s;\n"])));
var MembersList = styled.ul(_templateObject4$j || (_templateObject4$j = _taggedTemplateLiteralLoose(["\n  margin: 10px 0 0;\n  padding: 0;\n  overflow-x: hidden;\n  list-style: none;\n  transition: all 0.2s;\n  height: calc(100% - 10px); ;\n"])));
var MemberItem = styled.li(_templateObject5$f || (_templateObject5$f = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  font-size: 15px;\n  padding: 6px 16px;\n  transition: all 0.2s;\n  cursor: pointer;\n  background-color: ", ";\n\n  &:hover ", " {\n    opacity: 1;\n    visibility: visible;\n  }\n\n  & .dropdown-wrapper {\n    margin-left: auto;\n  }\n\n  & .dropdown-body {\n    bottom: -100px;\n    right: 0;\n  }\n\n  & ", " {\n    width: 10px;\n    height: 10px;\n  }\n"])), function (props) {
  return props.isActiveItem && colors.gray0;
}, EditMemberIcon, UserStatus);

var _templateObject$v, _templateObject2$t, _templateObject3$n, _templateObject4$k, _templateObject5$g, _templateObject6$f, _templateObject7$d, _templateObject8$b, _templateObject9$a, _templateObject10$8, _templateObject11$6, _templateObject12$5, _templateObject13$4, _templateObject14$4, _templateObject15$3, _templateObject16$2, _templateObject17$2, _templateObject18$2, _templateObject19$2, _templateObject20$1, _templateObject21$1, _templateObject22$1, _templateObject23$1, _templateObject24$1, _templateObject25$1, _templateObject26$1, _templateObject27$1, _templateObject28$1;
var prevActiveChannelId;

var SendMessageInput = function SendMessageInput(_ref) {
  var handleAttachmentSelected = _ref.handleAttachmentSelected,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      emojiIcoOrder = _ref.emojiIcoOrder,
      attachmentIcoOrder = _ref.attachmentIcoOrder,
      sendIconOrder = _ref.sendIconOrder,
      inputOrder = _ref.inputOrder,
      hideEmojis = _ref.hideEmojis,
      CustomTypingIndicator = _ref.CustomTypingIndicator,
      margin = _ref.margin,
      border = _ref.border,
      borderRadius = _ref.borderRadius,
      selectedAttachmentsBorderRadius = _ref.selectedAttachmentsBorderRadius,
      selectedFileAttachmentsIcon = _ref.selectedFileAttachmentsIcon,
      selectedFileAttachmentsBoxWidth = _ref.selectedFileAttachmentsBoxWidth,
      selectedFileAttachmentsBoxBackground = _ref.selectedFileAttachmentsBoxBackground,
      selectedFileAttachmentsBoxBorder = _ref.selectedFileAttachmentsBoxBorder,
      selectedFileAttachmentsTitleColor = _ref.selectedFileAttachmentsTitleColor,
      selectedFileAttachmentsSizeColor = _ref.selectedFileAttachmentsSizeColor,
      replyMessageIcon = _ref.replyMessageIcon;
  var dispatch = useDispatch();
  var getFromContacts = getShowOnlyContactUsers();
  var activeChannel = useSelector(activeChannelSelector);
  var isBlockedUserChat = activeChannel.peer && activeChannel.peer.blocked;
  var isDeletedUserChat = activeChannel.peer && activeChannel.peer.activityState === 'Deleted';
  var messageToEdit = useSelector(messageToEditSelector);
  var messageForReply = useSelector(messageForReplySelector);
  var draggedAttachments = useSelector(draggedAttachmentsSelector);
  var ChatClient = getClient();
  var user = ChatClient.user;
  var messageContRef = useRef(null);

  var _usePermissions = usePermissions(activeChannel.role),
      checkActionPermission = _usePermissions[0];

  var _useState = useState(''),
      messageText = _useState[0],
      setMessageText = _useState[1];

  var _useState2 = useState(''),
      editMessageText = _useState2[0],
      setEditMessageText = _useState2[1];

  var _useState3 = useState({}),
      readyVideoAttachments = _useState3[0],
      setReadyVideoAttachments = _useState3[1];

  var _useState4 = useState(false),
      showChooseAttachmentType = _useState4[0],
      setShowChooseAttachmentType = _useState4[1];

  var _useState5 = useState(false),
      isEmojisOpened = _useState5[0],
      setIsEmojisOpened = _useState5[1];

  var _useState6 = useState(false),
      emojisInRightSide = _useState6[0],
      setEmojisInRightSide = _useState6[1];

  var _useState7 = useState([]),
      mentionedMembers = _useState7[0],
      setMentionedMembers = _useState7[1];

  var _useState8 = useState([]),
      mentionedMembersDisplayName = _useState8[0],
      setMentionedMembersDisplayName = _useState8[1];

  var _useState9 = useState(undefined),
      currentMentions = _useState9[0],
      setCurrentMentions = _useState9[1];

  var _useState10 = useState(false),
      mentionTyping = _useState10[0],
      setMentionTyping = _useState10[1];

  var _useState11 = useState(undefined),
      mentionEdit = _useState11[0],
      setMentionEdit = _useState11[1];

  var _useState12 = useState(),
      selectionPos = _useState12[0],
      setSelectionPos = _useState12[1];

  var _useState13 = useState(),
      typingTimout = _useState13[0],
      setTypingTimout = _useState13[1];

  var _useState14 = useState(),
      inTypingStateTimout = _useState14[0],
      setInTypingStateTimout = _useState14[1];

  var _useState15 = useState(false),
      inTypingState = _useState15[0],
      setInTypingState = _useState15[1];

  var _useState16 = useState(false),
      sendMessageIsActive = _useState16[0],
      setSendMessageIsActive = _useState16[1];

  var _useState17 = useState(false),
      openMention = _useState17[0],
      setOpenMention = _useState17[1];

  var _useState18 = useState([]),
      attachments = _useState18[0],
      setAttachments = _useState18[1];

  var typingIndicator = useSelector(typingIndicatorSelector(activeChannel.id));
  var contactsMap = useSelector(contactsMapSelector);
  var connectionStatus = useSelector(connectionStatusSelector, shallowEqual);
  var fileUploader = useRef(null);
  var messageInputRef = useRef(null);
  var emojiBtnRef = useRef(null);
  var mentionsRef = useRef(null);
  var mediaExtensions = '.jpg,.jpeg,.png,.gif,.mp4,.mov,.avi,.wmv,.flv,.webm,.jfif';

  var handleSendTypingState = function handleSendTypingState(typingState) {
    if (typingState) {
      setInTypingStateTimout(setTimeout(function () {
        setInTypingStateTimout(0);
      }, 3000));
    } else {
      clearTimeout(inTypingStateTimout);
    }

    setInTypingState(typingState);
    dispatch(sendTypingAC(typingState));
  };

  var handleAddEmoji = function handleAddEmoji(emoji) {
    var selPos = getCaretPosition(messageInputRef.current);
    var newText = messageText.slice(0, selPos) + emoji + messageText.slice(selPos);
    setMessageText(newText);
    messageInputRef.current.innerText = newText;
    setCursorPosition(messageInputRef.current, selPos + emoji.length);
  };

  var handleSetMention = function handleSetMention(member) {
    var mentionDisplayName = makeUserName(user.id === member.id ? member : contactsMap[member.id], member, getFromContacts);
    var mentionToChange = mentionedMembers.find(function (men) {
      return men.start === currentMentions.start;
    });

    if (mentionToChange) {
      setMentionedMembers(mentionedMembers.map(function (menMem) {
        if (menMem.start === currentMentions.start) {
          return _extends({}, member, {
            start: currentMentions.start,
            end: currentMentions.start + 1 + mentionDisplayName.trim().length
          });
        } else {
          return menMem;
        }
      }));
      setMentionedMembersDisplayName(mentionedMembersDisplayName.filter(function (menMem) {
        return menMem.id !== mentionToChange.id;
      }));
    } else {
      setMentionedMembers(function (members) {
        return [].concat(members, [_extends({}, member, {
          start: currentMentions.start,
          end: currentMentions.start + 1 + mentionDisplayName.trim().length
        })]);
      });
    }

    if (!mentionedMembersDisplayName.find(function (menMem) {
      return menMem.id === member.id;
    })) {
      setMentionedMembersDisplayName(function (prevState) {
        return [].concat(prevState, [{
          id: member.id,
          displayName: "@" + mentionDisplayName
        }]);
      });
    }

    setMentionTyping(false);
    var currentText = "" + messageText.slice(0, mentionToChange ? mentionToChange.start + 1 : currentMentions.start + 1) + mentionDisplayName + " " + messageText.slice(mentionToChange ? mentionToChange.end : currentMentions.start + 1 + currentMentions.typed.length);
    setMessageText(currentText);
    messageInputRef.current.innerText = currentText;
    setCursorPosition(messageInputRef.current, currentMentions.start + 1 + mentionDisplayName.length);

    var updateCurrentMentions = _extends({}, currentMentions);

    updateCurrentMentions.typed = mentionDisplayName;
    updateCurrentMentions.id = member.id;
    updateCurrentMentions.end = updateCurrentMentions.start + mentionDisplayName.length;
    setCurrentMentions(updateCurrentMentions);
    setMentionEdit(undefined);
    messageInputRef.current.focus();
  };

  var handleCloseMentionsPopup = function handleCloseMentionsPopup() {
    setOpenMention(false);
    setMentionTyping(false);
    setMentionEdit(undefined);
  };

  var handleTyping = function handleTyping(e) {
    if (!(openMention && (e.key === 'ArrowDown' || e.key === 'ArrowUp'))) {
      if (messageToEdit) {
        setEditMessageText(e.currentTarget.innerText);
      } else {
        setMessageText(e.currentTarget.innerText);
      }

      handleMentionDetect(e);

      if (typingTimout) {
        if (!inTypingStateTimout) {
          handleSendTypingState(true);
        }

        clearTimeout(typingTimout);
      } else {
        handleSendTypingState(true);
      }

      setTypingTimout(setTimeout(function () {
        setTypingTimout(0);
      }, 2000));
    }
  };

  var handleMentionDetect = function handleMentionDetect(e) {
    var selPos = getCaretPosition(e.currentTarget);

    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowTop' || e.key === 'ArrowDown') {
      setSelectionPos(selPos);
    } else {
      if (mentionedMembers.length) {
        var edited = false;
        var editMentions = mentionedMembers.map(function (men) {
          if (men.start > selPos) {
            if (!edited) {
              edited = true;
            }

            var newMen = _extends({}, men);

            if (e.key === 'Delete' || e.key === 'Backspace') {
              newMen.start -= 1;
              newMen.end -= 1;
            } else {
              newMen.start += 1;
              newMen.end += 1;
            }

            return newMen;
          }

          return men;
        });

        if (edited) {
          setMentionedMembers(editMentions);
        }
      }
    }

    if (currentMentions && currentMentions.start === selPos - 1 && !mentionTyping) {
      setMentionTyping(true);
      setOpenMention(true);
    }

    var lastChar = messageInputRef.current.innerText.slice(0, selPos).slice(-1);

    if (lastChar === '@' && !mentionTyping && activeChannel.type === CHANNEL_TYPE.PRIVATE) {
      setCurrentMentions({
        start: selPos - 1,
        typed: ''
      });
      setMentionTyping(true);
      setOpenMention(true);
    }

    var shouldClose = false;

    if (e.key === 'Backspace') {
      var mentionToEdit = mentionedMembers.find(function (menMem) {
        return menMem.start <= selPos && menMem.end >= selPos + 1;
      });

      if (mentionToEdit) {
        var currentText = [messageText.slice(0, mentionToEdit.start + 1), messageText.slice(mentionToEdit.end)].join('');
        setMessageText(currentText);
        messageInputRef.current.innerText = currentText;
        setMentionedMembers(function (prevState) {
          return prevState.filter(function (mem) {
            return mem.start !== mentionToEdit.start;
          });
        });
        setMentionEdit(undefined);
        setCursorPosition(messageInputRef.current, mentionToEdit.start + 1);
        setOpenMention(true);
        setMentionTyping(true);
        setCurrentMentions({
          start: mentionToEdit.start,
          typed: ''
        });
      } else if (currentMentions) {
        if (currentMentions.start >= selPos) {
          shouldClose = true;
          setCurrentMentions(undefined);
          setOpenMention(false);
          setMentionTyping(false);
        } else {
          setCurrentMentions({
            start: currentMentions.start,
            typed: messageText.slice(currentMentions.start + 1, selPos)
          });
        }
      }
    }

    if (mentionTyping) {
      if (e.key === ' ') {
        handleCloseMentionsPopup();
      } else if (!currentMentions.end && !shouldClose) {
        var typedMessage = e.currentTarget.innerText;

        var updateCurrentMentions = _extends({}, currentMentions);

        updateCurrentMentions.typed = typedMessage.slice(updateCurrentMentions.start + 1, selPos);
        setCurrentMentions(updateCurrentMentions);
      }
    }

    if (mentionEdit && (e.key === 'Delete' || e.key === 'Backspace')) {
      var _currentText = [messageText.slice(0, mentionEdit.start + 1), messageText.slice(mentionEdit.end)].join('');

      setMessageText(_currentText);
      messageInputRef.current.innerText = _currentText;
      setMentionedMembers(function (prevState) {
        return prevState.filter(function (mem) {
          return mem.start !== mentionEdit.start;
        });
      });
      setMentionEdit(undefined);
      setCursorPosition(messageInputRef.current, mentionEdit.start + 1);
      setCurrentMentions({
        start: mentionEdit.start,
        typed: ''
      });
    }
  };

  var handleCloseReply = function handleCloseReply() {
    dispatch(setMessageForReplyAC(null));
  };

  var handleSendEditMessage = function handleSendEditMessage(event) {
    var shiftKey = event.shiftKey,
        charCode = event.charCode,
        type = event.type;
    var shouldSend = charCode === 13 && shiftKey === false && !openMention || type === 'click';

    if (shouldSend) {
      event.preventDefault();

      if (messageToEdit) {
        handleEditMessage();
      } else if (messageText || attachments.length && attachments.length > 0) {
        var messageTexToSend = messageText.trim();
        var mentionedMembersPositions = {};
        mentionedMembers.forEach(function (menMem) {
          if (!mentionedMembersPositions[menMem.id]) {
            mentionedMembersPositions[menMem.id] = {
              loc: menMem.start,
              len: menMem.end - menMem.start
            };
          }
        });
        var messageToSend = {
          metadata: mentionedMembersPositions,
          body: messageTexToSend,
          mentionedMembers: [],
          attachments: [],
          type: 'text'
        };
        messageToSend.mentionedMembers = mentionedMembers.filter(function (v, i, a) {
          return a.findIndex(function (t) {
            return t.id === v.id;
          }) === i;
        });

        if (messageForReply) {
          messageToSend.parent = messageForReply;
        }

        if (messageTexToSend && !attachments.length) {
          var messageTextArr = [messageTexToSend];
          var firstUrl;
          messageTextArr.forEach(function (textPart) {
            if (urlRegex.test(textPart)) {
              var textArray = textPart.split(urlRegex);
              textArray.forEach(function (part) {
                try {
                  if (urlRegex.test(part)) {
                    if (!firstUrl) {
                      firstUrl = part;
                    }
                  }

                  return Promise.resolve();
                } catch (e) {
                  return Promise.reject(e);
                }
              });
            }
          });

          if (firstUrl) {
            messageToSend.attachments = [{
              type: attachmentTypes.link,
              data: firstUrl,
              upload: false
            }];
          }

          dispatch(sendTextMessageAC(messageToSend, activeChannel.id, connectionStatus));
        }

        if (attachments.length) {
          var sendAsSeparateMessage = getSendAttachmentsAsSeparateMessages();
          messageToSend.attachments = attachments.map(function (attachment, index) {
            var attachmentToSend = {
              name: attachment.data.name,
              data: attachment.data,
              attachmentId: attachment.attachmentId,
              upload: true,
              attachmentUrl: attachment.attachmentUrl,
              metadata: attachment.metadata,
              type: attachment.type,
              size: attachment.size
            };

            if (sendAsSeparateMessage) {
              if (index !== 0) {
                messageToSend.body = '';
              }

              dispatch(sendMessageAC(_extends({}, messageToSend, {
                attachments: [attachmentToSend]
              }), activeChannel.id, connectionStatus, true));
            }

            return attachmentToSend;
          });

          if (!sendAsSeparateMessage) {
            dispatch(sendMessageAC(messageToSend, activeChannel.id, connectionStatus, false));
          }
        }

        setMessageText('');
        messageInputRef.current.innerText = '';
        setAttachments([]);
        handleCloseReply();
        setMentionedMembers([]);
        setMentionedMembersDisplayName([]);
        setOpenMention(false);
        setMentionTyping(false);
        setCurrentMentions(undefined);
        fileUploader.current.value = '';

        if (inTypingState) {
          handleSendTypingState(false);
        }

        clearTimeout(typingTimout);
        setTypingTimout(undefined);
      }
    }
  };

  var handleEditMessage = function handleEditMessage() {
    var messageTexToSend = editMessageText.trim();
    var mentionedMembersPositions = messageToEdit.metadata;
    var mentionedUserForSend = messageToEdit.mentionedUsers;

    if (messageToEdit.mentionedUsers && messageToEdit.mentionedUsers.length) {
      mentionedMembersPositions = {};
      var findIndexes = [];
      mentionedUserForSend.forEach(function (menMem) {
        var mentionedMembersDisplayName = "@" + menMem.firstName + (menMem.lastName !== '' ? " " + menMem.lastName : '');
        var menIndex = messageTexToSend.indexOf(mentionedMembersDisplayName);
        var existingIndex = findIndexes.includes(menIndex);
        var i = 0;

        if (menIndex < 0) {
          mentionedUserForSend = messageToEdit.mentionedUsers.filter(function (menUs) {
            return menUs.id !== menMem.id;
          });
        } else {
          while (existingIndex) {
            menIndex = messageTexToSend.indexOf(menMem.displayName, menIndex + 1);
            existingIndex = findIndexes.includes(menIndex);
            i++;

            if (i > mentionedUserForSend.length) {
              break;
            }
          }

          var mentionDisplayLength = mentionedMembersDisplayName.length;

          if (!mentionedMembersPositions[menMem.id] && menIndex >= 0) {
            var _extends2;

            findIndexes.push(menIndex);
            mentionedMembersPositions = _extends({}, mentionedMembersPositions, (_extends2 = {}, _extends2[menMem.id] = {
              loc: menIndex,
              len: mentionDisplayLength
            }, _extends2));
          }
        }
      });
    }

    var messageToSend = _extends({}, messageToEdit, {
      metadata: mentionedMembersPositions,
      mentionedUsers: mentionedUserForSend,
      body: messageTexToSend
    });

    messageToSend.type = /(https?:\/\/[^\s]+)/.test(messageToSend.body) ? 'link' : messageToSend.type;
    dispatch(editMessageAC(activeChannel.id, messageToSend));
    handleCloseEditMode();
  };

  var handleCloseEditMode = function handleCloseEditMode() {
    setEditMessageText('');

    if (messageInputRef.current) {
      messageInputRef.current.innerText = '';
    }

    dispatch(setMessageToEditAC(null));
  };

  var removeUpload = function removeUpload(attachmentId) {
    if (attachmentId) {
      deleteVideoThumb(attachmentId);
      setAttachments(attachments.filter(function (item) {
        return item.attachmentId !== attachmentId;
      }));
    } else {
      setAttachments([]);
    }
  };

  var handleFileUpload = function handleFileUpload(e) {
    var isMediaAttachment = e.target.accept === mediaExtensions;
    var fileList = Object.values(e.target.files);
    fileList.forEach(function (file) {
      handleAddAttachment(file, isMediaAttachment);
      return Promise.resolve();
    });
    fileUploader.current.value = '';
  };

  var onOpenFileUploader = function onOpenFileUploader(attachmentType) {
    setShowChooseAttachmentType(false);
    fileUploader.current.accept = attachmentType;
    fileUploader.current.click();
  };

  var handlePastAttachments = function handlePastAttachments(e) {
    var os = detectOS();
    var browser = detectBrowser();

    if (os === 'Windows' && browser === 'Firefox') {
      e.preventDefault();
    } else {
      if (e.clipboardData.files && e.clipboardData.files.length > 0) {
        e.preventDefault();
        var fileList = Object.values(e.clipboardData.files);
        fileList.forEach(function (file) {
          handleAddAttachment(file, true);
          return Promise.resolve();
        });
      } else {
        e.preventDefault();
        document.execCommand('inserttext', false, e.clipboardData.getData('text/plain'));
      }
    }
  };

  var handleEmojiPopupToggle = function handleEmojiPopupToggle(bool) {
    setIsEmojisOpened(bool);
    messageInputRef.current.focus();
  };

  var setVideoIsReadyToSend = function setVideoIsReadyToSend(attachmentId) {
    var _extends3;

    setReadyVideoAttachments(_extends({}, readyVideoAttachments, (_extends3 = {}, _extends3[attachmentId] = true, _extends3)));
  };

  var handleJoinToChannel = function handleJoinToChannel() {
    dispatch(joinChannelAC(activeChannel.id));
  };

  var handleClick = function handleClick(e) {
    var emojisContainer = document.getElementById('emojisContainer');

    if (emojisContainer && !emojisContainer.contains(e.target) && emojiBtnRef.current && !emojiBtnRef.current.contains(e.target)) {
      setIsEmojisOpened(false);
    }
  };

  useEffect(function () {
    if (mentionedMembers.length) {
      var currentPos = getCaretPosition(messageInputRef.current);
      var mentionToEdit = mentionedMembers.find(function (menMem) {
        return menMem.start < currentPos && menMem.end >= currentPos;
      });

      if (mentionToEdit) {
        setMentionEdit(mentionToEdit);
        setCurrentMentions({
          start: mentionToEdit.start,
          typed: ''
        });
        setOpenMention(true);
        setMentionTyping(true);
      } else if (openMention || mentionTyping) {
        handleCloseMentionsPopup();
        setMentionTyping(false);
        setOpenMention(false);
      }
    }
  }, [selectionPos]);

  var handleAddAttachment = function handleAddAttachment(file, isMediaAttachment) {
    try {
      var customUploader = getCustomUploader();
      var fileType = file.type.split('/')[0];

      var _temp4 = function () {
        if (customUploader) {
          if (fileType === 'image') {
            resizeImage(file).then(function (resizedFile) {
              try {
                setAttachments(function (prevState) {
                  return [].concat(prevState, [{
                    data: file,
                    upload: false,
                    type: isMediaAttachment ? fileType : 'file',
                    attachmentUrl: URL.createObjectURL(resizedFile.blob),
                    attachmentId: v4(),
                    size: file.size
                  }]);
                });
                return Promise.resolve();
              } catch (e) {
                return Promise.reject(e);
              }
            });
          } else if (fileType === 'video') {
            setAttachments(function (prevState) {
              return [].concat(prevState, [{
                data: file,
                upload: false,
                type: isMediaAttachment ? fileType : 'file',
                attachmentUrl: URL.createObjectURL(file),
                attachmentId: v4(),
                size: file.size
              }]);
            });
          } else {
            setAttachments(function (prevState) {
              return [].concat(prevState, [{
                data: file,
                upload: false,
                type: 'file',
                attachmentUrl: URL.createObjectURL(file),
                attachmentId: v4(),
                size: file.size
              }]);
            });
          }
        } else {
          var _temp5 = function () {
            if (fileType === 'image') {
              if (isMediaAttachment) {
                resizeImage(file).then(function (resizedFile) {
                  try {
                    return Promise.resolve(createImageThumbnail(file)).then(function (_ref2) {
                      var thumbnail = _ref2.thumbnail;
                      setAttachments(function (prevState) {
                        return [].concat(prevState, [{
                          data: new File([resizedFile.blob], resizedFile.file.name),
                          attachmentUrl: URL.createObjectURL(file),
                          attachmentId: v4(),
                          type: fileType,
                          metadata: JSON.stringify({
                            tmb: thumbnail,
                            szw: resizedFile.newWidth,
                            szh: resizedFile.newHeight
                          })
                        }]);
                      });
                    });
                  } catch (e) {
                    return Promise.reject(e);
                  }
                });
              } else {
                createFileImageThumbnail(file).then(function (thumbnail) {
                  setAttachments(function (prevState) {
                    return [].concat(prevState, [{
                      data: file,
                      type: 'file',
                      attachmentUrl: URL.createObjectURL(file),
                      attachmentId: v4(),
                      metadata: JSON.stringify({
                        tmb: thumbnail
                      })
                    }]);
                  });
                });
              }
            } else {
              var _temp6 = function () {
                if (fileType === 'video') {
                  return Promise.resolve(getFrame(URL.createObjectURL(file), 1)).then(function (_ref3) {
                    var thumb = _ref3.thumb,
                        width = _ref3.width,
                        height = _ref3.height;
                    setAttachments(function (prevState) {
                      return [].concat(prevState, [{
                        data: file,
                        type: 'video',
                        attachmentUrl: URL.createObjectURL(file),
                        attachmentId: v4(),
                        metadata: JSON.stringify({
                          tmb: thumb,
                          szw: width,
                          szh: height
                        })
                      }]);
                    });
                  });
                } else {
                  setAttachments(function (prevState) {
                    return [].concat(prevState, [{
                      data: file,
                      type: 'file',
                      attachmentUrl: URL.createObjectURL(file),
                      attachmentId: v4()
                    }]);
                  });
                }
              }();

              if (_temp6 && _temp6.then) return _temp6.then(function () {});
            }
          }();

          if (_temp5 && _temp5.then) return _temp5.then(function () {});
        }
      }();

      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  useEffect(function () {
    if (typingTimout === 0) {
      handleSendTypingState(false);
    }
  }, [typingTimout]);
  useDidUpdate(function () {
    if (draggedAttachments.length > 0) {
      var attachmentsFiles = draggedAttachments.map(function (draggedData) {
        var arr = draggedData.data.split(',');
        var bstr = atob(arr[1]);
        var n = bstr.length;
        var u8arr = new Uint8Array(n);

        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }

        return new File([u8arr], draggedData.name, {
          type: draggedData.type
        });
      });
      attachmentsFiles.forEach(function (file) {
        try {
          handleAddAttachment(file, draggedAttachments[0].attachmentType === 'media');
          return Promise.resolve();
        } catch (e) {
          return Promise.reject(e);
        }
      });
      dispatch(setDraggedAttachments([], ''));
    }
  }, [draggedAttachments]);
  useEffect(function () {
    if (prevActiveChannelId && activeChannel.id && prevActiveChannelId !== activeChannel.id) {
      setMessageText('');
      handleCloseReply();
      setMentionedMembersDisplayName([]);
      setAttachments([]);
      handleCloseEditMode();
      clearTimeout(typingTimout);
    } else if (activeChannel.id) {
      prevActiveChannelId = activeChannel.id;
    }

    if (messageInputRef.current) {
      messageInputRef.current.focus();
    }

    setMentionedMembers([]);
    setOpenMention(false);
    setCurrentMentions(undefined);
    setMentionTyping(false);
  }, [activeChannel.id]);
  useEffect(function () {
    if (messageText || editMessageText && editMessageText !== messageToEdit.body || attachments.length) {
      if (attachments.length) {
        var videoAttachment = false;
        attachments.forEach(function (att) {
          if (att.type === 'video') {
            videoAttachment = true;

            if (!readyVideoAttachments[att.attachmentId]) {
              setSendMessageIsActive(false);
            } else {
              setSendMessageIsActive(true);
            }
          }
        });

        if (!videoAttachment) {
          setSendMessageIsActive(true);
        }
      } else {
        setSendMessageIsActive(true);
      }
    } else {
      setSendMessageIsActive(false);
    }
  }, [messageText, attachments, editMessageText, readyVideoAttachments]);
  useEffect(function () {
    if (connectionStatus === CONNECTION_STATUS.CONNECTED) {
      setTimeout(function () {
        var pendingMessagesMap = getPendingMessagesMap();
        Object.keys(pendingMessagesMap).forEach(function (key) {
          pendingMessagesMap[key].forEach(function (msg) {
            dispatch(resendMessageAC(msg, key, connectionStatus));
          });
        });
      }, 1000);
    }
  }, [connectionStatus]);
  useEffect(function () {
    if (handleAttachmentSelected) {
      handleAttachmentSelected(!!attachments.length);
    }

    if (messageContRef && messageContRef.current) {
      dispatch(setSendMessageInputHeightAC(messageContRef.current.getBoundingClientRect().height));
    }
  }, [attachments]);
  useEffect(function () {
    if (messageForReply && messageToEdit) {
      handleCloseEditMode();
    }

    if (messageContRef && messageContRef.current) {
      dispatch(setSendMessageInputHeightAC(messageContRef.current.getBoundingClientRect().height));
    }

    if (messageInputRef.current) {
      messageInputRef.current.focus();
    }
  }, [messageForReply]);
  useEffect(function () {
    if (messageToEdit && messageInputRef.current) {
      setEditMessageText(messageToEdit.body || '');
      messageInputRef.current.innerText = messageToEdit.body;
      placeCaretAtEnd(messageInputRef.current);
      messageInputRef.current.focus();

      if (messageForReply) {
        handleCloseReply();
      }
    }

    if (messageContRef && messageContRef.current) {
      dispatch(setSendMessageInputHeightAC(messageContRef.current.getBoundingClientRect().height));
    }

    if (messageInputRef.current) {
      messageInputRef.current.focus();
    }
  }, [messageToEdit]);
  useEffect(function () {
    if (emojiBtnRef.current && emojiBtnRef.current.offsetLeft > messageInputRef.current.offsetWidth) {
      setEmojisInRightSide(true);
    }

    document.addEventListener('mousedown', handleClick);
    return function () {
      document.removeEventListener('mousedown', handleClick);
    };
  }, []);
  return React__default.createElement(Container$f, {
    margin: margin,
    border: border,
    borderRadius: borderRadius,
    ref: messageContRef
  }, !activeChannel.id ? React__default.createElement(Loading, null) : isBlockedUserChat || isDeletedUserChat || disabled ? React__default.createElement(BlockedUserInfo, null, React__default.createElement(SvgErrorCircle, null), ' ', isDeletedUserChat ? 'This user has been deleted.' : disabled ? "Sender doesn't support replies" : 'You blocked this user.') : !activeChannel.role ? React__default.createElement(JoinChannelCont, {
    onClick: handleJoinToChannel,
    color: colors.primary
  }, "Join") : (activeChannel.type === CHANNEL_TYPE.PUBLIC ? !(activeChannel.role === 'admin' || activeChannel.role === 'owner') : !checkActionPermission('sendMessage')) ? React__default.createElement(ReadOnlyCont, {
    iconColor: colors.primary
  }, React__default.createElement(SvgEye, null), " Read only") : React__default.createElement(React__default.Fragment, null, React__default.createElement(TypingIndicator$1, null, CustomTypingIndicator ? React__default.createElement(CustomTypingIndicator, {
    from: typingIndicator.from,
    typingState: typingIndicator.typingState
  }) : typingIndicator && typingIndicator.typingState && React__default.createElement(TypingIndicatorCont, null, React__default.createElement(TypingFrom, null, contactsMap[typingIndicator.from.id] && contactsMap[typingIndicator.from.id].firstName || typingIndicator.from.id, ' ', "is typing"), React__default.createElement(TypingAnimation, null, React__default.createElement(DotOne, null), React__default.createElement(DotTwo, null), React__default.createElement(DotThree, null)))), isEmojisOpened && React__default.createElement(EmojisPopup, {
    handleAddEmoji: handleAddEmoji,
    handleEmojiPopupToggle: handleEmojiPopupToggle,
    rightSide: emojisInRightSide
  }), messageToEdit && React__default.createElement(EditReplyMessageCont, null, React__default.createElement(CloseEditMode, {
    onClick: handleCloseEditMode
  }, React__default.createElement(SvgClose, null)), React__default.createElement(EditReplyMessageHeader, {
    color: colors.primary
  }, React__default.createElement(SvgEdit, null), "Edit Message"), React__default.createElement(EditMessageText, null, messageToEdit.body)), messageForReply && React__default.createElement(EditReplyMessageCont, null, React__default.createElement(CloseEditMode, {
    onClick: handleCloseReply
  }, React__default.createElement(SvgClose, null)), React__default.createElement(ReplyMessageCont, null, !!(messageForReply.attachments && messageForReply.attachments.length) && (messageForReply.attachments[0].type === attachmentTypes.image || messageForReply.attachments[0].type === attachmentTypes.video ? React__default.createElement(Attachment, {
    attachment: messageForReply.attachments[0],
    backgroundColor: selectedFileAttachmentsBoxBackground || '',
    isRepliedMessage: true
  }) : messageForReply.attachments[0].type === attachmentTypes.file && React__default.createElement(ReplyIconWrapper, {
    backgroundColor: colors.primary
  }, React__default.createElement(SvgChoseFile, null))), React__default.createElement("div", null, React__default.createElement(EditReplyMessageHeader, {
    color: colors.primary
  }, replyMessageIcon || React__default.createElement(SvgReplyIcon, null), " Reply to", React__default.createElement(UserName$1, null, user.id === messageForReply.user.id ? user.firstName ? user.firstName + " " + user.lastName : user.id : makeUserName(contactsMap[messageForReply.user.id], messageForReply.user, getFromContacts))), messageForReply.attachments && messageForReply.attachments.length ? messageForReply.attachments[0].type === attachmentTypes.voice ? 'Voice' : messageForReply.attachments[0].type === attachmentTypes.image ? React__default.createElement(TextInOneLine, null, messageForReply.body || 'Photo') : messageForReply.attachments[0].type === attachmentTypes.video ? React__default.createElement(TextInOneLine, null, messageForReply.body || 'Video') : React__default.createElement(TextInOneLine, null, messageForReply.body || 'File') : MessageTextFormat({
    text: messageForReply.body,
    message: messageForReply,
    contactsMap: contactsMap,
    getFromContacts: getFromContacts
  })))), !!attachments.length && React__default.createElement(ChosenAttachments, {
    fileBoxWidth: selectedFileAttachmentsBoxWidth
  }, attachments.map(function (attachment) {
    return React__default.createElement(Attachment, {
      attachment: attachment,
      isPrevious: true,
      removeSelected: removeUpload,
      key: attachment.attachmentId,
      setVideoIsReadyToSend: setVideoIsReadyToSend,
      borderRadius: selectedAttachmentsBorderRadius,
      selectedFileAttachmentsIcon: selectedFileAttachmentsIcon,
      backgroundColor: selectedFileAttachmentsBoxBackground || '',
      selectedFileAttachmentsBoxBorder: selectedFileAttachmentsBoxBorder,
      selectedFileAttachmentsTitleColor: selectedFileAttachmentsTitleColor,
      selectedFileAttachmentsSizeColor: selectedFileAttachmentsSizeColor
    });
  })), React__default.createElement(SendMessageInputContainer, {
    border: border,
    borderRadius: borderRadius,
    iconColor: colors.primary
  }, React__default.createElement(DropDown, {
    forceClose: showChooseAttachmentType,
    position: 'top',
    order: attachmentIcoOrder === 0 || attachmentIcoOrder ? attachmentIcoOrder : 4,
    trigger: React__default.createElement(AddAttachmentIcon, {
      color: colors.primary
    }, React__default.createElement(SvgAttachment, null))
  }, React__default.createElement(DropdownOptionsUl, null, React__default.createElement(DropdownOptionLi, {
    key: 1,
    textColor: colors.gray6,
    hoverBackground: colors.gray5,
    onClick: function onClick() {
      return onOpenFileUploader(mediaExtensions);
    },
    iconWidth: '20px',
    iconColor: colors.gray4
  }, React__default.createElement(SvgChoseMedia, null), "Photo or video"), React__default.createElement(DropdownOptionLi, {
    key: 2,
    textColor: colors.gray6,
    hoverBackground: colors.gray5,
    onClick: function onClick() {
      return onOpenFileUploader('');
    },
    iconWidth: '20px',
    iconColor: colors.gray4
  }, React__default.createElement(SvgChoseFile, null), "File"))), !hideEmojis && React__default.createElement(EmojiButton, {
    order: emojiIcoOrder,
    isEmojisOpened: isEmojisOpened,
    ref: emojiBtnRef,
    hoverColor: colors.primary,
    onClick: function onClick() {
      setIsEmojisOpened(!isEmojisOpened);
    }
  }, React__default.createElement(SvgEmojiSmileIcon, null)), React__default.createElement(MentionsContainer, {
    ref: mentionsRef,
    mentionsIsOpen: openMention
  }, openMention && React__default.createElement(MentionMembersPopup, {
    channelId: activeChannel.id,
    addMentionMember: handleSetMention,
    searchMention: currentMentions.typed,
    handleMentionsPopupClose: handleCloseMentionsPopup
  })), React__default.createElement(UploadFile, {
    ref: fileUploader,
    onChange: handleFileUpload,
    multiple: true,
    type: 'file'
  }), React__default.createElement(MessageInputWrapper, {
    order: inputOrder
  }, React__default.createElement(MessageInput, {
    contentEditable: true,
    suppressContentEditableWarning: true,
    onKeyUp: handleTyping,
    onPaste: handlePastAttachments,
    onKeyPress: handleSendEditMessage,
    "data-placeholder": 'Type message here ...',
    ref: messageInputRef
  })), React__default.createElement(SendMessageIcon, {
    isActive: sendMessageIsActive,
    order: sendIconOrder,
    onClick: sendMessageIsActive ? handleSendEditMessage : null
  }, React__default.createElement(SvgSend, null)))));
};

var Container$f = styled.div(_templateObject$v || (_templateObject$v = _taggedTemplateLiteralLoose(["\n  margin: ", ";\n  border-top: 1px solid ", ";\n  border: ", ";\n  border-radius: ", ";\n  position: relative;\n  padding: 0 12px;\n"])), function (props) {
  return props.margin || '30px 16px 16px';
}, colors.gray1, function (props) {
  return props.border || '';
}, function (props) {
  return props.borderRadius || '4px';
});
var EditReplyMessageCont = styled.div(_templateObject2$t || (_templateObject2$t = _taggedTemplateLiteralLoose(["\n  position: relative;\n  left: -12px;\n  width: calc(100% - 8px);\n  padding: 8px 16px;\n  font-weight: 400;\n  font-size: 15px;\n  line-height: 20px;\n  letter-spacing: -0.2px;\n  color: ", ";\n  background-color: ", ";\n  z-index: 19;\n  border-bottom: 1px solid ", ";\n"])), colors.gray6, colors.gray5, colors.gray1);
var EditMessageText = styled.p(_templateObject3$n || (_templateObject3$n = _taggedTemplateLiteralLoose(["\n  margin: 0;\n  display: -webkit-box;\n  -webkit-line-clamp: 3;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n  text-overflow: ellipsis;\n"])));
var CloseEditMode = styled.span(_templateObject4$k || (_templateObject4$k = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  top: 8px;\n  right: 12px;\n  width: 20px;\n  height: 20px;\n  text-align: center;\n  line-height: 22px;\n  cursor: pointer;\n\n  & > svg {\n    color: ", ";\n  }\n"])), colors.gray4);
var UserName$1 = styled.span(_templateObject5$g || (_templateObject5$g = _taggedTemplateLiteralLoose(["\n  font-weight: 500;\n  margin-left: 4px;\n"])));
var EditReplyMessageHeader = styled.h4(_templateObject6$f || (_templateObject6$f = _taggedTemplateLiteralLoose(["\n  display: flex;\n  margin: 0 0 2px;\n  font-weight: 400;\n  font-size: 13px;\n  line-height: 16px;\n  color: ", ";\n\n  > svg {\n    margin-right: 4px;\n    width: 16px;\n    height: 16px;\n  }\n"])), function (props) {
  return props.color || colors.primary;
});
var AddAttachmentIcon = styled.span(_templateObject7$d || (_templateObject7$d = _taggedTemplateLiteralLoose(["\n  display: flex;\n  height: 48px;\n  align-items: center;\n  margin: 0 5px;\n  cursor: pointer;\n  line-height: 13px;\n  z-index: 2;\n  order: ", ";\n\n  > svg {\n    ", "\n  }\n\n  &:hover > svg {\n    color: ", ";\n  }\n"])), function (props) {
  return props.order === 0 || props.order ? props.order : 1;
}, function (props) {
  return props.isActive ? "color: " + (props.color || colors.primary) + ";" : 'color: #898B99;';
}, function (props) {
  return props.color || colors.primary;
});
var SendMessageInputContainer = styled.div(_templateObject8$b || (_templateObject8$b = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: flex-end;\n  position: relative;\n  min-height: 48px;\n  box-sizing: border-box;\n  border-radius: ", ";\n\n  & .dropdown-trigger.open {\n    color: #ccc;\n    & ", " {\n      & > svg {\n        color: ", ";\n        };\n      }\n    }\n  }\n"])), function (props) {
  return props.messageForReply ? '0 0 4px 4px' : '4px';
}, AddAttachmentIcon, function (props) {
  return props.iconColor || colors.primary;
});
var MessageInputWrapper = styled.div(_templateObject9$a || (_templateObject9$a = _taggedTemplateLiteralLoose(["\n  width: 100%;\n  position: relative;\n  order: ", ";\n"])), function (props) {
  return props.order === 0 || props.order ? props.order : 3;
});
var MessageInput = styled.div(_templateObject10$8 || (_templateObject10$8 = _taggedTemplateLiteralLoose(["\n  margin: 14px 12px 14px 12px;\n  //width: 100%;\n  max-height: 80px;\n  min-height: 20px;\n  display: block;\n  border: none;\n  font: inherit;\n  box-sizing: border-box;\n  border-radius: 6px;\n  outline: none !important;\n  font-size: 15px;\n  line-height: 20px;\n  overflow: auto;\n\n  &:empty:before {\n    content: attr(data-placeholder);\n  }\n  &:before {\n    position: absolute;\n    top: 15px;\n    left: 12px;\n    font-size: 15px;\n    color: ", ";\n    pointer-events: none;\n    unicode-bidi: plaintext;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    max-width: 100%;\n  }\n  &::placeholder {\n    font-size: 15px;\n    color: ", ";\n    opacity: 1;\n  }\n  //caret-color: #000;\n"])), colors.gray7, colors.gray7);
var EmojiButton = styled.span(_templateObject11$6 || (_templateObject11$6 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  height: 48px;\n  align-items: center;\n  position: relative;\n  margin: 0 5px;\n  cursor: pointer;\n  line-height: 13px;\n  z-index: 2;\n  order: ", ";\n  > svg {\n    ", "\n  }\n\n  &:hover > svg {\n    color: ", ";\n  }\n"])), function (props) {
  return props.order === 0 || props.order ? props.order : 2;
}, function (props) {
  return props.isEmojisOpened ? "color: " + (props.hoverColor || colors.primary) + ";" : 'color: #898B99;';
}, function (props) {
  return props.hoverColor || colors.primary;
});
var MentionsContainer = styled.div(_templateObject12$5 || (_templateObject12$5 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  left: 0;\n  bottom: 100%;\n  z-index: 9998;\n"])));
var SendMessageIcon = styled.span(_templateObject13$4 || (_templateObject13$4 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  height: 48px;\n  align-items: center;\n  margin: 0 5px;\n  cursor: pointer;\n  line-height: 13px;\n  order: ", ";\n\n  color: ", ";\n"])), function (props) {
  return props.order === 0 || props.order ? props.order : 4;
}, function (props) {
  return props.isActive ? colors.primary : '#ccc';
});
var ChosenAttachments = styled.div(_templateObject14$4 || (_templateObject14$4 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  padding: 16px 16px 14px;\n  overflow-x: auto;\n\n  & ", " {\n    width: 100%;\n    height: 100%;\n    border-radius: 4px;\n    object-fit: cover;\n  }\n\n  & ", " {\n    width: ", ";\n    padding: 6px 12px;\n    height: 48px;\n  }\n"])), AttachmentImg$1, AttachmentFile$1, function (props) {
  return props.fileBoxWidth || '200px';
});
var TypingIndicator$1 = styled.div(_templateObject15$3 || (_templateObject15$3 = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  bottom: 100%;\n  left: 16px;\n"])));
var TypingIndicatorCont = styled.div(_templateObject16$2 || (_templateObject16$2 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  margin-bottom: 12px;\n"])));
var TypingFrom = styled.h5(_templateObject17$2 || (_templateObject17$2 = _taggedTemplateLiteralLoose(["\n  margin: 0 4px 0 0;\n  font-weight: 400;\n  font-size: 13px;\n  line-height: 16px;\n  letter-spacing: -0.2px;\n  color: ", ";\n"])), colors.gray9);
var sizeAnimation = keyframes(_templateObject18$2 || (_templateObject18$2 = _taggedTemplateLiteralLoose(["\n  0% {\n    width: 2px;\n    height: 2px;\n    opacity: 0.4;\n  }\n  100% {\n    width: 6px;\n    height: 6px;\n    opacity: 1;\n  }\n"])));
var DotOne = styled.span(_templateObject19$2 || (_templateObject19$2 = _taggedTemplateLiteralLoose([""])));
var DotTwo = styled.span(_templateObject20$1 || (_templateObject20$1 = _taggedTemplateLiteralLoose([""])));
var DotThree = styled.span(_templateObject21$1 || (_templateObject21$1 = _taggedTemplateLiteralLoose([""])));
var TypingAnimation = styled.div(_templateObject22$1 || (_templateObject22$1 = _taggedTemplateLiteralLoose(["\n  display: flex;\n\n  & > span {\n    position: relative;\n    width: 6px;\n    height: 6px;\n    margin-right: 3px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    animation-timing-function: linear;\n\n    &:after {\n      content: '';\n      position: absolute;\n\n      width: 3.5px;\n      height: 3.5px;\n      border-radius: 50%;\n      background-color: #818c99;\n      animation-name: ", ";\n      animation-duration: 0.6s;\n      animation-iteration-count: infinite;\n    }\n  }\n  & ", " {\n    &:after {\n      animation-delay: 0s;\n    }\n  }\n  & ", " {\n    &:after {\n      animation-delay: 0.2s;\n    }\n  }\n  & ", " {\n    &:after {\n      animation-delay: 0.3s;\n    }\n  }\n"])), sizeAnimation, DotOne, DotTwo, DotThree);
var Loading = styled.div(_templateObject23$1 || (_templateObject23$1 = _taggedTemplateLiteralLoose(["\n  height: 48px;\n"])));
var BlockedUserInfo = styled.div(_templateObject24$1 || (_templateObject24$1 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 12px;\n  font-weight: 400;\n  font-size: 15px;\n  line-height: 20px;\n  color: ", ";\n\n  & > svg {\n    margin-right: 12px;\n  }\n"])), colors.gray6);
var JoinChannelCont = styled.div(_templateObject25$1 || (_templateObject25$1 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin: 0 -12px;\n  padding: 14px;\n  font-weight: 500;\n  font-size: 15px;\n  line-height: 20px;\n  letter-spacing: -0.2px;\n  color: ", ";\n  background-color: ", ";\n  cursor: pointer;\n"])), function (props) {
  return props.color || colors.primary;
}, colors.gray5);
var ReadOnlyCont = styled.div(_templateObject26$1 || (_templateObject26$1 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 12px;\n  font-weight: 500;\n  font-size: 15px;\n  line-height: 20px;\n  letter-spacing: -0.2px;\n  color: ", ";\n\n  & > svg {\n    margin-right: 12px;\n    color: ", ";\n  }\n"])), colors.gray6, function (props) {
  return props.iconColor || colors.primary;
});
var ReplyMessageCont = styled.div(_templateObject27$1 || (_templateObject27$1 = _taggedTemplateLiteralLoose(["\n  display: flex;\n"])));
var ReplyIconWrapper = styled.span(_templateObject28$1 || (_templateObject28$1 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-right: 12px;\n  width: 40px;\n  height: 40px;\n  background-color: ", ";\n  border-radius: 50%;\n  & > svg {\n    width: 20px;\n    height: 20px;\n    color: ", ";\n  }\n"])), function (props) {
  return props.backgroundColor || colors.primary;
}, colors.white);

var _path$10;

function _extends$13() {
  _extends$13 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$13.apply(this, arguments);
}

function SvgBottom(props) {
  return /*#__PURE__*/createElement("svg", _extends$13({
    width: 12,
    height: 7,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$10 || (_path$10 = /*#__PURE__*/createElement("path", {
    d: "M1.5 1.5l4.5 4 4.5-4",
    stroke: "#676A7C",
    strokeWidth: 1.4,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })));
}

var _path$11;

function _extends$14() {
  _extends$14 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$14.apply(this, arguments);
}

function SvgNotificationsOff2(props) {
  return /*#__PURE__*/createElement("svg", _extends$14({
    width: 16,
    height: 16,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$11 || (_path$11 = /*#__PURE__*/createElement("path", {
    d: "M9.259 14.3a1.454 1.454 0 01-2.517 0M12.821 9.007a13.013 13.013 0 01-.458-3.636M3.826 4.105c-.126.41-.19.837-.189 1.266 0 5.09-2.182 6.545-2.182 6.545h10.182M12.365 5.37a4.363 4.363 0 00-6.786-3.636M1 1l14 14",
    stroke: "CurrentColor",
    strokeWidth: 1.4,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })));
}

var _path$12, _circle$6;

function _extends$15() {
  _extends$15 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$15.apply(this, arguments);
}

function SvgMarkAsUnRead(props) {
  return /*#__PURE__*/createElement("svg", _extends$15({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$12 || (_path$12 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M17.778 8.516a3.958 3.958 0 01-5.117-5.982 7.847 7.847 0 00-2.631-.451c-4.356 0-7.887 3.544-7.887 7.917 0 1.359.341 2.638.942 3.755l-.967 3.118a.732.732 0 00.912.919l3.043-.943a7.827 7.827 0 003.957 1.067c4.356 0 7.887-3.544 7.887-7.916 0-.507-.048-1.003-.139-1.484z",
    fill: "CurrentColor"
  })), _circle$6 || (_circle$6 = /*#__PURE__*/createElement("circle", {
    cx: 15.542,
    cy: 5.25,
    r: 1.875,
    fill: "CurrentColor",
    stroke: "CurrentColor"
  })));
}

var _path$13;

function _extends$16() {
  _extends$16 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$16.apply(this, arguments);
}

function SvgMarkAsRead(props) {
  return /*#__PURE__*/createElement("svg", _extends$16({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$13 || (_path$13 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M17.917 10c0 4.372-3.531 7.916-7.887 7.916a7.827 7.827 0 01-3.957-1.067l-3.043.943a.732.732 0 01-.913-.919l.968-3.118A7.904 7.904 0 012.143 10c0-4.373 3.531-7.917 7.887-7.917S17.917 5.627 17.917 10z",
    fill: "CurrentColor"
  })));
}

var _path$14;

function _extends$17() {
  _extends$17 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$17.apply(this, arguments);
}

function SvgDeleteChannel(props) {
  return /*#__PURE__*/createElement("svg", _extends$17({
    width: 20,
    height: 21,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$14 || (_path$14 = /*#__PURE__*/createElement("path", {
    d: "M5 16.333C5 17.25 5.75 18 6.667 18h6.666C14.25 18 15 17.25 15 16.333V8c0-.917-.75-1.667-1.667-1.667H6.667C5.75 6.333 5 7.083 5 8v8.333zm10-12.5h-2.083l-.592-.591A.84.84 0 0011.742 3H8.258a.84.84 0 00-.583.242l-.592.591H5a.836.836 0 00-.833.834c0 .458.375.833.833.833h10a.836.836 0 00.833-.833.836.836 0 00-.833-.834z",
    fill: "CurrentColor"
  })));
}

var _path$15;

function _extends$18() {
  _extends$18 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$18.apply(this, arguments);
}

function SvgClear(props) {
  return /*#__PURE__*/createElement("svg", _extends$18({
    width: 20,
    height: 21,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$15 || (_path$15 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10 3.833a6.667 6.667 0 100 13.333 6.667 6.667 0 000-13.333zm-8.333 6.666a8.333 8.333 0 1116.667 0 8.333 8.333 0 01-16.667 0zM6.911 7.41a.833.833 0 011.179 0L10 9.32l1.911-1.91A.833.833 0 0113.09 8.59l-1.911 1.91 1.91 1.911a.833.833 0 01-1.178 1.179l-1.91-1.911-1.911 1.91A.833.833 0 016.91 12.41l1.91-1.91-1.91-1.911a.833.833 0 010-1.179z",
    fill: "#FA4C56"
  })));
}

var _path$16;

function _extends$19() {
  _extends$19 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$19.apply(this, arguments);
}

function SvgBlockChannel(props) {
  return /*#__PURE__*/createElement("svg", _extends$19({
    width: 20,
    height: 21,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$16 || (_path$16 = /*#__PURE__*/createElement("path", {
    d: "M10 2.167A8.336 8.336 0 001.667 10.5c0 4.6 3.733 8.334 8.333 8.334s8.333-3.734 8.333-8.334S14.6 2.167 10 2.167zm0 15A6.665 6.665 0 013.333 10.5c0-1.541.525-2.958 1.409-4.083l9.341 9.342A6.586 6.586 0 0110 17.167zm5.258-2.583L5.917 5.242A6.585 6.585 0 0110 3.834a6.665 6.665 0 016.667 6.666 6.586 6.586 0 01-1.409 4.084z",
    fill: "CurrentColor"
  })));
}

var _path$17, _path2$7;

function _extends$1a() {
  _extends$1a = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1a.apply(this, arguments);
}

function SvgReport(props) {
  return /*#__PURE__*/createElement("svg", _extends$1a({
    width: 20,
    height: 21,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$17 || (_path$17 = /*#__PURE__*/createElement("path", {
    d: "M9.096 10.402a.882.882 0 011.765 0v3.627a.882.882 0 11-1.765 0v-3.627zM9.979 6.088a.98.98 0 100 1.96.98.98 0 000-1.96z",
    fill: "CurrentColor"
  })), _path2$7 || (_path2$7 = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10 17.27A6.77 6.77 0 1010 3.73a6.77 6.77 0 000 13.542zm0 1.563a8.333 8.333 0 100-16.667 8.333 8.333 0 000 16.667z",
    fill: "CurrentColor"
  })));
}

var _path$18;

function _extends$1b() {
  _extends$1b = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1b.apply(this, arguments);
}

function SvgStar(props) {
  return /*#__PURE__*/createElement("svg", _extends$1b({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$18 || (_path$18 = /*#__PURE__*/createElement("path", {
    d: "M12.888 7.002l3.823.367c1.33.128 1.739 1.43.711 2.285l-2.993 2.49 1.111 4.06c.365 1.332-.767 2.14-1.901 1.337l-3.637-2.573-3.637 2.573c-1.13.799-2.267-.005-1.902-1.338l1.111-4.058-2.993-2.491c-1.032-.86-.625-2.156.711-2.285l3.823-.367 1.684-3.889c.528-1.217 1.878-1.217 2.405 0l1.684 3.889z",
    fill: "#B2B6BE"
  })));
}

var _path$19;

function _extends$1c() {
  _extends$1c = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1c.apply(this, arguments);
}

function SvgPin(props) {
  return /*#__PURE__*/createElement("svg", _extends$1c({
    width: 20,
    height: 20,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$19 || (_path$19 = /*#__PURE__*/createElement("path", {
    d: "M12.253 2.663a.583.583 0 01.825 0l4.258 4.258a.583.583 0 01-.412.996h-1.509l-2.5 2.5v5.218a.6.6 0 01-1.024.424l-3.24-3.24-3.956 3.958a1.042 1.042 0 11-1.473-1.473l3.956-3.958L3.94 8.108a.6.6 0 01-.168-.33l-.007-.095a.6.6 0 01.6-.6h5.218l2.5-2.5V3.075c0-.155.061-.303.17-.412z",
    fill: "#B2B6BE"
  })));
}

var _templateObject$w, _templateObject2$u, _templateObject3$o, _templateObject4$l, _templateObject5$h, _templateObject6$g;

var Actions$1 = function Actions(_ref) {
  var channel = _ref.channel,
      actionMenuOpen = _ref.actionMenuOpen,
      menuIsOpen = _ref.menuIsOpen,
      toggleable = _ref.toggleable,
      _ref$showMuteUnmuteNo = _ref.showMuteUnmuteNotifications,
      showMuteUnmuteNotifications = _ref$showMuteUnmuteNo === void 0 ? true : _ref$showMuteUnmuteNo,
      muteUnmuteNotificationsOrder = _ref.muteUnmuteNotificationsOrder,
      muteNotificationIcon = _ref.muteNotificationIcon,
      unmuteNotificationIcon = _ref.unmuteNotificationIcon,
      muteNotificationIconColor = _ref.muteNotificationIconColor,
      unmuteNotificationIconColor = _ref.unmuteNotificationIconColor,
      muteUnmuteNotificationTextColor = _ref.muteUnmuteNotificationTextColor,
      timeOptionsToMuteNotifications = _ref.timeOptionsToMuteNotifications,
      _ref$showStarredMessa = _ref.showStarredMessages,
      showStarredMessages = _ref$showStarredMessa === void 0 ? false : _ref$showStarredMessa,
      starredMessagesOrder = _ref.starredMessagesOrder,
      staredMessagesIcon = _ref.staredMessagesIcon,
      staredMessagesIconColor = _ref.staredMessagesIconColor,
      staredMessagesTextColor = _ref.staredMessagesTextColor,
      _ref$showPinChannel = _ref.showPinChannel,
      showPinChannel = _ref$showPinChannel === void 0 ? false : _ref$showPinChannel,
      pinChannelOrder = _ref.pinChannelOrder,
      pinChannelIcon = _ref.pinChannelIcon,
      pinChannelIconColor = _ref.pinChannelIconColor,
      pinChannelTextColor = _ref.pinChannelTextColor,
      _ref$showMarkAsReadUn = _ref.showMarkAsReadUnread,
      showMarkAsReadUnread = _ref$showMarkAsReadUn === void 0 ? true : _ref$showMarkAsReadUn,
      markAsReadUnreadOrder = _ref.markAsReadUnreadOrder,
      markAsReadIcon = _ref.markAsReadIcon,
      markAsUnreadIcon = _ref.markAsUnreadIcon,
      markAsReadIconColor = _ref.markAsReadIconColor,
      markAsUnreadIconColor = _ref.markAsUnreadIconColor,
      markAsReadUnreadTextColor = _ref.markAsReadUnreadTextColor,
      _ref$showLeaveChannel = _ref.showLeaveChannel,
      showLeaveChannel = _ref$showLeaveChannel === void 0 ? true : _ref$showLeaveChannel,
      leaveChannelOrder = _ref.leaveChannelOrder,
      leaveChannelIcon = _ref.leaveChannelIcon,
      leaveChannelIconColor = _ref.leaveChannelIconColor,
      leaveChannelTextColor = _ref.leaveChannelTextColor,
      _ref$showReportChanne = _ref.showReportChannel,
      showReportChannel = _ref$showReportChanne === void 0 ? true : _ref$showReportChanne,
      reportChannelIcon = _ref.reportChannelIcon,
      reportChannelOrder = _ref.reportChannelOrder,
      reportChannelIconColor = _ref.reportChannelIconColor,
      reportChannelTextColor = _ref.reportChannelTextColor,
      showDeleteChannel = _ref.showDeleteChannel,
      deleteChannelIcon = _ref.deleteChannelIcon,
      deleteChannelIconColor = _ref.deleteChannelIconColor,
      deleteChannelTextColor = _ref.deleteChannelTextColor,
      deleteChannelOrder = _ref.deleteChannelOrder,
      _ref$showBlockAndLeav = _ref.showBlockAndLeaveChannel,
      showBlockAndLeaveChannel = _ref$showBlockAndLeav === void 0 ? true : _ref$showBlockAndLeav,
      _ref$showBlockUser = _ref.showBlockUser,
      showBlockUser = _ref$showBlockUser === void 0 ? true : _ref$showBlockUser,
      blockAndLeaveChannelIcon = _ref.blockAndLeaveChannelIcon,
      unblockUserIcon = _ref.unblockUserIcon,
      blockAndLeaveChannelIconColor = _ref.blockAndLeaveChannelIconColor,
      blockAndLeaveChannelTextColor = _ref.blockAndLeaveChannelTextColor,
      unblockUserTextColor = _ref.unblockUserTextColor,
      blockUserWarningText = _ref.blockUserWarningText,
      blockAndLeavePublicChannelWarningText = _ref.blockAndLeavePublicChannelWarningText,
      blockAndLeavePrivateChannelWarningText = _ref.blockAndLeavePrivateChannelWarningText,
      leavePublicChannelWarningText = _ref.leavePublicChannelWarningText,
      leavePrivateChannelWarningText = _ref.leavePrivateChannelWarningText,
      deletePublicChannelWarningText = _ref.deletePublicChannelWarningText,
      deletePrivateChannelWarningText = _ref.deletePrivateChannelWarningText,
      deleteDirectChannelWarningText = _ref.deleteDirectChannelWarningText,
      showClearHistoryForDirectChannel = _ref.showClearHistoryForDirectChannel,
      showClearHistoryForPrivateChannel = _ref.showClearHistoryForPrivateChannel,
      showClearHistoryForPublicChannel = _ref.showClearHistoryForPublicChannel,
      clearHistoryOrder = _ref.clearHistoryOrder,
      clearHistoryIcon = _ref.clearHistoryIcon,
      clearHistoryTextColor = _ref.clearHistoryTextColor,
      showDeleteAllMessagesForDirectChannel = _ref.showDeleteAllMessagesForDirectChannel,
      showDeleteAllMessagesForPrivateChannel = _ref.showDeleteAllMessagesForPrivateChannel,
      showDeleteAllMessagesForPublicChannel = _ref.showDeleteAllMessagesForPublicChannel,
      deleteAllMessagesOrder = _ref.deleteAllMessagesOrder,
      deleteAllMessagesIcon = _ref.deleteAllMessagesIcon,
      deleteAllMessagesTextColor = _ref.deleteAllMessagesTextColor,
      clearHistoryPublicChannelWarningText = _ref.clearHistoryPublicChannelWarningText,
      clearHistoryPrivateChannelWarningText = _ref.clearHistoryPrivateChannelWarningText,
      clearHistoryDirectChannelWarningText = _ref.clearHistoryDirectChannelWarningText;

  var _useState = useState(false),
      clearHistoryPopupOpen = _useState[0],
      setClearHistoryPopupOpen = _useState[1];

  var _useState2 = useState(false),
      deleteAllMessagesPopupOpen = _useState2[0],
      setDeleteAllMessagesPopupOpenPopupOpen = _useState2[1];

  var _useState3 = useState(false),
      leaveChannelPopupOpen = _useState3[0],
      setLeaveChannelPopupOpen = _useState3[1];

  var _useState4 = useState(false),
      deleteChannelPopupOpen = _useState4[0],
      setDeleteChannelPopupOpen = _useState4[1];

  var _useState5 = useState(false),
      blockChannelPopupOpen = _useState5[0],
      setBlockChannelPopupOpen = _useState5[1];

  var _useState6 = useState(false),
      blockUserPopupOpen = _useState6[0],
      setBlockUserPopupOpen = _useState6[1];

  var _useState7 = useState(false),
      unblockUserPopupOpen = _useState7[0],
      setUnblockUserPopupOpen = _useState7[1];

  var _useState8 = useState(false),
      reportUserPopupOpen = _useState8[0],
      setReportUserPopupOpen = _useState8[1];

  var _usePermissions = usePermissions(channel.role),
      checkActionPermission = _usePermissions[0];

  var _useState9 = useState(''),
      popupButtonText = _useState9[0],
      setPopupButtonText = _useState9[1];

  var _useState10 = useState(''),
      popupTitle = _useState10[0],
      setPopupTitle = _useState10[1];

  var dispatch = useDispatch();
  var oneHour = 60 * 60 * 1000;
  var twoHours = oneHour * 2;
  var oneDay = oneHour * 24;
  var isDirectChannel = channel.type === CHANNEL_TYPE.DIRECT;
  var isPublicChannel = channel.type === CHANNEL_TYPE.PUBLIC;
  var isPrivateChannel = channel.type === CHANNEL_TYPE.PRIVATE;
  var channelType = channel.type === CHANNEL_TYPE.PUBLIC ? 'channel' : isDirectChannel ? 'chat' : 'group';

  var handleToggleClearHistoryPopup = function handleToggleClearHistoryPopup() {
    setClearHistoryPopupOpen(!clearHistoryPopupOpen);
  };

  var handleToggleDeleteAllMessagesPopup = function handleToggleDeleteAllMessagesPopup() {
    setDeleteAllMessagesPopupOpenPopupOpen(!deleteAllMessagesPopupOpen);
  };

  var handleToggleLeaveChannelPopupOpen = function handleToggleLeaveChannelPopupOpen() {
    setLeaveChannelPopupOpen(!leaveChannelPopupOpen);
  };

  var handleToggleDeleteChannelPopupOpen = function handleToggleDeleteChannelPopupOpen() {
    setDeleteChannelPopupOpen(!deleteChannelPopupOpen);
  };

  var handleToggleBlockChannelPopupOpen = function handleToggleBlockChannelPopupOpen() {
    setBlockChannelPopupOpen(!blockChannelPopupOpen);
  };

  var handleToggleBlockUserPopupOpen = function handleToggleBlockUserPopupOpen() {
    setBlockUserPopupOpen(!blockUserPopupOpen);
  };

  var handleToggleUnblockUserPopupOpen = function handleToggleUnblockUserPopupOpen() {
    setUnblockUserPopupOpen(!unblockUserPopupOpen);
  };

  var toggleReportUserPopup = function toggleReportUserPopup() {
    setReportUserPopupOpen(!reportUserPopupOpen);
  };

  var handleActionsOpen = function handleActionsOpen() {
    if (toggleable && actionMenuOpen) {
      actionMenuOpen();
    }
  };

  var handleLeaveChannel = function handleLeaveChannel() {
    dispatch(leaveChannelAC(channel.id));
  };

  var handleDeleteChannel = function handleDeleteChannel() {
    dispatch(deleteChannelAC(channel.id));
  };

  var handleBlockChannel = function handleBlockChannel() {
    dispatch(blockChannelAC(channel.id));
  };

  var handleBlockUser = function handleBlockUser() {
    dispatch(blockUserAC([channel.peer.id]));
  };

  var handleUnblockUser = function handleUnblockUser() {
    dispatch(unblockUserAC([channel.peer.id]));
  };

  var handleClearHistory = function handleClearHistory() {
    dispatch(clearHistoryAC(channel.id));
  };

  var handleDeleteAllMessagesHistory = function handleDeleteAllMessagesHistory() {
    dispatch(deleteAllMessagesAC(channel.id));
  };

  var handleNotificationOnOff = function handleNotificationOnOff(expTime) {
    console.log('exp time ... ', expTime);

    if (channel.muted) {
      dispatch(turnOnNotificationsAC());
    } else {
      dispatch(turnOffNotificationsAC(expTime));
    }
  };

  var handleToggleChannelMarkAs = function handleToggleChannelMarkAs() {
    console.log('handle action mark read ', channel.markedAsUnread);

    if (channel.markedAsUnread) {
      dispatch(markChannelAsReadAC(channel.id));
    } else {
      dispatch(markChannelAsUnReadAC(channel.id));
    }
  };

  return React__default.createElement(Container$g, {
    isDirect: isDirectChannel
  }, toggleable && React__default.createElement(ActionHeader, {
    onClick: handleActionsOpen
  }, React__default.createElement(SectionHeader, null, "ACTIONS"), React__default.createElement(MenuTriggerIcon, {
    isOpen: menuIsOpen
  }, React__default.createElement(SvgBottom, null))), React__default.createElement(ActionsMenu, {
    isOpen: menuIsOpen
  }, showMuteUnmuteNotifications && (isDirectChannel ? channel.peer.activityState !== 'Deleted' : true) && (channel.muted ? React__default.createElement(ActionItem$1, {
    key: 0,
    order: muteUnmuteNotificationsOrder,
    onClick: function onClick() {
      return handleNotificationOnOff();
    },
    iconColor: muteNotificationIconColor || colors.gray4,
    color: muteUnmuteNotificationTextColor || colors.gray6,
    hoverColor: muteUnmuteNotificationTextColor || colors.gray6
  }, React__default.createElement(React__default.Fragment, null, muteNotificationIcon || React__default.createElement(DefaultMutedIcon, null), " Unmute notifications")) : React__default.createElement(DropDown, {
    isSelect: true,
    height: 'auto',
    position: 'left',
    order: muteUnmuteNotificationsOrder,
    trigger: React__default.createElement(ActionItem$1, {
      key: 0,
      disableEvent: true,
      iconColor: unmuteNotificationIconColor || colors.gray4,
      color: muteUnmuteNotificationTextColor || colors.gray6,
      hoverColor: muteUnmuteNotificationTextColor || colors.gray6
    }, React__default.createElement(React__default.Fragment, null, unmuteNotificationIcon || React__default.createElement(SvgNotifications, null), " Mute notifications"))
  }, React__default.createElement(DropdownOptionsUl, null, timeOptionsToMuteNotifications && timeOptionsToMuteNotifications.length ? timeOptionsToMuteNotifications.map(function (value, index) {
    return React__default.createElement(DropdownOptionLi, {
      key: value + index,
      hoverBackground: customColors.selectedChannelBackground,
      onClick: function onClick() {
        return handleNotificationOnOff(value * oneHour);
      }
    }, "Mute for ", value < 24 ? value + " " + (value > 1 ? 'hours' : 'hour') + " " : '1 day');
  }) : React__default.createElement(React__default.Fragment, null, React__default.createElement(DropdownOptionLi, {
    key: 1,
    hoverBackground: customColors.selectedChannelBackground,
    onClick: function onClick() {
      return handleNotificationOnOff(oneHour);
    }
  }, "Mute for 1 hour"), React__default.createElement(DropdownOptionLi, {
    key: 2,
    hoverBackground: customColors.selectedChannelBackground,
    onClick: function onClick() {
      return handleNotificationOnOff(twoHours);
    }
  }, "Mute for 2 hours"), React__default.createElement(DropdownOptionLi, {
    key: 3,
    hoverBackground: customColors.selectedChannelBackground,
    onClick: function onClick() {
      return handleNotificationOnOff(oneDay);
    }
  }, "Mute for 1 day")), React__default.createElement(DropdownOptionLi, {
    key: 4,
    hoverBackground: customColors.selectedChannelBackground,
    onClick: function onClick() {
      return handleNotificationOnOff();
    }
  }, "Mute forever")))), showStarredMessages && React__default.createElement(ActionItem$1, {
    key: 1,
    onClick: function onClick() {
      return console.log('stared messages');
    },
    order: starredMessagesOrder,
    iconColor: staredMessagesIconColor || colors.gray4,
    color: staredMessagesTextColor || colors.gray6,
    hoverColor: staredMessagesTextColor || colors.gray6
  }, React__default.createElement(React__default.Fragment, null, staredMessagesIcon || React__default.createElement(SvgStar, null), " Starred messages ")), showPinChannel && (isDirectChannel ? channel.peer.activityState !== 'Deleted' : true) && React__default.createElement(ActionItem$1, {
    key: 2,
    onClick: function onClick() {
      return console.log('pin channel');
    },
    order: pinChannelOrder,
    iconColor: pinChannelIconColor || colors.gray4,
    color: pinChannelTextColor || colors.gray6,
    hoverColor: pinChannelTextColor || colors.gray6
  }, React__default.createElement(React__default.Fragment, null, pinChannelIcon || React__default.createElement(SvgPin, null), " Pin ", channelType)), showMarkAsReadUnread && (isDirectChannel ? channel.peer.activityState !== 'Deleted' : true) && (channel.markedAsUnread ? React__default.createElement(ActionItem$1, {
    key: 3,
    onClick: handleToggleChannelMarkAs,
    order: markAsReadUnreadOrder,
    iconColor: markAsReadIconColor || colors.gray4,
    color: markAsReadUnreadTextColor || colors.gray6,
    hoverColor: markAsReadUnreadTextColor || colors.gray6
  }, React__default.createElement(React__default.Fragment, null, markAsReadIcon || React__default.createElement(SvgMarkAsRead, null), " Mark as read")) : React__default.createElement(ActionItem$1, {
    key: 3,
    order: markAsReadUnreadOrder,
    onClick: handleToggleChannelMarkAs,
    iconColor: markAsUnreadIconColor || colors.gray4,
    color: markAsReadUnreadTextColor || colors.gray6,
    hoverColor: markAsReadUnreadTextColor || colors.gray6
  }, React__default.createElement(React__default.Fragment, null, markAsUnreadIcon || React__default.createElement(SvgMarkAsUnRead, null), " Mark as unread"))), !isDirectChannel && showLeaveChannel && React__default.createElement(ActionItem$1, {
    key: 4,
    order: leaveChannelOrder,
    color: leaveChannelTextColor || colors.red1,
    iconColor: leaveChannelIconColor || colors.red1,
    hoverColor: leaveChannelTextColor || colors.red1,
    onClick: function onClick() {
      setPopupButtonText('Leave');
      setPopupTitle("Leave " + channelType);
      handleToggleLeaveChannelPopupOpen();
    }
  }, leaveChannelIcon || React__default.createElement(SvgLeave, null), " Leave ", channelType), isDirectChannel ? React__default.createElement(React__default.Fragment, null, showBlockUser && (isDirectChannel ? channel.peer.activityState !== 'Deleted' : true) && (channel.peer.blocked ? React__default.createElement(ActionItem$1, {
    key: 5,
    color: unblockUserTextColor || colors.gray6,
    hoverColor: unblockUserTextColor || colors.gray6,
    onClick: function onClick() {
      handleUnblockUser();
    }
  }, unblockUserIcon || React__default.createElement(SvgBlockChannel, null), " Unblock user") : React__default.createElement(ActionItem$1, {
    key: 6,
    color: deleteChannelTextColor || colors.red1,
    iconColor: deleteChannelIconColor || colors.red1,
    hoverColor: deleteChannelTextColor || colors.red1,
    onClick: function onClick() {
      setPopupButtonText('Block');
      setPopupTitle('Block user');
      handleToggleBlockUserPopupOpen();
    }
  }, blockAndLeaveChannelIcon || React__default.createElement(SvgBlockChannel, null), " Block user")), showReportChannel && React__default.createElement(ActionItem$1, {
    color: deleteChannelTextColor || colors.red1,
    iconColor: deleteChannelIconColor || colors.red1,
    hoverColor: deleteChannelTextColor || colors.red1,
    key: 7,
    onClick: function onClick() {
      return toggleReportUserPopup();
    }
  }, React__default.createElement(SvgReport, null), "Report user")) : React__default.createElement(React__default.Fragment, null, showBlockAndLeaveChannel && React__default.createElement(ActionItem$1, {
    key: 8,
    color: blockAndLeaveChannelTextColor || colors.red1,
    iconColor: blockAndLeaveChannelIconColor || colors.red1,
    hoverColor: blockAndLeaveChannelTextColor || colors.red1,
    onClick: function onClick() {
      setPopupButtonText('Block');
      setPopupTitle("Block and Leave " + channelType);
      handleToggleBlockChannelPopupOpen();
    }
  }, blockAndLeaveChannelIcon || React__default.createElement(SvgBlockChannel, null), " Block and Leave ", channelType), showReportChannel && React__default.createElement(ActionItem$1, {
    key: 9,
    order: reportChannelOrder,
    color: reportChannelTextColor || colors.red1,
    iconColor: reportChannelIconColor || colors.red1,
    hoverColor: reportChannelTextColor || colors.red1,
    onClick: function onClick() {
      setPopupButtonText('Report');
      setPopupTitle('Report channel');
      console.log('Report channel');
    }
  }, reportChannelIcon || React__default.createElement(SvgReport, null), " Report", ' ', channel.type === CHANNEL_TYPE.PUBLIC ? 'channel' : channel.type === CHANNEL_TYPE.PRIVATE ? 'group' : 'chat')), (isDirectChannel && showClearHistoryForDirectChannel && channel.peer.activityState !== 'Deleted' || isPrivateChannel && showClearHistoryForPrivateChannel || isPublicChannel && showClearHistoryForPublicChannel) && checkActionPermission('deleteAllMessagesForMe') && React__default.createElement(ActionItem$1, {
    key: 10,
    color: clearHistoryTextColor || colors.red1,
    iconColor: clearHistoryTextColor || colors.red1,
    order: clearHistoryOrder,
    hoverColor: clearHistoryTextColor || colors.red1,
    onClick: function onClick() {
      setPopupButtonText('Clear');
      setPopupTitle('Clear history');
      handleToggleClearHistoryPopup();
    }
  }, clearHistoryIcon || React__default.createElement(SvgClear, null), " Clear history"), (isDirectChannel && showDeleteAllMessagesForDirectChannel || isPrivateChannel && showDeleteAllMessagesForPrivateChannel || isPublicChannel && showDeleteAllMessagesForPublicChannel) && checkActionPermission('deleteAllMessagesForAll') && React__default.createElement(ActionItem$1, {
    key: 11,
    color: deleteAllMessagesTextColor || colors.red1,
    iconColor: deleteAllMessagesTextColor || colors.red1,
    order: deleteAllMessagesOrder,
    hoverColor: deleteAllMessagesTextColor || colors.red1,
    onClick: function onClick() {
      setPopupButtonText('Clear');
      setPopupTitle("Clear history");
      handleToggleDeleteAllMessagesPopup();
    }
  }, deleteAllMessagesIcon || React__default.createElement(SvgClear, null), " Clear history"), showDeleteChannel && checkActionPermission('deleteChannel') && React__default.createElement(ActionItem$1, {
    key: 12,
    order: deleteChannelOrder,
    color: deleteChannelTextColor || colors.red1,
    iconColor: deleteChannelIconColor || colors.red1,
    hoverColor: deleteChannelTextColor || colors.red1,
    onClick: function onClick() {
      setPopupButtonText('Delete');
      setPopupTitle("Delete  " + channelType);
      handleToggleDeleteChannelPopupOpen();
    }
  }, deleteChannelIcon || React__default.createElement(SvgDeleteChannel, null), " Delete ", channelType)), leaveChannelPopupOpen && React__default.createElement(ConfirmPopup, {
    handleFunction: handleLeaveChannel,
    togglePopup: handleToggleLeaveChannelPopupOpen,
    buttonText: popupButtonText,
    description: channel.type === CHANNEL_TYPE.PRIVATE && leavePrivateChannelWarningText ? leavePrivateChannelWarningText : channel.type === CHANNEL_TYPE.PUBLIC && leavePublicChannelWarningText ? leavePublicChannelWarningText : "Are you sure you want to leave the \"" + (channel.subject || (channel.type === CHANNEL_TYPE.DIRECT ? channel.peer.firstName : '')) + "\"  channel?",
    title: popupTitle
  }), deleteChannelPopupOpen && React__default.createElement(ConfirmPopup, {
    handleFunction: handleDeleteChannel,
    togglePopup: handleToggleDeleteChannelPopupOpen,
    buttonText: popupButtonText,
    description: channel.type === CHANNEL_TYPE.DIRECT && deleteDirectChannelWarningText ? deleteDirectChannelWarningText : channel.type === CHANNEL_TYPE.PRIVATE && deletePrivateChannelWarningText ? deletePrivateChannelWarningText : channel.type === CHANNEL_TYPE.PUBLIC && deletePublicChannelWarningText ? deletePublicChannelWarningText : "Are you sure you want to delete the " + (channel.type === CHANNEL_TYPE.DIRECT ? "channel with " + channel.peer.firstName : "\"" + channel.subject + "\" channel") + " ? This action cannot be undone.",
    title: popupTitle
  }), blockChannelPopupOpen && React__default.createElement(ConfirmPopup, {
    handleFunction: handleBlockChannel,
    togglePopup: handleToggleBlockChannelPopupOpen,
    buttonText: popupButtonText,
    description: channel.type === CHANNEL_TYPE.PRIVATE && blockAndLeavePrivateChannelWarningText ? blockAndLeavePrivateChannelWarningText : channel.type === CHANNEL_TYPE.PUBLIC && blockAndLeavePublicChannelWarningText ? blockAndLeavePublicChannelWarningText : "Are you sure you want to block the \"" + (channel.subject || (channel.type === CHANNEL_TYPE.DIRECT ? channel.peer.firstName : '')) + "\"  channel?",
    title: popupTitle
  }), blockUserPopupOpen && React__default.createElement(ConfirmPopup, {
    handleFunction: handleBlockUser,
    togglePopup: handleToggleBlockUserPopupOpen,
    buttonText: popupButtonText,
    description: blockUserWarningText || "Are you sure you want to block " + (channel.type === CHANNEL_TYPE.DIRECT ? channel.peer.firstName : '') + " ?",
    title: popupTitle
  }), unblockUserPopupOpen && React__default.createElement(ConfirmPopup, {
    handleFunction: handleUnblockUser,
    togglePopup: handleToggleUnblockUserPopupOpen,
    buttonText: popupButtonText,
    description: 'Are you sure you want to unblock?',
    title: popupTitle
  }), clearHistoryPopupOpen && React__default.createElement(ConfirmPopup, {
    handleFunction: handleClearHistory,
    togglePopup: handleToggleClearHistoryPopup,
    buttonText: popupButtonText,
    description: channel.type === CHANNEL_TYPE.DIRECT && clearHistoryDirectChannelWarningText ? clearHistoryDirectChannelWarningText : channel.type === CHANNEL_TYPE.PRIVATE && clearHistoryPrivateChannelWarningText ? clearHistoryPrivateChannelWarningText : channel.type === CHANNEL_TYPE.PUBLIC && clearHistoryPublicChannelWarningText ? clearHistoryPublicChannelWarningText : 'Are you sure you want to clear history? This action cannot be undone.',
    title: popupTitle
  }), deleteAllMessagesPopupOpen && React__default.createElement(ConfirmPopup, {
    handleFunction: handleDeleteAllMessagesHistory,
    togglePopup: handleToggleDeleteAllMessagesPopup,
    buttonText: popupButtonText,
    description: channel.type === CHANNEL_TYPE.DIRECT && clearHistoryDirectChannelWarningText ? clearHistoryDirectChannelWarningText : channel.type === CHANNEL_TYPE.PRIVATE && clearHistoryPrivateChannelWarningText ? clearHistoryPrivateChannelWarningText : channel.type === CHANNEL_TYPE.PUBLIC && clearHistoryPublicChannelWarningText ? clearHistoryPublicChannelWarningText : 'Are you sure you want to delete all messages? This action cannot be undone.',
    title: popupTitle
  }));
};
var Container$g = styled.div(_templateObject$w || (_templateObject$w = _taggedTemplateLiteralLoose(["\n  padding: 10px 16px;\n  border-top: 0.5px solid ", ";\n  border-bottom: 6px solid ", ";\n  /*", "*/\n"])), colors.gray1, colors.gray0, function (props) {
  return !props.isDirect && "border-bottom: 6px solid " + colors.gray0;
});
var ActionHeader = styled.div(_templateObject2$u || (_templateObject2$u = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  margin: 25px 0 22px;\n  cursor: pointer;\n"])));
var MenuTriggerIcon = styled.span(_templateObject3$o || (_templateObject3$o = _taggedTemplateLiteralLoose(["\n  transition: all 0.2s;\n  ", "\n"])), function (props) {
  return !props.isOpen && ' transform: rotate(-90deg);';
});
var ActionsMenu = styled.ul(_templateObject4$l || (_templateObject4$l = _taggedTemplateLiteralLoose(["\n  display: flex;\n  flex-direction: column;\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  transition: all 0.2s;\n"])));
var DefaultMutedIcon = styled(SvgNotificationsOff2)(_templateObject5$h || (_templateObject5$h = _taggedTemplateLiteralLoose([""])));
var ActionItem$1 = styled.li(_templateObject6$g || (_templateObject6$g = _taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  align-items: center;\n  padding: 10px 0;\n  font-size: 15px;\n  height: 20px;\n  color: ", ";\n  cursor: pointer;\n  order: ", ";\n  pointer-events: ", ";\n\n  & > div {\n    margin-left: auto;\n  }\n\n  & > svg {\n    margin-right: 16px;\n    color: ", ";\n  }\n\n  & > ", " {\n    margin-right: 12px;\n    margin-left: 2px;\n  }\n\n  &:hover {\n    color: ", ";\n  }\n\n  &:last-child {\n    //margin-bottom: 0;\n  }\n"])), function (props) {
  return props.color || colors.blue6;
}, function (props) {
  return props.order;
}, function (props) {
  return props.disableEvent && 'none';
}, function (props) {
  return props.iconColor || colors.gray4;
}, DefaultMutedIcon, function (props) {
  return props.hoverColor || colors.blue2;
});

var _rect$1, _rect2, _path$1a;

function _extends$1d() {
  _extends$1d = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1d.apply(this, arguments);
}

function SvgAddMember(props) {
  return /*#__PURE__*/createElement("svg", _extends$1d({
    width: 40,
    height: 40,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _rect$1 || (_rect$1 = /*#__PURE__*/createElement("rect", {
    width: 40,
    height: 40,
    rx: 20,
    fill: "#F3F5F7"
  })), _rect2 || (_rect2 = /*#__PURE__*/createElement("rect", {
    x: 0.25,
    y: 0.25,
    width: 39.5,
    height: 39.5,
    rx: 19.75,
    stroke: "#000",
    strokeOpacity: 0.08,
    strokeWidth: 0.5
  })), _path$1a || (_path$1a = /*#__PURE__*/createElement("path", {
    d: "M20 12a1 1 0 011 1v6h6a1 1 0 110 2h-6v6a1 1 0 11-2 0l-.001-6H13a1 1 0 110-2h5.999L19 13a1 1 0 011-1z",
    fill: "CurrentColor"
  })));
}

var _path$1b;

function _extends$1e() {
  _extends$1e = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1e.apply(this, arguments);
}

function SvgMoreVert(props) {
  return /*#__PURE__*/createElement("svg", _extends$1e({
    width: 4,
    height: 14,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$1b || (_path$1b = /*#__PURE__*/createElement("path", {
    d: "M.532 11.012c.355-.355.764-.533 1.228-.533.464 0 .874.178 1.228.533.355.354.532.764.532 1.228 0 .464-.177.873-.532 1.228-.354.355-.764.532-1.228.532-.464 0-.873-.177-1.228-.532C.177 13.113 0 12.704 0 12.24c0-.464.177-.873.532-1.228zm0-5.24c.355-.355.764-.532 1.228-.532.464 0 .874.177 1.228.532.355.355.532.764.532 1.228 0 .464-.177.873-.532 1.228-.354.355-.764.532-1.228.532-.464 0-.873-.177-1.228-.532C.177 7.873 0 7.464 0 7c0-.464.177-.873.532-1.228zm2.456-2.784c-.354.355-.764.532-1.228.532-.464 0-.873-.177-1.228-.532C.177 2.634 0 2.224 0 1.76 0 1.296.177.887.532.532.887.177 1.296 0 1.76 0c.464 0 .874.177 1.228.532.355.355.532.764.532 1.228 0 .464-.177.874-.532 1.228z",
    fill: "#9B9DA8"
  })));
}

var _templateObject$x, _templateObject2$v, _templateObject3$p;

var ChangeMemberRole = function ChangeMemberRole(_ref) {
  var channelId = _ref.channelId,
      member = _ref.member,
      handleClosePopup = _ref.handleClosePopup;
  var dispatch = useDispatch();

  var _useState = useState(false),
      isChanged = _useState[0],
      setIsChanged = _useState[1];

  var _useState2 = useState(),
      selectedRole = _useState2[0],
      setSelectedRole = _useState2[1];

  var roles = useSelector(rolesSelector, shallowEqual) || [];
  useEffect(function () {
    dispatch(getRolesAC$1());
  }, []);

  var handleSave = function handleSave() {
    if (isChanged && selectedRole) {
      var updateMember = _extends({}, member, {
        role: selectedRole
      });

      dispatch(changeMemberRoleAC(channelId, [updateMember]));
    }

    handleClosePopup();
  };

  function onChangeFunction(roleName) {
    if (member.role !== roleName) {
      setIsChanged(true);
    }

    setSelectedRole(roleName);
  }

  return React__default.createElement(PopupContainer, null, React__default.createElement(Popup, {
    maxWidth: '400px',
    padding: '0'
  }, React__default.createElement(PopupBody, {
    padding: 24
  }, React__default.createElement(CloseIcon, {
    onClick: function onClick() {
      return handleClosePopup();
    }
  }), React__default.createElement(PopupName, null, "Change member role"), React__default.createElement(RolesSelect, null, React__default.createElement(RoleLabel, null, "Roles"), React__default.createElement(CustomSelect, null, React__default.createElement(DropDown, {
    withIcon: true,
    isSelect: true,
    trigger: React__default.createElement(CustomSelectTrigger, null, selectedRole || member.role || 'Select')
  }, React__default.createElement(DropdownOptionsUl, null, !!roles.length && roles.map(function (role) {
    return React__default.createElement(DropdownOptionLi, {
      hoverBackground: customColors.selectedChannelBackground,
      key: role.name,
      onClick: function onClick() {
        return onChangeFunction(role.name);
      }
    }, React__default.createElement(RoleSpan, null, role.name));
  })))))), React__default.createElement(PopupFooter, {
    backgroundColor: colors.gray5
  }, React__default.createElement(Button, {
    type: 'button',
    color: colors.gray6,
    backgroundColor: 'transparent',
    onClick: function onClick() {
      return handleClosePopup();
    }
  }, "Cancel"), React__default.createElement(Button, {
    type: 'button',
    backgroundColor: colors.primary,
    borderRadius: '8px',
    onClick: handleSave
  }, "Save"))));
};

var RolesSelect = styled.div(_templateObject$x || (_templateObject$x = _taggedTemplateLiteralLoose(["\n  margin-bottom: 32px;\n"])));
var RoleLabel = styled.div(_templateObject2$v || (_templateObject2$v = _taggedTemplateLiteralLoose(["\n  font-style: normal;\n  font-weight: 500;\n  font-size: 14px;\n  margin: 20px 0 8px;\n  color: #1f233c;\n"])));
var RoleSpan = styled.span(_templateObject3$p || (_templateObject3$p = _taggedTemplateLiteralLoose(["\n  font-style: normal;\n  font-weight: normal;\n  font-size: 14px;\n  color: #383b51;\n  text-transform: capitalize;\n"])));

var _templateObject$y, _templateObject2$w, _templateObject3$q, _templateObject4$m, _templateObject5$i, _templateObject6$h, _templateObject7$e, _templateObject8$c;

var Members = function Members(_ref) {
  var channel = _ref.channel,
      chekActionPermission = _ref.chekActionPermission,
      publicChannelDeleteMemberPopupDescription = _ref.publicChannelDeleteMemberPopupDescription,
      privateChannelDeleteMemberPopupDescription = _ref.privateChannelDeleteMemberPopupDescription,
      publicChannelRevokeAdminPopupDescription = _ref.publicChannelRevokeAdminPopupDescription,
      privateChannelRevokeAdminPopupDescription = _ref.privateChannelRevokeAdminPopupDescription,
      publicChannelMakeAdminPopupDescription = _ref.publicChannelMakeAdminPopupDescription,
      privateChannelMakeAdminPopupDescription = _ref.privateChannelMakeAdminPopupDescription,
      _ref$showChangeMember = _ref.showChangeMemberRole,
      showChangeMemberRole = _ref$showChangeMember === void 0 ? true : _ref$showChangeMember,
      _ref$showMakeMemberAd = _ref.showMakeMemberAdmin,
      showMakeMemberAdmin = _ref$showMakeMemberAd === void 0 ? true : _ref$showMakeMemberAd,
      _ref$showKickMember = _ref.showKickMember,
      showKickMember = _ref$showKickMember === void 0 ? true : _ref$showKickMember,
      _ref$showKickAndBlock = _ref.showKickAndBlockMember,
      showKickAndBlockMember = _ref$showKickAndBlock === void 0 ? true : _ref$showKickAndBlock;
  var getFromContacts = getShowOnlyContactUsers();

  var _useState = useState(null),
      selectedMember = _useState[0],
      setSelectedMember = _useState[1];

  var _useState2 = useState(false),
      kickMemberPopupOpen = _useState2[0],
      setKickMemberPopupOpen = _useState2[1];

  var _useState3 = useState(false),
      blockMemberPopupOpen = _useState3[0],
      setBlockMemberPopupOpen = _useState3[1];

  var _useState4 = useState(false),
      changeMemberRolePopup = _useState4[0],
      setChangeMemberRolePopup = _useState4[1];

  var _useState5 = useState(false),
      makeAdminPopup = _useState5[0],
      setMakeAdminPopup = _useState5[1];

  var _useState6 = useState(false),
      revokeAdminPopup = _useState6[0],
      setRevokeAdminPopup = _useState6[1];

  var _useState7 = useState(false),
      addMemberPopupOpen = _useState7[0],
      setAddMemberPopupOpen = _useState7[1];

  var _useState8 = useState(),
      closeMenu = _useState8[0],
      setCloseMenu = _useState8[1];

  var members = useSelector(activeChannelMembersSelector) || [];
  var contactsMap = useSelector(contactsMapSelector) || {};
  var membersLoading = useSelector(membersLoadingStateSelector) || {};
  var user = getClient().chatClient.user;
  var dispatch = useDispatch();
  var noMemberEditPermissions = !chekActionPermission('changeMemberRole') && !chekActionPermission('kickAndBlockMember') && !chekActionPermission('kickMember');

  var handleMembersListScroll = function handleMembersListScroll(event) {
    if (event.target.scrollTop >= event.target.scrollHeight - event.target.offsetHeight - 100) {
      if (membersLoading === LOADING_STATE.LOADED) {
        dispatch(loadMoreMembersAC(15));
      }
    }
  };

  var watchDropdownState = function watchDropdownState(state, memberId) {
    if (state) {
      setCloseMenu(memberId);
    }
  };

  var toggleKickMemberPopup = function toggleKickMemberPopup() {
    if (kickMemberPopupOpen) {
      setSelectedMember(null);
    }

    setKickMemberPopupOpen(!kickMemberPopupOpen);
  };

  var toggleBlockMemberPopup = function toggleBlockMemberPopup() {
    if (blockMemberPopupOpen) {
      setSelectedMember(null);
    }

    setBlockMemberPopupOpen(!blockMemberPopupOpen);
  };

  var toggleChangeRolePopup = function toggleChangeRolePopup() {
    if (changeMemberRolePopup) {
      setSelectedMember(null);
    }

    setChangeMemberRolePopup(!changeMemberRolePopup);
  };

  var toggleMakeAdminPopup = function toggleMakeAdminPopup(revoke) {
    if (revoke) {
      if (revokeAdminPopup) {
        setSelectedMember(null);
      }

      setRevokeAdminPopup(!revokeAdminPopup);
    } else {
      if (makeAdminPopup) {
        setSelectedMember(null);
      }

      setMakeAdminPopup(!makeAdminPopup);
    }
  };

  console.log('render members ********************************* ');

  var handleKickMember = function handleKickMember() {
    selectedMember && dispatch(kickMemberAC(channel.id, selectedMember.id));
  };

  var handleBlockMember = function handleBlockMember() {
    selectedMember && dispatch(blockMemberAC(channel.id, selectedMember.id));
  };

  var handleMakeAdmin = function handleMakeAdmin() {
    if (selectedMember) {
      var updateMember = _extends({}, selectedMember, {
        role: 'admin'
      });

      dispatch(changeMemberRoleAC(channel.id, [updateMember]));
    }
  };

  var handleRevokeAdmin = function handleRevokeAdmin() {
    if (selectedMember) {
      var updateMember = _extends({}, selectedMember, {
        role: 'subscriber'
      });

      dispatch(changeMemberRoleAC(channel.id, [updateMember]));
    }
  };

  var handleAddMemberPopup = function handleAddMemberPopup() {
    setAddMemberPopupOpen(!addMemberPopupOpen);
  };

  useEffect(function () {
    dispatch(getContactsAC());
    dispatch(getMembersAC(channel.id));
  }, [channel]);
  return React__default.createElement(Container$h, null, React__default.createElement(ActionsMenu$1, null, React__default.createElement(MembersList$1, {
    onScroll: handleMembersListScroll
  }, chekActionPermission('addMember') && React__default.createElement(MemberItem$1, {
    key: 1,
    onClick: handleAddMemberPopup,
    addMemberIconColor: colors.primary
  }, React__default.createElement(SvgAddMember, null), (channel === null || channel === void 0 ? void 0 : channel.type) === CHANNEL_TYPE.PUBLIC ? 'Add subscribers' : 'Add members'), !!members.length && members.map(function (member, index) {
    return React__default.createElement(MemberItem$1, {
      key: member.id + index,
      hoverBackground: customColors.selectedChannelBackground
    }, React__default.createElement(Avatar, {
      name: member.firstName || member.id,
      image: member.avatarUrl,
      size: 40,
      textSize: 14,
      setDefaultAvatar: true
    }), React__default.createElement(MemberNamePresence, null, React__default.createElement(MemberName$2, null, member.id === user.id ? 'You' : makeUserName(member.id === user.id ? member : contactsMap[member.id], member, getFromContacts), member.role === 'owner' ? React__default.createElement(RoleBadge, {
      color: colors.primary
    }, "Owner") : member.role === 'admin' ? React__default.createElement(RoleBadge, {
      color: colors.purple
    }, "Admin") : ''), React__default.createElement(SubTitle, null, member.presence && member.presence.state === PRESENCE_STATUS.ONLINE ? 'Online' : member.presence && member.presence.lastActiveAt && userLastActiveDateFormat(member.presence.lastActiveAt))), !noMemberEditPermissions && member.role !== 'owner' && React__default.createElement(DropDown, {
      isSelect: true,
      forceClose: !!(closeMenu && closeMenu !== member.id),
      watchToggleState: function watchToggleState(state) {
        return watchDropdownState(state, member.id);
      },
      trigger: React__default.createElement(EditMemberIcon$1, null, React__default.createElement(SvgMoreVert, null))
    }, React__default.createElement(DropdownOptionsUl, null, showChangeMemberRole && chekActionPermission('changeMemberRole') && React__default.createElement(DropdownOptionLi, {
      onClick: function onClick() {
        setSelectedMember(member);
        toggleChangeRolePopup();
      },
      key: 1,
      hoverBackground: customColors.selectedChannelBackground
    }, "Change role"), showMakeMemberAdmin && chekActionPermission('changeMemberRole') && member.role !== 'owner' && React__default.createElement(DropdownOptionLi, {
      onClick: function onClick() {
        setSelectedMember(member);
        toggleMakeAdminPopup(member.role === 'admin');
      },
      textColor: member.role === 'admin' ? colors.red1 : '',
      key: 2,
      hoverBackground: customColors.selectedChannelBackground
    }, member.role === 'admin' ? 'Revoke Admin' : 'Make Admin'), showKickMember && chekActionPermission('kickMember') && member.role !== 'owner' && React__default.createElement(DropdownOptionLi, {
      onClick: function onClick() {
        setSelectedMember(member);
        toggleKickMemberPopup();
      },
      textColor: colors.red1,
      key: 3,
      hoverBackground: customColors.selectedChannelBackground
    }, "Remove"), showKickAndBlockMember && chekActionPermission('kickAndBlockMember') && React__default.createElement(DropdownOptionLi, {
      textColor: colors.red1,
      key: 4,
      hoverBackground: customColors.selectedChannelBackground,
      onClick: function onClick() {
        setSelectedMember(member);
        toggleBlockMemberPopup();
      }
    }, "Remove and Block member"))));
  }))), kickMemberPopupOpen && React__default.createElement(ConfirmPopup, {
    handleFunction: handleKickMember,
    togglePopup: toggleKickMemberPopup,
    buttonText: 'Remove',
    title: channel.type === CHANNEL_TYPE.PRIVATE ? 'Remove member' : 'Remove subscriber',
    description: privateChannelDeleteMemberPopupDescription && channel.type === CHANNEL_TYPE.PRIVATE ? privateChannelDeleteMemberPopupDescription : publicChannelDeleteMemberPopupDescription && channel.type === CHANNEL_TYPE.PUBLIC ? publicChannelDeleteMemberPopupDescription : React__default.createElement("span", null, "Are you sure to remove", !!selectedMember && React__default.createElement(BoltText, null, " ", makeUserName(contactsMap[selectedMember.id], selectedMember, getFromContacts), " "), "from this ", channel.type === CHANNEL_TYPE.PUBLIC ? 'channel' : 'group', "?")
  }), blockMemberPopupOpen && React__default.createElement(ConfirmPopup, {
    handleFunction: handleBlockMember,
    togglePopup: toggleBlockMemberPopup,
    buttonText: 'Block',
    description: "Block and remove member - " + (selectedMember && (selectedMember.firstName || selectedMember.lastName || selectedMember.id)),
    title: 'Block and remove user'
  }), makeAdminPopup && React__default.createElement(ConfirmPopup, {
    handleFunction: handleMakeAdmin,
    togglePopup: function togglePopup() {
      return toggleMakeAdminPopup(false);
    },
    buttonText: 'Promote',
    buttonBackground: colors.primary,
    title: 'Promote admin',
    description: privateChannelMakeAdminPopupDescription && channel.type === CHANNEL_TYPE.PRIVATE ? privateChannelMakeAdminPopupDescription : publicChannelMakeAdminPopupDescription && channel.type === CHANNEL_TYPE.PUBLIC ? publicChannelMakeAdminPopupDescription : React__default.createElement("span", null, "Are you sure you want to promote", selectedMember && React__default.createElement(BoltText, null, " ", makeUserName(contactsMap[selectedMember.id], selectedMember, getFromContacts), " "), "to ", React__default.createElement(BoltText, null, "Admin?"))
  }), revokeAdminPopup && React__default.createElement(ConfirmPopup, {
    handleFunction: handleRevokeAdmin,
    togglePopup: function togglePopup() {
      return toggleMakeAdminPopup(true);
    },
    buttonText: 'Revoke',
    title: 'Revoke admin',
    description: privateChannelRevokeAdminPopupDescription && channel.type === CHANNEL_TYPE.PRIVATE ? privateChannelRevokeAdminPopupDescription : publicChannelRevokeAdminPopupDescription && channel.type === CHANNEL_TYPE.PUBLIC ? publicChannelRevokeAdminPopupDescription : React__default.createElement("span", null, "Are you sure you want to revoke", React__default.createElement(BoltText, null, " \u201CAdmin\u201D "), "rights from user:", selectedMember && React__default.createElement(BoltText, null, " ", makeUserName(contactsMap[selectedMember.id], selectedMember, getFromContacts), " "), "?")
  }), changeMemberRolePopup && React__default.createElement(ChangeMemberRole, {
    channelId: channel.id,
    member: selectedMember,
    handleClosePopup: toggleChangeRolePopup
  }), addMemberPopupOpen && React__default.createElement(UsersPopup, {
    popupHeight: '540px',
    popupWidth: '520px',
    actionType: 'addMembers',
    channel: channel,
    selectIsRequired: true,
    memberIds: members.map(function (mem) {
      return mem.id;
    }),
    toggleCreatePopup: handleAddMemberPopup
  }));
};
var Container$h = styled.div(_templateObject$y || (_templateObject$y = _taggedTemplateLiteralLoose([""])));
var ActionsMenu$1 = styled.div(_templateObject2$w || (_templateObject2$w = _taggedTemplateLiteralLoose(["\n  position: relative;\n  transition: all 0.2s;\n"])));
var MemberNamePresence = styled.div(_templateObject3$q || (_templateObject3$q = _taggedTemplateLiteralLoose(["\n  margin-left: 12px;\n  max-width: calc(100% - 64px);\n"])));
var MemberName$2 = styled.h4(_templateObject4$m || (_templateObject4$m = _taggedTemplateLiteralLoose(["\n  margin: 0;\n  width: 100%;\n  font-weight: 400;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  color: ", ";\n"])), colors.gray6);
var EditMemberIcon$1 = styled.span(_templateObject5$i || (_templateObject5$i = _taggedTemplateLiteralLoose(["\n  margin-left: auto;\n  cursor: pointer;\n  padding: 2px;\n  opacity: 0;\n  visibility: hidden;\n  transition: all 0.2s;\n"])));
var MembersList$1 = styled.ul(_templateObject6$h || (_templateObject6$h = _taggedTemplateLiteralLoose(["\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  transition: all 0.2s;\n"])));
var MemberItem$1 = styled.li(_templateObject7$e || (_templateObject7$e = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  font-size: 15px;\n  padding: 6px 16px;\n  transition: all 0.2s;\n\n  &:first-child {\n    color: ", ";\n    cursor: pointer;\n    background-color: #fff;\n\n    > svg {\n      color: ", ";\n      margin-right: 12px;\n    }\n  }\n\n  &:hover {\n    background-color: ", ";\n  }\n\n  &:hover ", " {\n    opacity: 1;\n    visibility: visible;\n  }\n\n  & .dropdown-wrapper {\n    margin-left: auto;\n  }\n\n  & ", " {\n    width: 12px;\n    height: 12px;\n    right: -1px;\n    bottom: -1px;\n  }\n"])), colors.gray6, function (props) {
  return props.addMemberIconColor || colors.primary;
}, function (props) {
  return props.hoverBackground || colors.gray0;
}, EditMemberIcon$1, UserStatus);
var RoleBadge = styled.span(_templateObject8$c || (_templateObject8$c = _taggedTemplateLiteralLoose(["\n  position: relative;\n  padding: 2px 8px;\n  border-radius: 12px;\n  margin-left: 4px;\n  font-weight: 500;\n  font-size: 12px;\n  line-height: 16px;\n  color: ", ";\n\n  &::after {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    border-radius: 12px;\n    width: 100%;\n    height: 100%;\n    background-color: ", ";\n    opacity: 0.1;\n  }\n"])), function (props) {
  return props.color;
}, function (props) {
  return props.color || colors.primary;
});

var _templateObject$z, _templateObject2$x;

var Media = function Media(_ref) {
  var channelId = _ref.channelId;
  var attachments = useSelector(activeTabAttachmentsSelector, shallowEqual) || [];

  var _useState = useState(null),
      mediaFile = _useState[0],
      setMediaFile = _useState[1];

  var dispatch = useDispatch();

  var handleMediaItemClick = function handleMediaItemClick(file) {
    setMediaFile(file);
  };

  useEffect(function () {
    dispatch(getAttachmentsAC(channelId, channelDetailsTabs.media));
  }, [channelId]);
  return React__default.createElement(Container$i, null, attachments.map(function (file) {
    return React__default.createElement(MediaItem, {
      key: file.url,
      onClick: function onClick() {
        return handleMediaItemClick(file);
      }
    }, file.type === 'image' ? React__default.createElement(Attachment, {
      attachment: file,
      backgroundColor: colors.white,
      borderRadius: '8px',
      isDetailsView: true
    }) : React__default.createElement(Attachment, {
      attachment: file,
      backgroundColor: colors.white,
      borderRadius: '8px',
      isDetailsView: true
    }));
  }), mediaFile && React__default.createElement(SliderPopup, {
    channelId: channelId,
    setIsSliderOpen: setMediaFile,
    mediaFiles: attachments,
    currentMediaFile: mediaFile
  }));
};
var Container$i = styled.div(_templateObject$z || (_templateObject$z = _taggedTemplateLiteralLoose(["\n  padding: 6px 4px;\n  overflow-x: hidden;\n  overflow-y: auto;\n  list-style: none;\n  transition: all 0.2s;\n  align-items: flex-start;\n  display: flex;\n  flex-wrap: wrap;\n"])));
var MediaItem = styled.div(_templateObject2$x || (_templateObject2$x = _taggedTemplateLiteralLoose(["\n  width: calc(33.3333% - 4px);\n  height: 110px;\n  box-sizing: border-box;\n  //border: 1px solid #ccc;\n  border: 0.5px solid rgba(0, 0, 0, 0.1);\n  border-radius: 8px;\n  overflow: hidden;\n  margin: 2px;\n"])));

var _path$1c, _path2$8, _path3$4;

function _extends$1f() {
  _extends$1f = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1f.apply(this, arguments);
}

function SvgFileIcon$1(props) {
  return /*#__PURE__*/createElement("svg", _extends$1f({
    width: 28,
    height: 28,
    viewBox: "0 0 30 30",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$1c || (_path$1c = /*#__PURE__*/createElement("path", {
    d: "M16.25 2.5H7.5A2.5 2.5 0 005 5v20a2.5 2.5 0 002.5 2.5h15A2.5 2.5 0 0025 25V11.25L16.25 2.5z",
    stroke: "#2F81FF",
    strokeWidth: 1.4,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), _path2$8 || (_path2$8 = /*#__PURE__*/createElement("path", {
    d: "M16.25 2.5v8.75H25",
    stroke: "#2F81FF",
    strokeWidth: 1.4,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), _path3$4 || (_path3$4 = /*#__PURE__*/createElement("path", {
    d: "M10 15.834h10M10 19.166h6.667",
    stroke: "#2F81FF",
    strokeWidth: 1.4,
    strokeLinecap: "round"
  })));
}

var _path$1d, _path2$9;

function _extends$1g() {
  _extends$1g = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1g.apply(this, arguments);
}

function SvgDownloadFile(props) {
  return /*#__PURE__*/createElement("svg", _extends$1g({
    width: 18,
    height: 18,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$1d || (_path$1d = /*#__PURE__*/createElement("path", {
    d: "M16.5 11.5v3.333a1.666 1.666 0 01-1.667 1.667H3.167A1.667 1.667 0 011.5 14.833V11.5",
    stroke: "#2F81FF",
    strokeWidth: 1.4,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })), _path2$9 || (_path2$9 = /*#__PURE__*/createElement("path", {
    d: "M4.833 7.334L9 11.501l4.167-4.167M9 11.5v-10",
    stroke: "#2F81FF",
    strokeWidth: 1.4,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })));
}

var _templateObject$A, _templateObject2$y, _templateObject3$r, _templateObject4$n, _templateObject5$j, _templateObject6$i, _templateObject7$f;

var Files = function Files(_ref) {
  var channelId = _ref.channelId,
      filePreviewIcon = _ref.filePreviewIcon,
      filePreviewHoverIcon = _ref.filePreviewHoverIcon,
      filePreviewTitleColor = _ref.filePreviewTitleColor,
      filePreviewSizeColor = _ref.filePreviewSizeColor,
      filePreviewHoverBackgroundColor = _ref.filePreviewHoverBackgroundColor,
      filePreviewDownloadIcon = _ref.filePreviewDownloadIcon;
  var dispatch = useDispatch();
  var attachments = useSelector(activeTabAttachmentsSelector, shallowEqual) || [];
  useEffect(function () {
    dispatch(getAttachmentsAC(channelId, channelDetailsTabs.file));
  }, [channelId]);
  return React__default.createElement(Container$j, null, attachments.map(function (file) {
    return React__default.createElement(FileItem, {
      key: file.url,
      hoverBackgroundColor: filePreviewHoverBackgroundColor
    }, file.metadata && file.metadata.tmb ? React__default.createElement(FileThumb, {
      draggable: false,
      src: "data:image/jpeg;base64," + file.metadata.tmb
    }) : React__default.createElement(React__default.Fragment, null, React__default.createElement(FileIconCont, null, filePreviewIcon || React__default.createElement(SvgFileIcon$1, null)), React__default.createElement(FileHoverIconCont, null, filePreviewHoverIcon || React__default.createElement(SvgFileIcon$1, null))), React__default.createElement("div", null, React__default.createElement(AttachmentPreviewTitle, {
      color: filePreviewTitleColor
    }, formatLargeText(file.name, 32)), React__default.createElement(FileSizeAndDate, {
      color: filePreviewSizeColor
    }, bytesToSize(file.fileSize))), React__default.createElement(DownloadWrapper, {
      onClick: function onClick() {
        return downloadFile(file);
      }
    }, filePreviewDownloadIcon || React__default.createElement(SvgDownloadFile, null)));
  }));
};
var Container$j = styled.ul(_templateObject$A || (_templateObject$A = _taggedTemplateLiteralLoose(["\n  margin: 0;\n  padding: 0;\n  overflow-x: hidden;\n  overflow-y: auto;\n  list-style: none;\n  transition: all 0.2s;\n"])));
var DownloadWrapper = styled.a(_templateObject2$y || (_templateObject2$y = _taggedTemplateLiteralLoose(["\n  text-decoration: none;\n  visibility: hidden;\n  padding: 5px 6px;\n  position: absolute;\n  top: 25%;\n  right: 16px;\n  cursor: pointer;\n"])));
var FileIconCont = styled.span(_templateObject3$r || (_templateObject3$r = _taggedTemplateLiteralLoose(["\n  display: inline-flex;\n\n  & > svg {\n    width: 40px;\n    height: 40px;\n  }\n"])));
var FileHoverIconCont = styled.span(_templateObject4$n || (_templateObject4$n = _taggedTemplateLiteralLoose(["\n  display: none;\n  & > svg {\n    width: 40px;\n    height: 40px;\n  }\n"])));
var FileThumb = styled.img(_templateObject5$j || (_templateObject5$j = _taggedTemplateLiteralLoose(["\n  width: 40px;\n  height: 40px;\n  border: 0.5px solid rgba(0, 0, 0, 0.1);\n  border-radius: 8px;\n  object-fit: cover;\n"])));
var FileItem = styled.div(_templateObject6$i || (_templateObject6$i = _taggedTemplateLiteralLoose(["\n  position: relative;\n  padding: 11px 16px;\n  display: flex;\n  align-items: center;\n  font-size: 15px;\n  transition: all 0.2s;\n  div {\n    margin-left: 7px;\n    width: calc(100% - 48px);\n  }\n  &:hover {\n    background-color: ", ";\n    ", " {\n      visibility: visible;\n    }\n    & ", " {\n      display: none;\n    }\n    & ", " {\n      display: inline-flex;\n    }\n  }\n  /*&.isHover {\n\n  }*/\n"])), function (props) {
  return props.hoverBackgroundColor || colors.gray0;
}, DownloadWrapper, FileIconCont, FileHoverIconCont);
var FileSizeAndDate = styled.span(_templateObject7$f || (_templateObject7$f = _taggedTemplateLiteralLoose(["\n  display: block;\n  font-style: normal;\n  font-weight: normal;\n  font-size: 13px;\n  line-height: 16px;\n  color: ", ";\n  margin-top: 2px;\n"])), function (props) {
  return props.color || colors.gray6;
});

var _rect$2, _rect2$1, _g$3, _defs;

function _extends$1h() {
  _extends$1h = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1h.apply(this, arguments);
}

function SvgLinkIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$1h({
    width: 42,
    height: 42,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _rect$2 || (_rect$2 = /*#__PURE__*/createElement("rect", {
    width: 42,
    height: 42,
    rx: 6,
    fill: "#E3E7FF"
  })), _rect2$1 || (_rect2$1 = /*#__PURE__*/createElement("rect", {
    x: 0.25,
    y: 0.25,
    width: 41.5,
    height: 41.5,
    rx: 5.75,
    stroke: "#000",
    strokeOpacity: 0.1,
    strokeWidth: 0.5
  })), _g$3 || (_g$3 = /*#__PURE__*/createElement("g", {
    clipPath: "url(#linkIcon_svg__clip0)"
  }, /*#__PURE__*/createElement("path", {
    d: "M20.314 20.973a.984.984 0 11-1.754.895 3.939 3.939 0 01.724-4.574l2.088-2.088a3.938 3.938 0 115.569 5.569.984.984 0 01-1.392-1.393 1.969 1.969 0 00-2.785-2.784l-2.088 2.088a1.97 1.97 0 00-.362 2.287zm1.522.198a.984.984 0 111.754-.895 3.939 3.939 0 01-.724 4.574l-2.089 2.088a3.938 3.938 0 01-5.568-5.569.984.984 0 011.392 1.392 1.969 1.969 0 002.784 2.785l2.088-2.089a1.97 1.97 0 00.363-2.286z",
    fill: "#95A6FF"
  }))), _defs || (_defs = /*#__PURE__*/createElement("defs", null, /*#__PURE__*/createElement("clipPath", {
    id: "linkIcon_svg__clip0"
  }, /*#__PURE__*/createElement("path", {
    fill: "#fff",
    transform: "translate(13.125 13.125)",
    d: "M0 0h15.75v15.75H0z"
  })))));
}

var _templateObject$B, _templateObject2$z, _templateObject3$s, _templateObject4$o, _templateObject5$k;

var LinkItem = function LinkItem(_ref) {
  var link = _ref.link,
      linkPreviewIcon = _ref.linkPreviewIcon,
      linkPreviewHoverIcon = _ref.linkPreviewHoverIcon,
      linkPreviewColor = _ref.linkPreviewColor,
      linkPreviewHoverBackgroundColor = _ref.linkPreviewHoverBackgroundColor;
  return React__default.createElement(FileItem$1, {
    draggable: false,
    hoverBackgroundColor: linkPreviewHoverBackgroundColor
  }, React__default.createElement("a", {
    draggable: false,
    href: link,
    target: '_blank',
    rel: 'noreferrer'
  }, React__default.createElement(React__default.Fragment, null, React__default.createElement(LinkIconCont, null, linkPreviewIcon || React__default.createElement(SvgLinkIcon, null)), React__default.createElement(LinkHoverIconCont, null, linkPreviewHoverIcon || React__default.createElement(SvgLinkIcon, null))), React__default.createElement(LinkInfoCont, null, React__default.createElement(LinkUrl, {
    color: linkPreviewColor
  }, link))));
};
var LinkIconCont = styled.span(_templateObject$B || (_templateObject$B = _taggedTemplateLiteralLoose(["\n  display: inline-flex;\n"])));
var LinkHoverIconCont = styled.span(_templateObject2$z || (_templateObject2$z = _taggedTemplateLiteralLoose(["\n  display: none;\n"])));
var LinkInfoCont = styled.div(_templateObject3$s || (_templateObject3$s = _taggedTemplateLiteralLoose(["\n  margin-left: 12px;\n  width: calc(100% - 40px);\n"])));
var FileItem$1 = styled.li(_templateObject4$o || (_templateObject4$o = _taggedTemplateLiteralLoose(["\n  padding: 9px 16px;\n  a {\n    display: flex;\n    align-items: center;\n    text-decoration: none;\n  }\n  &:hover {\n    background-color: ", ";\n    & ", " {\n      display: none;\n    }\n    & ", " {\n      display: inline-flex;\n    }\n  }\n"])), function (props) {
  return props.hoverBackgroundColor || colors.gray0;
}, LinkIconCont, LinkHoverIconCont);
var LinkUrl = styled.span(_templateObject5$k || (_templateObject5$k = _taggedTemplateLiteralLoose(["\n  display: block;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  max-width: calc(100% - 52px);\n  font-style: normal;\n  font-weight: normal;\n  font-size: 13px;\n  line-height: 16px;\n  text-decoration: underline;\n  color: ", ";\n"])), function (props) {
  return props.color || colors.gray6;
});

var _templateObject$C;

var Links = function Links(_ref) {
  var channelId = _ref.channelId,
      linkPreviewIcon = _ref.linkPreviewIcon,
      linkPreviewHoverIcon = _ref.linkPreviewHoverIcon,
      linkPreviewTitleColor = _ref.linkPreviewTitleColor,
      linkPreviewColor = _ref.linkPreviewColor,
      linkPreviewHoverBackgroundColor = _ref.linkPreviewHoverBackgroundColor;
  var dispatch = useDispatch();
  var attachments = useSelector(activeTabAttachmentsSelector, shallowEqual) || [];
  useEffect(function () {
    dispatch(getAttachmentsAC(channelId, channelDetailsTabs.link));
  }, [channelId]);
  return React__default.createElement(Container$k, null, attachments.map(function (file) {
    return React__default.createElement(LinkItem, {
      key: file.id,
      link: file.url,
      linkPreviewColor: linkPreviewColor,
      linkPreviewHoverBackgroundColor: linkPreviewHoverBackgroundColor,
      linkPreviewHoverIcon: linkPreviewHoverIcon,
      linkPreviewTitleColor: linkPreviewTitleColor,
      linkPreviewIcon: linkPreviewIcon
    });
  }));
};
var Container$k = styled.ul(_templateObject$C || (_templateObject$C = _taggedTemplateLiteralLoose(["\n  margin: 0;\n  padding: 11px 0 0;\n  overflow-x: hidden;\n  overflow-y: auto;\n  list-style: none;\n  transition: all 0.2s;\n"])));

var _rect$3, _circle$7, _path$1e;

function _extends$1i() {
  _extends$1i = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1i.apply(this, arguments);
}

function SvgVoicePreview(props) {
  return /*#__PURE__*/createElement("svg", _extends$1i({
    width: 40,
    height: 40,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _rect$3 || (_rect$3 = /*#__PURE__*/createElement("rect", {
    width: 40,
    height: 40,
    rx: 8,
    fill: "#F3F5F7"
  })), _circle$7 || (_circle$7 = /*#__PURE__*/createElement("circle", {
    cx: 20,
    cy: 20,
    r: 14,
    fill: "#0DBD8B"
  })), _path$1e || (_path$1e = /*#__PURE__*/createElement("path", {
    d: "M25.024 19.13c.635.385.635 1.354 0 1.738l-6.612 3.997c-.63.38-1.412-.1-1.412-.868v-7.995c0-.768.783-1.25 1.412-.869l6.612 3.998z",
    fill: "#fff"
  })));
}

var _rect$4, _circle$8, _path$1f;

function _extends$1j() {
  _extends$1j = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1j.apply(this, arguments);
}

function SvgVoicePreviewPause(props) {
  return /*#__PURE__*/createElement("svg", _extends$1j({
    width: 40,
    height: 40,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _rect$4 || (_rect$4 = /*#__PURE__*/createElement("rect", {
    width: 40,
    height: 40,
    rx: 8,
    fill: "#F3F5F7"
  })), _circle$8 || (_circle$8 = /*#__PURE__*/createElement("circle", {
    cx: 20,
    cy: 20,
    r: 14,
    fill: "#0DBD8B"
  })), _path$1f || (_path$1f = /*#__PURE__*/createElement("path", {
    d: "M17.974 15c.357 0 .486.037.617.107.13.07.232.172.302.302.07.13.107.26.107.617v7.948c0 .357-.037.486-.107.617a.726.726 0 01-.302.302c-.13.07-.26.107-.617.107h-.948c-.357 0-.486-.037-.617-.107a.726.726 0 01-.302-.302c-.07-.13-.107-.26-.107-.617v-7.948c0-.357.037-.486.107-.617a.726.726 0 01.302-.302c.13-.07.26-.107.617-.107h.948zm5 0c.357 0 .486.037.617.107.13.07.232.172.302.302.07.13.107.26.107.617v7.948c0 .357-.037.486-.107.617a.726.726 0 01-.302.302c-.13.07-.26.107-.617.107h-.948c-.357 0-.486-.037-.617-.107a.726.726 0 01-.302-.302c-.07-.13-.107-.26-.107-.617v-7.948c0-.357.037-.486.107-.617a.726.726 0 01.302-.302c.13-.07.26-.107.617-.107h.948z",
    fill: "#fff"
  })));
}

var _rect$5, _circle$9, _path$1g;

function _extends$1k() {
  _extends$1k = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1k.apply(this, arguments);
}

function SvgVoicePreviewHoverIcon(props) {
  return /*#__PURE__*/createElement("svg", _extends$1k({
    width: 40,
    height: 40,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _rect$5 || (_rect$5 = /*#__PURE__*/createElement("rect", {
    width: 40,
    height: 40,
    rx: 8,
    fill: "#fff"
  })), _circle$9 || (_circle$9 = /*#__PURE__*/createElement("circle", {
    cx: 20,
    cy: 20,
    r: 14,
    fill: "#0DBD8B"
  })), _path$1g || (_path$1g = /*#__PURE__*/createElement("path", {
    d: "M25.024 19.13c.635.385.635 1.354 0 1.738l-6.612 3.997c-.63.38-1.412-.1-1.412-.868v-7.995c0-.768.783-1.25 1.412-.869l6.612 3.998z",
    fill: "#fff"
  })));
}

var _rect$6, _circle$a, _path$1h;

function _extends$1l() {
  _extends$1l = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1l.apply(this, arguments);
}

function SvgVoicePreviewPauseHover(props) {
  return /*#__PURE__*/createElement("svg", _extends$1l({
    width: 40,
    height: 40,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _rect$6 || (_rect$6 = /*#__PURE__*/createElement("rect", {
    width: 40,
    height: 40,
    rx: 8,
    fill: "#fff"
  })), _circle$a || (_circle$a = /*#__PURE__*/createElement("circle", {
    cx: 20,
    cy: 20,
    r: 14,
    fill: "#0DBD8B"
  })), _path$1h || (_path$1h = /*#__PURE__*/createElement("path", {
    d: "M17.974 15c.357 0 .486.037.617.107.13.07.232.172.302.302.07.13.107.26.107.617v7.948c0 .357-.037.486-.107.617a.726.726 0 01-.302.302c-.13.07-.26.107-.617.107h-.948c-.357 0-.486-.037-.617-.107a.726.726 0 01-.302-.302c-.07-.13-.107-.26-.107-.617v-7.948c0-.357.037-.486.107-.617a.726.726 0 01.302-.302c.13-.07.26-.107.617-.107h.948zm5 0c.357 0 .486.037.617.107.13.07.232.172.302.302.07.13.107.26.107.617v7.948c0 .357-.037.486-.107.617a.726.726 0 01-.302.302c-.13.07-.26.107-.617.107h-.948c-.357 0-.486-.037-.617-.107a.726.726 0 01-.302-.302c-.07-.13-.107-.26-.107-.617v-7.948c0-.357.037-.486.107-.617a.726.726 0 01.302-.302c.13-.07.26-.107.617-.107h.948z",
    fill: "#fff"
  })));
}

var _templateObject$D, _templateObject2$A, _templateObject3$t, _templateObject4$p, _templateObject5$l, _templateObject6$j, _templateObject7$g, _templateObject8$d;

var VoiceItem = function VoiceItem(_ref) {
  var file = _ref.file,
      voicePreviewPlayIcon = _ref.voicePreviewPlayIcon,
      voicePreviewPlayHoverIcon = _ref.voicePreviewPlayHoverIcon,
      voicePreviewPauseIcon = _ref.voicePreviewPauseIcon,
      voicePreviewPauseHoverIcon = _ref.voicePreviewPauseHoverIcon,
      voicePreviewTitleColor = _ref.voicePreviewTitleColor,
      voicePreviewDateAndTimeColor = _ref.voicePreviewDateAndTimeColor,
      voicePreviewHoverBackgroundColor = _ref.voicePreviewHoverBackgroundColor,
      setVoiceIsPlaying = _ref.setVoiceIsPlaying,
      playingVoiceId = _ref.playingVoiceId;
  var getFromContacts = getShowOnlyContactUsers();

  var _useState = useState(''),
      fileUrl = _useState[0],
      setFileUrl = _useState[1];

  var _useState2 = useState(false),
      audioIsPlaying = _useState2[0],
      setAudioIsPlaying = _useState2[1];

  var _useState3 = useState(''),
      currentTime = _useState3[0],
      setCurrentTime = _useState3[1];

  var customDownloader = getCustomDownloader();
  var contactsMap = useSelector(contactsMapSelector);
  var user = useSelector(userSelector);
  var audioRef = useRef();
  var intervalRef = useRef(null);

  var handlePlayPause = function handlePlayPause() {
    if (audioRef && audioRef.current) {
      if (audioRef.current.paused) {
        var _audioRef$current, _audioRef$current5;

        var audioDuration = (_audioRef$current = audioRef.current) === null || _audioRef$current === void 0 ? void 0 : _audioRef$current.duration;
        intervalRef.current = setInterval(function () {
          var _audioRef$current2;

          var audioCurrentTime = (_audioRef$current2 = audioRef.current) === null || _audioRef$current2 === void 0 ? void 0 : _audioRef$current2.currentTime;

          if (audioDuration) {
            if ((audioCurrentTime || audioCurrentTime === 0) && audioDuration - audioCurrentTime > 0) {
              setCurrentTime(formatAudioVideoTime(audioDuration, audioCurrentTime));
            } else {
              var _audioRef$current3;

              setCurrentTime(formatAudioVideoTime(audioDuration, 0));
              setAudioIsPlaying(false);
              (_audioRef$current3 = audioRef.current) === null || _audioRef$current3 === void 0 ? void 0 : _audioRef$current3.pause();
              audioRef.current && (audioRef.current.currentTime = 0);
              clearInterval(intervalRef.current);
            }
          } else {
            var _audioRef$current4;

            audioDuration = (_audioRef$current4 = audioRef.current) === null || _audioRef$current4 === void 0 ? void 0 : _audioRef$current4.duration;
          }
        }, 10);
        setAudioIsPlaying(true);

        if (setVoiceIsPlaying) {
          setVoiceIsPlaying(file.id);
        }

        (_audioRef$current5 = audioRef.current) === null || _audioRef$current5 === void 0 ? void 0 : _audioRef$current5.play();
      } else {
        var _audioRef$current6;

        clearInterval(intervalRef.current);
        setAudioIsPlaying(false);
        (_audioRef$current6 = audioRef.current) === null || _audioRef$current6 === void 0 ? void 0 : _audioRef$current6.pause();
      }
    }
  };

  useDidUpdate(function () {
    if (playingVoiceId && playingVoiceId !== file.id) {
      var _audioRef$current7;

      clearInterval(intervalRef.current);
      setAudioIsPlaying(false);
      (_audioRef$current7 = audioRef.current) === null || _audioRef$current7 === void 0 ? void 0 : _audioRef$current7.pause();
    }
  }, [playingVoiceId]);
  useEffect(function () {
    if (customDownloader) {
      customDownloader(file.url).then(function (url) {
        setFileUrl(url);
      });
    } else {
      setFileUrl(file.url);
    }

    return function () {
      clearInterval(intervalRef.current);
    };
  }, []);
  return React__default.createElement(FileItem$2, {
    onMouseEnter: function onMouseEnter(e) {
      return e.currentTarget.classList.add('isHover');
    },
    onMouseLeave: function onMouseLeave(e) {
      return e.currentTarget.classList.remove('isHover');
    },
    hoverBackgroundColor: voicePreviewHoverBackgroundColor
  }, audioIsPlaying ? React__default.createElement(React__default.Fragment, null, React__default.createElement(FileIconCont$1, {
    onClick: handlePlayPause
  }, voicePreviewPauseIcon || React__default.createElement(SvgVoicePreviewPause, null)), React__default.createElement(FileHoverIconCont$1, {
    onClick: handlePlayPause
  }, voicePreviewPauseHoverIcon || React__default.createElement(SvgVoicePreviewPauseHover, null))) : React__default.createElement(React__default.Fragment, null, React__default.createElement(FileIconCont$1, {
    onClick: handlePlayPause
  }, voicePreviewPlayIcon || React__default.createElement(SvgVoicePreview, null)), React__default.createElement(FileHoverIconCont$1, {
    onClick: handlePlayPause
  }, voicePreviewPlayHoverIcon || React__default.createElement(SvgVoicePreviewHoverIcon, null))), React__default.createElement(AudioInfo, null, React__default.createElement(AudioTitle, {
    color: voicePreviewTitleColor
  }, file.user.id === user.id ? 'You' : makeUserName(contactsMap[file.user.id], file.user, getFromContacts)), React__default.createElement(AudioDate, {
    color: voicePreviewDateAndTimeColor
  }, moment(file.createdAt).format('DD MMMM, YYYY')), React__default.createElement(AudioSendTime, null, currentTime || formatAudioVideoTime(file.metadata.dur, 0))), React__default.createElement(Audio, {
    controls: true,
    ref: audioRef,
    src: fileUrl
  }, React__default.createElement("source", {
    src: fileUrl,
    type: 'audio/ogg'
  }), React__default.createElement("source", {
    src: fileUrl,
    type: 'audio/mpeg'
  })));
};
var FileIconCont$1 = styled.span(_templateObject$D || (_templateObject$D = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n  display: inline-flex;\n"])));
var FileHoverIconCont$1 = styled.span(_templateObject2$A || (_templateObject2$A = _taggedTemplateLiteralLoose(["\n  cursor: pointer;\n  display: none;\n"])));
var FileItem$2 = styled.li(_templateObject3$t || (_templateObject3$t = _taggedTemplateLiteralLoose(["\n  padding: 9px 16px;\n  display: flex;\n  align-items: center;\n  text-decoration: none;\n\n  &:hover {\n    background-color: ", ";\n  }\n  div {\n    margin-left: 12px;\n    width: 100%;\n  }\n  img {\n    width: 42px;\n    height: 42px;\n    border: 0.5px solid rgba(0, 0, 0, 0.1);\n    box-sizing: border-box;\n    border-radius: 6px;\n  }\n\n  &.isHover {\n    & ", " {\n      display: none;\n    }\n    & ", " {\n      display: inline-flex;\n    }\n  }\n"])), function (props) {
  return props.hoverBackgroundColor || colors.gray0;
}, FileIconCont$1, FileHoverIconCont$1);
var AudioInfo = styled.div(_templateObject4$p || (_templateObject4$p = _taggedTemplateLiteralLoose(["\n  position: relative;\n"])));
var AudioTitle = styled.span(_templateObject5$l || (_templateObject5$l = _taggedTemplateLiteralLoose(["\n  display: block;\n  font-style: normal;\n  font-weight: 500;\n  font-size: 15px;\n  line-height: 20px;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  max-width: calc(100% - 72px);\n  color: ", ";\n"])), function (props) {
  return props.color || colors.gray6;
});
var AudioDate = styled.span(_templateObject6$j || (_templateObject6$j = _taggedTemplateLiteralLoose(["\n  display: block;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  max-width: calc(100% - 72px);\n  font-style: normal;\n  font-weight: normal;\n  font-size: 12px;\n  line-height: 16px;\n  color: ", ";\n"])), function (props) {
  return props.color || colors.gray9;
});
var AudioSendTime = styled.span(_templateObject7$g || (_templateObject7$g = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  right: 0;\n  top: 11px;\n  color: ", ";\n  font-size: 12px;\n  line-height: 16px;\n"])), function (props) {
  return props.color || colors.gray9;
});
var Audio = styled.audio(_templateObject8$d || (_templateObject8$d = _taggedTemplateLiteralLoose(["\n  display: none;\n"])));

var _templateObject$E;

var Voices = function Voices(_ref) {
  var channelId = _ref.channelId,
      voicePreviewPlayIcon = _ref.voicePreviewPlayIcon,
      voicePreviewPlayHoverIcon = _ref.voicePreviewPlayHoverIcon,
      voicePreviewPauseIcon = _ref.voicePreviewPauseIcon,
      voicePreviewPauseHoverIcon = _ref.voicePreviewPauseHoverIcon,
      voicePreviewTitleColor = _ref.voicePreviewTitleColor,
      voicePreviewDateAndTimeColor = _ref.voicePreviewDateAndTimeColor,
      voicePreviewHoverBackgroundColor = _ref.voicePreviewHoverBackgroundColor;
  var dispatch = useDispatch();

  var _useState = useState(''),
      payingVoiceId = _useState[0],
      setPlayingVoiceId = _useState[1];

  var attachments = useSelector(activeTabAttachmentsSelector, shallowEqual) || [];
  useEffect(function () {
    dispatch(getAttachmentsAC(channelId, channelDetailsTabs.voice));
  }, [channelId]);
  return React__default.createElement(Container$l, null, attachments.map(function (file) {
    return React__default.createElement(VoiceItem, {
      key: file.id,
      file: file,
      voicePreviewDateAndTimeColor: voicePreviewDateAndTimeColor,
      voicePreviewHoverBackgroundColor: voicePreviewHoverBackgroundColor,
      voicePreviewPlayHoverIcon: voicePreviewPlayIcon,
      voicePreviewPlayIcon: voicePreviewPlayHoverIcon,
      voicePreviewPauseIcon: voicePreviewPauseIcon,
      voicePreviewPauseHoverIcon: voicePreviewPauseHoverIcon,
      voicePreviewTitleColor: voicePreviewTitleColor,
      setVoiceIsPlaying: function setVoiceIsPlaying(voiceId) {
        return setPlayingVoiceId(voiceId);
      },
      playingVoiceId: payingVoiceId
    });
  }));
};
var Container$l = styled.ul(_templateObject$E || (_templateObject$E = _taggedTemplateLiteralLoose(["\n  margin: 0;\n  padding: 11px 0 0;\n  overflow-x: hidden;\n  overflow-y: auto;\n  list-style: none;\n  transition: all 0.2s;\n"])));

var _templateObject$F, _templateObject2$B;

var DetailsTab = function DetailsTab(_ref) {
  var channel = _ref.channel,
      activeTab = _ref.activeTab,
      checkActionPermission = _ref.checkActionPermission,
      setActiveTab = _ref.setActiveTab,
      linkPreviewIcon = _ref.linkPreviewIcon,
      linkPreviewHoverIcon = _ref.linkPreviewHoverIcon,
      linkPreviewTitleColor = _ref.linkPreviewTitleColor,
      linkPreviewColor = _ref.linkPreviewColor,
      linkPreviewHoverBackgroundColor = _ref.linkPreviewHoverBackgroundColor,
      voicePreviewPlayIcon = _ref.voicePreviewPlayIcon,
      voicePreviewPlayHoverIcon = _ref.voicePreviewPlayHoverIcon,
      voicePreviewPauseIcon = _ref.voicePreviewPauseIcon,
      voicePreviewPauseHoverIcon = _ref.voicePreviewPauseHoverIcon,
      voicePreviewTitleColor = _ref.voicePreviewTitleColor,
      voicePreviewDateAndTimeColor = _ref.voicePreviewDateAndTimeColor,
      voicePreviewHoverBackgroundColor = _ref.voicePreviewHoverBackgroundColor,
      filePreviewIcon = _ref.filePreviewIcon,
      filePreviewHoverIcon = _ref.filePreviewHoverIcon,
      filePreviewTitleColor = _ref.filePreviewTitleColor,
      filePreviewSizeColor = _ref.filePreviewSizeColor,
      filePreviewHoverBackgroundColor = _ref.filePreviewHoverBackgroundColor,
      filePreviewDownloadIcon = _ref.filePreviewDownloadIcon,
      showChangeMemberRole = _ref.showChangeMemberRole,
      showKickMember = _ref.showKickMember,
      showKickAndBlockMember = _ref.showKickAndBlockMember,
      showMakeMemberAdmin = _ref.showMakeMemberAdmin,
      publicChannelDeleteMemberPopupDescription = _ref.publicChannelDeleteMemberPopupDescription,
      privateChannelDeleteMemberPopupDescription = _ref.privateChannelDeleteMemberPopupDescription,
      publicChannelRevokeAdminPopupDescription = _ref.publicChannelRevokeAdminPopupDescription,
      privateChannelRevokeAdminPopupDescription = _ref.privateChannelRevokeAdminPopupDescription,
      publicChannelMakeAdminPopupDescription = _ref.publicChannelMakeAdminPopupDescription,
      privateChannelMakeAdminPopupDescription = _ref.privateChannelMakeAdminPopupDescription;
  var dispatch = useDispatch();
  var isDirectChannel = channel.type === CHANNEL_TYPE.DIRECT;
  var showMembers = !isDirectChannel && checkActionPermission('getMembers');

  var handleTabClick = function handleTabClick(tabIndex) {
    dispatch(emptyChannelAttachmentsAC());
    setActiveTab(tabIndex);
  };

  useEffect(function () {
    if (!showMembers) {
      setActiveTab(channelDetailsTabs.media);
    } else {
      setActiveTab(channelDetailsTabs.member);
    }
  }, [showMembers]);
  return React__default.createElement(Container$m, null, React__default.createElement(DetailsTabHeader, {
    activeTabColor: colors.primary
  }, Object.keys(channelDetailsTabs).map(function (key) {
    if (key === 'member') {
      if (showMembers) {
        return React__default.createElement("button", {
          className: activeTab === channelDetailsTabs[key] ? 'active' : '',
          type: 'button',
          onClick: function onClick() {
            return handleTabClick(channelDetailsTabs[key]);
          },
          key: key
        }, channelDetailsTabs[key] === channelDetailsTabs.member ? channel.type === CHANNEL_TYPE.PUBLIC ? 'Subscribers' : channelDetailsTabs[key] : channelDetailsTabs[key]);
      } else {
        return null;
      }
    }

    return React__default.createElement("button", {
      className: activeTab === channelDetailsTabs[key] ? 'active' : '',
      type: 'button',
      onClick: function onClick() {
        return handleTabClick(channelDetailsTabs[key]);
      },
      key: key
    }, channelDetailsTabs[key]);
  })), showMembers && activeTab === channelDetailsTabs.member && React__default.createElement(Members, {
    publicChannelDeleteMemberPopupDescription: publicChannelDeleteMemberPopupDescription,
    privateChannelDeleteMemberPopupDescription: privateChannelDeleteMemberPopupDescription,
    publicChannelRevokeAdminPopupDescription: publicChannelRevokeAdminPopupDescription,
    privateChannelRevokeAdminPopupDescription: privateChannelRevokeAdminPopupDescription,
    publicChannelMakeAdminPopupDescription: publicChannelMakeAdminPopupDescription,
    privateChannelMakeAdminPopupDescription: privateChannelMakeAdminPopupDescription,
    channel: channel,
    chekActionPermission: checkActionPermission,
    showChangeMemberRole: showChangeMemberRole,
    showKickMember: showKickMember,
    showKickAndBlockMember: showKickAndBlockMember,
    showMakeMemberAdmin: showMakeMemberAdmin
  }), activeTab === channelDetailsTabs.media && React__default.createElement(Media, {
    channelId: channel.id
  }), activeTab === channelDetailsTabs.file && React__default.createElement(Files, {
    channelId: channel.id,
    filePreviewIcon: filePreviewIcon,
    filePreviewHoverIcon: filePreviewHoverIcon,
    filePreviewTitleColor: filePreviewTitleColor,
    filePreviewSizeColor: filePreviewSizeColor,
    filePreviewHoverBackgroundColor: filePreviewHoverBackgroundColor,
    filePreviewDownloadIcon: filePreviewDownloadIcon
  }), activeTab === channelDetailsTabs.link && React__default.createElement(Links, {
    channelId: channel.id,
    linkPreviewIcon: linkPreviewIcon,
    linkPreviewHoverIcon: linkPreviewHoverIcon,
    linkPreviewTitleColor: linkPreviewTitleColor,
    linkPreviewColor: linkPreviewColor,
    linkPreviewHoverBackgroundColor: linkPreviewHoverBackgroundColor
  }), activeTab === channelDetailsTabs.voice && React__default.createElement(Voices, {
    channelId: channel.id,
    voicePreviewPlayHoverIcon: voicePreviewPlayIcon,
    voicePreviewPlayIcon: voicePreviewPlayHoverIcon,
    voicePreviewPauseIcon: voicePreviewPauseIcon,
    voicePreviewPauseHoverIcon: voicePreviewPauseHoverIcon,
    voicePreviewTitleColor: voicePreviewTitleColor,
    voicePreviewDateAndTimeColor: voicePreviewDateAndTimeColor,
    voicePreviewHoverBackgroundColor: voicePreviewHoverBackgroundColor
  }));
};
var Container$m = styled.div(_templateObject$F || (_templateObject$F = _taggedTemplateLiteralLoose(["\n  border-top: 1px solid ", ";\n"])), colors.gray1);
var DetailsTabHeader = styled.div(_templateObject2$B || (_templateObject2$B = _taggedTemplateLiteralLoose(["\n  padding: 0 20px;\n  border-bottom: 1px solid ", ";\n  display: flex;\n  justify-content: space-between;\n  position: sticky;\n  top: 0;\n  z-index: 12;\n  background: #fff;\n  button {\n    position: relative;\n    border: none;\n    background: transparent;\n    outline: none;\n    padding: 13px 0 11px;\n    font-style: normal;\n    font-weight: 500;\n    font-size: 15px;\n    line-height: 20px;\n    color: ", ";\n    cursor: pointer;\n  }\n  & .active {\n    color: ", ";\n\n    &:after {\n      content: '';\n      width: 100%;\n      border-radius: 2px;\n      height: 2px;\n      background-color: ", ";\n      position: absolute;\n      top: calc(100% - 1px);\n      left: 0;\n    }\n  }\n"])), colors.gray1, colors.gray9, colors.gray6, function (props) {
  return props.activeTabColor || colors.primary;
});

var _path$1i;

function _extends$1m() {
  _extends$1m = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1m.apply(this, arguments);
}

function SvgCamera(props) {
  return /*#__PURE__*/createElement("svg", _extends$1m({
    width: 40,
    height: 40,
    viewBox: "0 0 41 41",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$1i || (_path$1i = /*#__PURE__*/createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M16.86 6.667a4.167 4.167 0 00-4.084 3.342c-.058.288-.17.566-.363.787l-.837.954c-.263.3-.644.473-1.043.473H6.11A2.778 2.778 0 003.333 15v15.278a2.778 2.778 0 002.778 2.778H33.89a2.778 2.778 0 002.778-2.778V15a2.778 2.778 0 00-2.778-2.777h-4.422c-.4 0-.78-.173-1.043-.473l-.837-.954c-.194-.22-.305-.499-.363-.787a4.167 4.167 0 00-4.085-3.342h-6.278zm8.696 15.278a5.556 5.556 0 11-11.112 0 5.556 5.556 0 0111.112 0zM6.806 10.139a.694.694 0 000 1.39h2.777a.694.694 0 100-1.39H6.806z",
    fill: "#fff"
  })));
}

var _templateObject$G, _templateObject2$C, _templateObject3$u, _templateObject4$q;
var Container$n = styled.div(_templateObject$G || (_templateObject$G = _taggedTemplateLiteralLoose(["\n  ", ";\n  height: ", ";\n  position: absolute;\n  padding: 24px 16px;\n  background-color: #fff;\n  z-index: 25;\n"])), function (props) {
  return props.active ? 'display: block' : 'display: none';
}, function (props) {
  return "calc(100vh - " + (props.heightOffset ? props.heightOffset + 48 : 48) + "px)";
});
var AvatarCont = styled.div(_templateObject2$C || (_templateObject2$C = _taggedTemplateLiteralLoose(["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n  margin-bottom: 4px;\n\n  &::after {\n    content: '';\n    position: absolute;\n    width: 120px;\n    height: 120px;\n    border-radius: 50%;\n    background-color: rgba(0, 0, 0, 0.4);\n  }\n  .dropdown-body {\n    top: inherit;\n    right: inherit;\n    bottom: -90px;\n  }\n"])));
var DropDownWrapper = styled.div(_templateObject3$u || (_templateObject3$u = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  z-index: 4;\n  width: 40px;\n  height: 40px;\n"])));
var EditChannelFooter = styled(ButtonBlock)(_templateObject4$q || (_templateObject4$q = _taggedTemplateLiteralLoose(["\n  margin-top: 24px;\n\n  & > button {\n    margin-left: 12px;\n  }\n"])));

var EditChannel = function EditChannel(_ref) {
  var channel = _ref.channel,
      handleToggleEditMode = _ref.handleToggleEditMode,
      editChannelSaveButtonBackgroundColor = _ref.editChannelSaveButtonBackgroundColor,
      editChannelSaveButtonTextColor = _ref.editChannelSaveButtonTextColor,
      editChannelCancelButtonBackgroundColor = _ref.editChannelCancelButtonBackgroundColor,
      editChannelCancelButtonTextColor = _ref.editChannelCancelButtonTextColor;
  var dispatch = useDispatch();
  var isEditMode = useSelector(channelEditModeSelector);

  var _useState = useState(false),
      cropPopup = _useState[0],
      setCropPopup = _useState[1];

  var _useState2 = useState(false),
      deleteAvatarPopupOpen = _useState2[0],
      setDeleteAvatarPopupOpen = _useState2[1];

  var _useState3 = useState(''),
      selectedImageUrl = _useState3[0],
      setSelectedImageUrl = _useState3[1];

  var _useState4 = useState(channel.subject),
      newSubject = _useState4[0],
      setNewSubject = _useState4[1];

  var _useState5 = useState(channel.metadata && channel.metadata.d),
      newDescription = _useState5[0],
      setNewDescription = _useState5[1];

  var _useState6 = useState(null),
      offsetTop = _useState6[0],
      setOffsetTop = _useState6[1];

  var _useStateComplex = useStateComplex({
    src: {},
    url: channel.avatarUrl
  }),
      newAvatar = _useStateComplex[0],
      setNewAvatar = _useStateComplex[1];

  var editContainer = useRef(null);
  var fileUploader = useRef(null);
  var isDirectChannel = channel.type === CHANNEL_TYPE.DIRECT;

  var onOpenFileUploader = function onOpenFileUploader() {
    fileUploader.current.click();
  };

  function handleSelectImage(image) {
    setNewAvatar({
      name: image.name
    });
    setSelectedImageUrl(URL.createObjectURL(image));
    setCropPopup(true);
  }

  var handleUpdateChannel = function handleUpdateChannel(data) {
    dispatch(updateChannelAC(channel.id, data));
  };

  var handleImageCrop = function handleImageCrop(image) {
    try {
      return Promise.resolve(resizeImage(image, undefined, undefined, 0.9)).then(function (_ref2) {
        var blob = _ref2.blob;
        var file = new File([blob], image.name);
        setNewAvatar({
          src: {
            file: file
          },
          url: URL.createObjectURL(file)
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var handleFileUpload = function handleFileUpload() {
    var file = fileUploader.current.files[0];
    handleSelectImage(file);
  };

  var handleRemoveAvatar = function handleRemoveAvatar() {
    setNewAvatar({
      src: {},
      url: ''
    });
    handleUpdateChannel({
      avatarUrl: ''
    });
  };

  var handleToggleDeleteAvatarPopup = function handleToggleDeleteAvatarPopup() {
    setDeleteAvatarPopupOpen(!deleteAvatarPopupOpen);
  };

  var handleSave = function handleSave() {
    if (newSubject !== channel.subject || newDescription !== (channel.metadata.d || channel.metadata) || newAvatar.url !== channel.avatarUrl) {
      handleUpdateChannel(_extends({}, newSubject !== channel.subject && {
        subject: newSubject
      }, newDescription !== (channel.metadata.d || channel.metadata) && {
        metadata: {
          d: newDescription
        }
      }, newAvatar.url !== channel.avatarUrl && {
        avatar: newAvatar.src.file
      }));
    }
  };

  useDidUpdate(function () {
    handleToggleEditMode(false);
    setSelectedImageUrl('');
    setNewSubject(channel.subject);
    setNewDescription(channel.metadata.d || channel.metadata);
    setNewAvatar({
      src: {},
      url: channel.avatarUrl
    });
  }, [channel]);
  useEffect(function () {
    setOffsetTop(editContainer && editContainer.current && editContainer.current.offsetTop);
  }, []);
  return React__default.createElement(React__default.Fragment, null, React__default.createElement(Container$n, {
    ref: editContainer,
    heightOffset: offsetTop,
    active: isEditMode
  }, React__default.createElement(AvatarCont, null, React__default.createElement(DropDownWrapper, null, !isDirectChannel && channel.role && React__default.createElement(DropDown, {
    position: 'center',
    trigger: React__default.createElement(SvgCamera, null)
  }, React__default.createElement(DropdownOptionsUl, null, React__default.createElement(DropdownOptionLi, {
    key: 1,
    hoverBackground: customColors.selectedChannelBackground,
    onClick: function onClick() {
      return onOpenFileUploader();
    },
    iconWidth: '20px'
  }, React__default.createElement(SvgPicture, null), React__default.createElement(UploadFileLabel, null, "Upload Avatar"), React__default.createElement(UploadFile, {
    ref: fileUploader,
    accept: '.png,.jpeg,.jpg',
    onChange: handleFileUpload,
    type: 'file'
  })), newAvatar.url && React__default.createElement(DropdownOptionLi, {
    key: 2,
    hoverBackground: customColors.selectedChannelBackground,
    textColor: colors.red1,
    onClick: handleToggleDeleteAvatarPopup,
    iconWidth: '20px'
  }, React__default.createElement(SvgDeleteChannel, null), "Remove Avatar")))), React__default.createElement(Avatar, {
    size: 120,
    image: newAvatar.url || (isDirectChannel ? channel.peer.avatarUrl : ''),
    name: isDirectChannel ? channel.peer.id : channel.subject || channel.id,
    textSize: 70
  })), React__default.createElement(Label, null, " Name "), React__default.createElement(CustomInput, {
    placeholder: 'Channel Subject',
    value: newSubject,
    onChange: function onChange(e) {
      return setNewSubject(e.target.value);
    }
  }), React__default.createElement(Label, null, " Description "), React__default.createElement(CustomInput, {
    placeholder: 'Channel description',
    value: newDescription,
    onChange: function onChange(e) {
      return setNewDescription(e.target.value);
    }
  }), React__default.createElement(EditChannelFooter, null, React__default.createElement(Button, {
    type: 'button',
    borderRadius: '8px',
    color: editChannelCancelButtonTextColor || colors.gray6,
    backgroundColor: editChannelCancelButtonBackgroundColor || colors.gray5,
    onClick: function onClick() {
      return handleToggleEditMode(false);
    }
  }, "Cancel"), React__default.createElement(Button, {
    borderRadius: '8px',
    color: editChannelSaveButtonTextColor,
    backgroundColor: editChannelSaveButtonBackgroundColor || colors.primary,
    onClick: handleSave
  }, "Save"))), cropPopup && React__default.createElement(ImageCrop, {
    image: {
      name: newAvatar.name,
      url: selectedImageUrl
    },
    onAccept: handleImageCrop,
    handleClosePopup: function handleClosePopup() {
      return setCropPopup(false);
    }
  }), deleteAvatarPopupOpen && React__default.createElement(ConfirmPopup, {
    handleFunction: handleRemoveAvatar,
    togglePopup: handleToggleDeleteAvatarPopup,
    title: 'Remove avatar?',
    description: 'Are you sure you want to remove your avatar?',
    buttonText: 'Remove'
  }));
};

var _templateObject$H, _templateObject2$D, _templateObject3$v, _templateObject4$r, _templateObject5$m, _templateObject6$k, _templateObject7$h;

var Details = function Details(_ref) {
  var channelEditIcon = _ref.channelEditIcon,
      editChannelSaveButtonBackgroundColor = _ref.editChannelSaveButtonBackgroundColor,
      editChannelSaveButtonTextColor = _ref.editChannelSaveButtonTextColor,
      editChannelCancelButtonBackgroundColor = _ref.editChannelCancelButtonBackgroundColor,
      editChannelCancelButtonTextColor = _ref.editChannelCancelButtonTextColor,
      showMuteUnmuteNotifications = _ref.showMuteUnmuteNotifications,
      muteUnmuteNotificationsOrder = _ref.muteUnmuteNotificationsOrder,
      muteNotificationIcon = _ref.muteNotificationIcon,
      unmuteNotificationIcon = _ref.unmuteNotificationIcon,
      muteNotificationIconColor = _ref.muteNotificationIconColor,
      unmuteNotificationIconColor = _ref.unmuteNotificationIconColor,
      muteUnmuteNotificationSwitcherColor = _ref.muteUnmuteNotificationSwitcherColor,
      muteUnmuteNotificationTextColor = _ref.muteUnmuteNotificationTextColor,
      timeOptionsToMuteNotifications = _ref.timeOptionsToMuteNotifications,
      showStarredMessages = _ref.showStarredMessages,
      starredMessagesOrder = _ref.starredMessagesOrder,
      staredMessagesIcon = _ref.staredMessagesIcon,
      staredMessagesIconColor = _ref.staredMessagesIconColor,
      staredMessagesTextColor = _ref.staredMessagesTextColor,
      showPinChannel = _ref.showPinChannel,
      pinChannelOrder = _ref.pinChannelOrder,
      pinChannelIcon = _ref.pinChannelIcon,
      pinChannelIconColor = _ref.pinChannelIconColor,
      pinChannelTextColor = _ref.pinChannelTextColor,
      showMarkAsReadUnread = _ref.showMarkAsReadUnread,
      markAsReadUnreadOrder = _ref.markAsReadUnreadOrder,
      markAsReadIcon = _ref.markAsReadIcon,
      markAsUnreadIcon = _ref.markAsUnreadIcon,
      markAsReadIconColor = _ref.markAsReadIconColor,
      markAsUnreadIconColor = _ref.markAsUnreadIconColor,
      markAsReadUnreadTextColor = _ref.markAsReadUnreadTextColor,
      showLeaveChannel = _ref.showLeaveChannel,
      leaveChannelOrder = _ref.leaveChannelOrder,
      leaveChannelIcon = _ref.leaveChannelIcon,
      leaveChannelIconColor = _ref.leaveChannelIconColor,
      leaveChannelTextColor = _ref.leaveChannelTextColor,
      showReportChannel = _ref.showReportChannel,
      reportChannelIcon = _ref.reportChannelIcon,
      reportChannelOrder = _ref.reportChannelOrder,
      reportChannelIconColor = _ref.reportChannelIconColor,
      reportChannelTextColor = _ref.reportChannelTextColor,
      deleteChannelIcon = _ref.deleteChannelIcon,
      showDeleteChannel = _ref.showDeleteChannel,
      deleteChannelIconColor = _ref.deleteChannelIconColor,
      deleteChannelTextColor = _ref.deleteChannelTextColor,
      deleteChannelOrder = _ref.deleteChannelOrder,
      showBlockAndLeaveChannel = _ref.showBlockAndLeaveChannel,
      showBlockUser = _ref.showBlockUser,
      blockAndLeaveChannelIcon = _ref.blockAndLeaveChannelIcon,
      blockAndLeaveChannelIconColor = _ref.blockAndLeaveChannelIconColor,
      blockAndLeaveChannelTextColor = _ref.blockAndLeaveChannelTextColor,
      unblockUserIcon = _ref.unblockUserIcon,
      linkPreviewIcon = _ref.linkPreviewIcon,
      linkPreviewHoverIcon = _ref.linkPreviewHoverIcon,
      linkPreviewTitleColor = _ref.linkPreviewTitleColor,
      linkPreviewColor = _ref.linkPreviewColor,
      linkPreviewHoverBackgroundColor = _ref.linkPreviewHoverBackgroundColor,
      voicePreviewPlayIcon = _ref.voicePreviewPlayIcon,
      voicePreviewPlayHoverIcon = _ref.voicePreviewPlayHoverIcon,
      voicePreviewPauseIcon = _ref.voicePreviewPauseIcon,
      voicePreviewPauseHoverIcon = _ref.voicePreviewPauseHoverIcon,
      voicePreviewTitleColor = _ref.voicePreviewTitleColor,
      voicePreviewDateAndTimeColor = _ref.voicePreviewDateAndTimeColor,
      voicePreviewHoverBackgroundColor = _ref.voicePreviewHoverBackgroundColor,
      filePreviewIcon = _ref.filePreviewIcon,
      filePreviewHoverIcon = _ref.filePreviewHoverIcon,
      filePreviewTitleColor = _ref.filePreviewTitleColor,
      filePreviewSizeColor = _ref.filePreviewSizeColor,
      filePreviewHoverBackgroundColor = _ref.filePreviewHoverBackgroundColor,
      filePreviewDownloadIcon = _ref.filePreviewDownloadIcon,
      blockUserWarningText = _ref.blockUserWarningText,
      blockAndLeavePublicChannelWarningText = _ref.blockAndLeavePublicChannelWarningText,
      blockAndLeavePrivateChannelWarningText = _ref.blockAndLeavePrivateChannelWarningText,
      leavePublicChannelWarningText = _ref.leavePublicChannelWarningText,
      leavePrivateChannelWarningText = _ref.leavePrivateChannelWarningText,
      deletePublicChannelWarningText = _ref.deletePublicChannelWarningText,
      deletePrivateChannelWarningText = _ref.deletePrivateChannelWarningText,
      deleteDirectChannelWarningText = _ref.deleteDirectChannelWarningText,
      clearHistoryPublicChannelWarningText = _ref.clearHistoryPublicChannelWarningText,
      clearHistoryPrivateChannelWarningText = _ref.clearHistoryPrivateChannelWarningText,
      clearHistoryDirectChannelWarningText = _ref.clearHistoryDirectChannelWarningText,
      showClearHistoryForDirectChannel = _ref.showClearHistoryForDirectChannel,
      showClearHistoryForPrivateChannel = _ref.showClearHistoryForPrivateChannel,
      showClearHistoryForPublicChannel = _ref.showClearHistoryForPublicChannel,
      clearHistoryOrder = _ref.clearHistoryOrder,
      clearHistoryIcon = _ref.clearHistoryIcon,
      clearHistoryTextColor = _ref.clearHistoryTextColor,
      showDeleteAllMessagesForDirectChannel = _ref.showDeleteAllMessagesForDirectChannel,
      showDeleteAllMessagesForPrivateChannel = _ref.showDeleteAllMessagesForPrivateChannel,
      showDeleteAllMessagesForPublicChannel = _ref.showDeleteAllMessagesForPublicChannel,
      deleteAllMessagesOrder = _ref.deleteAllMessagesOrder,
      deleteAllMessagesIcon = _ref.deleteAllMessagesIcon,
      deleteAllMessagesTextColor = _ref.deleteAllMessagesTextColor,
      showChangeMemberRole = _ref.showChangeMemberRole,
      showKickMember = _ref.showKickMember,
      showKickAndBlockMember = _ref.showKickAndBlockMember,
      showMakeMemberAdmin = _ref.showMakeMemberAdmin,
      publicChannelDeleteMemberPopupDescription = _ref.publicChannelDeleteMemberPopupDescription,
      privateChannelDeleteMemberPopupDescription = _ref.privateChannelDeleteMemberPopupDescription,
      publicChannelRevokeAdminPopupDescription = _ref.publicChannelRevokeAdminPopupDescription,
      privateChannelRevokeAdminPopupDescription = _ref.privateChannelRevokeAdminPopupDescription,
      publicChannelMakeAdminPopupDescription = _ref.publicChannelMakeAdminPopupDescription,
      privateChannelMakeAdminPopupDescription = _ref.privateChannelMakeAdminPopupDescription;
  var dispatch = useDispatch();
  var getFromContacts = getShowOnlyContactUsers();

  var _useState = useState(false),
      mounted = _useState[0],
      setMounted = _useState[1];

  var _useState2 = useState(''),
      activeTab = _useState2[0],
      setActiveTab = _useState2[1];

  var editMode = useSelector(channelEditModeSelector);
  var channel = useSelector(activeChannelSelector, shallowEqual);

  var _usePermissions = usePermissions(channel.role),
      checkActionPermission = _usePermissions[0];

  var membersLoading = useSelector(membersLoadingStateSelector);
  var messagesLoading = useSelector(messagesLoadingState);
  var attachmentsHasNex = useSelector(activeTabAttachmentsHasNextSelector);
  var contactsMap = useSelector(contactsMapSelector);
  var detailsRef = useRef(null);
  var isDirectChannel = channel.type === CHANNEL_TYPE.DIRECT;

  var handleMembersListScroll = function handleMembersListScroll(event) {
    if (event.target.scrollTop >= event.target.scrollHeight - event.target.offsetHeight - 100) {
      if (activeTab === channelDetailsTabs.member) {
        if (membersLoading === LOADING_STATE.LOADED) {
          dispatch(loadMoreMembersAC(15));
        }
      } else if (messagesLoading === LOADING_STATE.LOADED && attachmentsHasNex) {
        dispatch(loadMoreAttachmentsAC(10));
      }
    }
  };

  var setEditMode = function setEditMode(state) {
    dispatch(toggleEditChannelAC(state));
  };

  var handleDetailsClose = function handleDetailsClose() {
    setMounted(false);
    dispatch(switchChannelInfoAC(false));
  };

  useEffect(function () {
    setMounted(true);
  }, []);
  return React__default.createElement(Container$o, {
    mounted: mounted
  }, React__default.createElement(ChannelDetailsHeader, null, editMode ? React__default.createElement(React__default.Fragment, null, React__default.createElement(SvgArrowLeft, {
    onClick: function onClick() {
      return setEditMode(false);
    }
  }), React__default.createElement(SectionHeader, {
    margin: '0 0 0 12px'
  }, " Edit details ")) : React__default.createElement(React__default.Fragment, null, React__default.createElement(SectionHeader, null, "Details"), " ", React__default.createElement(CloseIcon, {
    onClick: handleDetailsClose
  }))), editMode && React__default.createElement(EditChannel, {
    channel: channel,
    handleToggleEditMode: setEditMode,
    editChannelSaveButtonBackgroundColor: editChannelSaveButtonBackgroundColor,
    editChannelSaveButtonTextColor: editChannelSaveButtonTextColor,
    editChannelCancelButtonBackgroundColor: editChannelCancelButtonBackgroundColor,
    editChannelCancelButtonTextColor: editChannelCancelButtonTextColor
  }), React__default.createElement(ChatDetails, {
    onScroll: handleMembersListScroll,
    heightOffset: detailsRef && detailsRef.current && detailsRef.current.offsetTop,
    ref: detailsRef
  }, React__default.createElement(DetailsHeader, null, React__default.createElement(Avatar, {
    image: channel.avatarUrl || channel.peer && channel.peer.avatarUrl,
    name: channel.subject || channel.peer && (channel.peer.firstName || channel.peer.id),
    size: 72,
    textSize: 26,
    setDefaultAvatar: isDirectChannel
  }), React__default.createElement(ChannelInfo$3, null, React__default.createElement(ChannelName$1, {
    isDirect: isDirectChannel
  }, channel.subject || (isDirectChannel ? makeUserName(contactsMap[channel.peer.id], channel.peer, getFromContacts) : '')), isDirectChannel ? React__default.createElement(SubTitle, null, hideUserPresence(channel.peer) ? '' : channel.peer.presence && (channel.peer.presence.state === PRESENCE_STATUS.ONLINE ? 'Online' : channel.peer.presence.lastActiveAt && userLastActiveDateFormat(channel.peer.presence.lastActiveAt))) : React__default.createElement(SubTitle, null, channel.memberCount, ' ', channel.type === CHANNEL_TYPE.PUBLIC ? channel.memberCount > 1 ? 'subscribers' : 'subscriber' : channel.memberCount > 1 ? 'members' : 'member')), !isDirectChannel && checkActionPermission('editChannel') && React__default.createElement(EditButton, {
    onClick: function onClick() {
      return setEditMode(true);
    }
  }, channelEditIcon || React__default.createElement(SvgEdit, null))), channel.role && React__default.createElement(Actions$1, {
    showMuteUnmuteNotifications: showMuteUnmuteNotifications,
    muteUnmuteNotificationsOrder: muteUnmuteNotificationsOrder,
    unmuteNotificationIcon: unmuteNotificationIcon,
    muteNotificationIconColor: muteNotificationIconColor,
    unmuteNotificationIconColor: unmuteNotificationIconColor,
    muteUnmuteNotificationSwitcherColor: muteUnmuteNotificationSwitcherColor,
    muteUnmuteNotificationTextColor: muteUnmuteNotificationTextColor,
    showStarredMessages: showStarredMessages,
    starredMessagesOrder: starredMessagesOrder,
    staredMessagesIcon: staredMessagesIcon,
    staredMessagesIconColor: staredMessagesIconColor,
    staredMessagesTextColor: staredMessagesTextColor,
    showClearHistoryForDirectChannel: showClearHistoryForDirectChannel,
    showClearHistoryForPrivateChannel: showClearHistoryForPrivateChannel,
    showClearHistoryForPublicChannel: showClearHistoryForPublicChannel,
    clearHistoryOrder: clearHistoryOrder,
    clearHistoryIcon: clearHistoryIcon,
    clearHistoryTextColor: clearHistoryTextColor,
    showDeleteAllMessagesForDirectChannel: showDeleteAllMessagesForDirectChannel,
    showDeleteAllMessagesForPrivateChannel: showDeleteAllMessagesForPrivateChannel,
    showDeleteAllMessagesForPublicChannel: showDeleteAllMessagesForPublicChannel,
    deleteAllMessagesOrder: deleteAllMessagesOrder,
    deleteAllMessagesIcon: deleteAllMessagesIcon,
    deleteAllMessagesTextColor: deleteAllMessagesTextColor,
    showPinChannel: showPinChannel,
    pinChannelOrder: pinChannelOrder,
    pinChannelIcon: pinChannelIcon,
    pinChannelIconColor: pinChannelIconColor,
    pinChannelTextColor: pinChannelTextColor,
    showMarkAsReadUnread: showMarkAsReadUnread,
    markAsReadUnreadOrder: markAsReadUnreadOrder,
    markAsReadIcon: markAsReadIcon,
    markAsUnreadIcon: markAsUnreadIcon,
    markAsReadIconColor: markAsReadIconColor,
    markAsUnreadIconColor: markAsUnreadIconColor,
    markAsReadUnreadTextColor: markAsReadUnreadTextColor,
    showLeaveChannel: showLeaveChannel,
    leaveChannelOrder: leaveChannelOrder,
    leaveChannelIcon: leaveChannelIcon,
    leaveChannelIconColor: leaveChannelIconColor,
    leaveChannelTextColor: leaveChannelTextColor,
    showReportChannel: showReportChannel,
    reportChannelIcon: reportChannelIcon,
    reportChannelOrder: reportChannelOrder,
    reportChannelIconColor: reportChannelIconColor,
    reportChannelTextColor: reportChannelTextColor,
    showDeleteChannel: showDeleteChannel && checkActionPermission('deleteChannel'),
    deleteChannelIcon: deleteChannelIcon,
    deleteChannelIconColor: deleteChannelIconColor,
    deleteChannelTextColor: deleteChannelTextColor,
    deleteChannelOrder: deleteChannelOrder,
    showBlockAndLeaveChannel: showBlockAndLeaveChannel,
    showBlockUser: showBlockUser,
    blockAndLeaveChannelIcon: blockAndLeaveChannelIcon,
    blockAndLeaveChannelIconColor: blockAndLeaveChannelIconColor,
    blockAndLeaveChannelTextColor: blockAndLeaveChannelTextColor,
    unblockUserIcon: unblockUserIcon,
    muteNotificationIcon: muteNotificationIcon,
    channel: channel,
    toggleable: false,
    blockUserWarningText: blockUserWarningText,
    blockAndLeavePublicChannelWarningText: blockAndLeavePublicChannelWarningText,
    blockAndLeavePrivateChannelWarningText: blockAndLeavePrivateChannelWarningText,
    leavePublicChannelWarningText: leavePublicChannelWarningText,
    leavePrivateChannelWarningText: leavePrivateChannelWarningText,
    deletePublicChannelWarningText: deletePublicChannelWarningText,
    deletePrivateChannelWarningText: deletePrivateChannelWarningText,
    deleteDirectChannelWarningText: deleteDirectChannelWarningText,
    clearHistoryPublicChannelWarningText: clearHistoryPublicChannelWarningText,
    clearHistoryPrivateChannelWarningText: clearHistoryPrivateChannelWarningText,
    clearHistoryDirectChannelWarningText: clearHistoryDirectChannelWarningText,
    timeOptionsToMuteNotifications: timeOptionsToMuteNotifications
  }), React__default.createElement(DetailsTab, {
    channel: channel,
    activeTab: activeTab,
    setActiveTab: setActiveTab,
    linkPreviewIcon: linkPreviewIcon,
    linkPreviewHoverIcon: linkPreviewHoverIcon,
    linkPreviewTitleColor: linkPreviewTitleColor,
    linkPreviewColor: linkPreviewColor,
    linkPreviewHoverBackgroundColor: linkPreviewHoverBackgroundColor,
    voicePreviewPlayHoverIcon: voicePreviewPlayIcon,
    voicePreviewPlayIcon: voicePreviewPlayHoverIcon,
    voicePreviewPauseIcon: voicePreviewPauseIcon,
    voicePreviewPauseHoverIcon: voicePreviewPauseHoverIcon,
    voicePreviewTitleColor: voicePreviewTitleColor,
    voicePreviewDateAndTimeColor: voicePreviewDateAndTimeColor,
    voicePreviewHoverBackgroundColor: voicePreviewHoverBackgroundColor,
    filePreviewIcon: filePreviewIcon,
    filePreviewHoverIcon: filePreviewHoverIcon,
    filePreviewTitleColor: filePreviewTitleColor,
    filePreviewSizeColor: filePreviewSizeColor,
    filePreviewHoverBackgroundColor: filePreviewHoverBackgroundColor,
    filePreviewDownloadIcon: filePreviewDownloadIcon,
    checkActionPermission: checkActionPermission,
    showChangeMemberRole: showChangeMemberRole,
    showKickMember: showKickMember,
    showKickAndBlockMember: showKickAndBlockMember,
    showMakeMemberAdmin: showMakeMemberAdmin,
    publicChannelDeleteMemberPopupDescription: publicChannelDeleteMemberPopupDescription,
    privateChannelDeleteMemberPopupDescription: privateChannelDeleteMemberPopupDescription,
    publicChannelRevokeAdminPopupDescription: publicChannelRevokeAdminPopupDescription,
    privateChannelRevokeAdminPopupDescription: privateChannelRevokeAdminPopupDescription,
    publicChannelMakeAdminPopupDescription: publicChannelMakeAdminPopupDescription,
    privateChannelMakeAdminPopupDescription: privateChannelMakeAdminPopupDescription
  })));
};
var Container$o = styled.div(_templateObject$H || (_templateObject$H = _taggedTemplateLiteralLoose(["\n  flex: 0 0 auto;\n  width: 0;\n  border-left: 1px solid ", ";\n  //transition: all 0.1s;\n  ", "\n}\n"])), colors.gray1, function (props) {
  return props.mounted && ' width: 360px';
});
var ChannelDetailsHeader = styled.div(_templateObject2$D || (_templateObject2$D = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  padding: 16px;\n  position: relative;\n  height: 64px;\n  box-sizing: border-box;\n  border-bottom: 1px solid ", ";\n\n  & svg {\n    cursor: pointer;\n  }\n"])), colors.gray1);
var ChatDetails = styled.div(_templateObject3$v || (_templateObject3$v = _taggedTemplateLiteralLoose(["\n  position: relative;\n  width: 360px;\n  height: ", ";\n  overflow-y: auto;\n"])), function (props) {
  return props.heightOffset ? "calc(100vh - " + props.heightOffset + "px)" : '100vh';
});
var ChannelInfo$3 = styled.div(_templateObject4$r || (_templateObject4$r = _taggedTemplateLiteralLoose(["\n  margin-left: 16px;\n"])));
var DetailsHeader = styled.div(_templateObject5$m || (_templateObject5$m = _taggedTemplateLiteralLoose(["\n  display: flex;\n  position: relative;\n  border-bottom: 6px solid ", ";\n  align-items: center;\n  box-sizing: border-box;\n  padding: 20px 16px;\n"])), colors.gray0);
var ChannelName$1 = styled(SectionHeader)(_templateObject6$k || (_templateObject6$k = _taggedTemplateLiteralLoose(["\n  white-space: nowrap;\n  max-width: ", ";\n  text-overflow: ellipsis;\n  overflow: hidden;\n"])), function (props) {
  return props.isDirect ? '200px' : '168px';
});
var EditButton = styled.span(_templateObject7$h || (_templateObject7$h = _taggedTemplateLiteralLoose(["\n  margin-left: 8px;\n  cursor: pointer;\n  color: #b2b6be;\n"])));

var ChannelDetailsContainer = function ChannelDetailsContainer(_ref) {
  var channelEditIcon = _ref.channelEditIcon,
      editChannelSaveButtonBackgroundColor = _ref.editChannelSaveButtonBackgroundColor,
      editChannelSaveButtonTextColor = _ref.editChannelSaveButtonTextColor,
      editChannelCancelButtonBackgroundColor = _ref.editChannelCancelButtonBackgroundColor,
      editChannelCancelButtonTextColor = _ref.editChannelCancelButtonTextColor,
      showMuteUnmuteNotifications = _ref.showMuteUnmuteNotifications,
      muteUnmuteNotificationsOrder = _ref.muteUnmuteNotificationsOrder,
      muteNotificationIcon = _ref.muteNotificationIcon,
      unmuteNotificationIcon = _ref.unmuteNotificationIcon,
      muteNotificationIconColor = _ref.muteNotificationIconColor,
      unmuteNotificationIconColor = _ref.unmuteNotificationIconColor,
      muteUnmuteNotificationSwitcherColor = _ref.muteUnmuteNotificationSwitcherColor,
      muteUnmuteNotificationTextColor = _ref.muteUnmuteNotificationTextColor,
      timeOptionsToMuteNotifications = _ref.timeOptionsToMuteNotifications,
      showStarredMessages = _ref.showStarredMessages,
      starredMessagesOrder = _ref.starredMessagesOrder,
      staredMessagesIcon = _ref.staredMessagesIcon,
      staredMessagesIconColor = _ref.staredMessagesIconColor,
      staredMessagesTextColor = _ref.staredMessagesTextColor,
      showPinChannel = _ref.showPinChannel,
      pinChannelOrder = _ref.pinChannelOrder,
      pinChannelIcon = _ref.pinChannelIcon,
      pinChannelIconColor = _ref.pinChannelIconColor,
      pinChannelTextColor = _ref.pinChannelTextColor,
      showMarkAsReadUnread = _ref.showMarkAsReadUnread,
      markAsReadUnreadOrder = _ref.markAsReadUnreadOrder,
      markAsReadIcon = _ref.markAsReadIcon,
      markAsUnreadIcon = _ref.markAsUnreadIcon,
      markAsReadIconColor = _ref.markAsReadIconColor,
      markAsUnreadIconColor = _ref.markAsUnreadIconColor,
      markAsReadUnreadTextColor = _ref.markAsReadUnreadTextColor,
      showLeaveChannel = _ref.showLeaveChannel,
      leaveChannelOrder = _ref.leaveChannelOrder,
      leaveChannelIcon = _ref.leaveChannelIcon,
      leaveChannelIconColor = _ref.leaveChannelIconColor,
      leaveChannelTextColor = _ref.leaveChannelTextColor,
      showReportChannel = _ref.showReportChannel,
      reportChannelIcon = _ref.reportChannelIcon,
      reportChannelOrder = _ref.reportChannelOrder,
      reportChannelIconColor = _ref.reportChannelIconColor,
      reportChannelTextColor = _ref.reportChannelTextColor,
      showDeleteChannel = _ref.showDeleteChannel,
      deleteChannelIcon = _ref.deleteChannelIcon,
      deleteChannelIconColor = _ref.deleteChannelIconColor,
      deleteChannelTextColor = _ref.deleteChannelTextColor,
      deleteChannelOrder = _ref.deleteChannelOrder,
      showBlockAndLeaveChannel = _ref.showBlockAndLeaveChannel,
      showBlockUser = _ref.showBlockUser,
      blockAndLeaveChannelIcon = _ref.blockAndLeaveChannelIcon,
      blockAndLeaveChannelIconColor = _ref.blockAndLeaveChannelIconColor,
      blockAndLeaveChannelTextColor = _ref.blockAndLeaveChannelTextColor,
      unblockUserIcon = _ref.unblockUserIcon,
      linkPreviewIcon = _ref.linkPreviewIcon,
      linkPreviewHoverIcon = _ref.linkPreviewHoverIcon,
      linkPreviewTitleColor = _ref.linkPreviewTitleColor,
      linkPreviewColor = _ref.linkPreviewColor,
      linkPreviewHoverBackgroundColor = _ref.linkPreviewHoverBackgroundColor,
      filePreviewIcon = _ref.filePreviewIcon,
      filePreviewHoverIcon = _ref.filePreviewHoverIcon,
      filePreviewTitleColor = _ref.filePreviewTitleColor,
      filePreviewSizeColor = _ref.filePreviewSizeColor,
      filePreviewHoverBackgroundColor = _ref.filePreviewHoverBackgroundColor,
      filePreviewDownloadIcon = _ref.filePreviewDownloadIcon,
      blockUserWarningText = _ref.blockUserWarningText,
      blockAndLeavePublicChannelWarningText = _ref.blockAndLeavePublicChannelWarningText,
      blockAndLeavePrivateChannelWarningText = _ref.blockAndLeavePrivateChannelWarningText,
      leavePublicChannelWarningText = _ref.leavePublicChannelWarningText,
      leavePrivateChannelWarningText = _ref.leavePrivateChannelWarningText,
      deletePublicChannelWarningText = _ref.deletePublicChannelWarningText,
      deletePrivateChannelWarningText = _ref.deletePrivateChannelWarningText,
      deleteDirectChannelWarningText = _ref.deleteDirectChannelWarningText,
      clearHistoryPublicChannelWarningText = _ref.clearHistoryPublicChannelWarningText,
      clearHistoryPrivateChannelWarningText = _ref.clearHistoryPrivateChannelWarningText,
      clearHistoryDirectChannelWarningText = _ref.clearHistoryDirectChannelWarningText,
      showClearHistoryForDirectChannel = _ref.showClearHistoryForDirectChannel,
      showClearHistoryForPrivateChannel = _ref.showClearHistoryForPrivateChannel,
      showClearHistoryForPublicChannel = _ref.showClearHistoryForPublicChannel,
      clearHistoryOrder = _ref.clearHistoryOrder,
      clearHistoryIcon = _ref.clearHistoryIcon,
      clearHistoryTextColor = _ref.clearHistoryTextColor,
      showDeleteAllMessagesForDirectChannel = _ref.showDeleteAllMessagesForDirectChannel,
      showDeleteAllMessagesForPrivateChannel = _ref.showDeleteAllMessagesForPrivateChannel,
      showDeleteAllMessagesForPublicChannel = _ref.showDeleteAllMessagesForPublicChannel,
      deleteAllMessagesOrder = _ref.deleteAllMessagesOrder,
      deleteAllMessagesIcon = _ref.deleteAllMessagesIcon,
      deleteAllMessagesTextColor = _ref.deleteAllMessagesTextColor,
      showChangeMemberRole = _ref.showChangeMemberRole,
      showKickMember = _ref.showKickMember,
      showKickAndBlockMember = _ref.showKickAndBlockMember,
      publicChannelDeleteMemberPopupDescription = _ref.publicChannelDeleteMemberPopupDescription,
      privateChannelDeleteMemberPopupDescription = _ref.privateChannelDeleteMemberPopupDescription,
      publicChannelRevokeAdminPopupDescription = _ref.publicChannelRevokeAdminPopupDescription,
      privateChannelRevokeAdminPopupDescription = _ref.privateChannelRevokeAdminPopupDescription,
      publicChannelMakeAdminPopupDescription = _ref.publicChannelMakeAdminPopupDescription,
      privateChannelMakeAdminPopupDescription = _ref.privateChannelMakeAdminPopupDescription;
  var channelDetailsIsOpen = useSelector(channelInfoIsOpenSelector, shallowEqual);
  return React__default.createElement(React__default.Fragment, null, channelDetailsIsOpen && React__default.createElement(Details, {
    channelEditIcon: channelEditIcon,
    editChannelSaveButtonBackgroundColor: editChannelSaveButtonBackgroundColor,
    editChannelSaveButtonTextColor: editChannelSaveButtonTextColor,
    editChannelCancelButtonBackgroundColor: editChannelCancelButtonBackgroundColor,
    editChannelCancelButtonTextColor: editChannelCancelButtonTextColor,
    showMuteUnmuteNotifications: showMuteUnmuteNotifications,
    muteUnmuteNotificationsOrder: muteUnmuteNotificationsOrder,
    muteNotificationIcon: muteNotificationIcon,
    unmuteNotificationIcon: unmuteNotificationIcon,
    muteNotificationIconColor: muteNotificationIconColor,
    unmuteNotificationIconColor: unmuteNotificationIconColor,
    muteUnmuteNotificationSwitcherColor: muteUnmuteNotificationSwitcherColor,
    muteUnmuteNotificationTextColor: muteUnmuteNotificationTextColor,
    timeOptionsToMuteNotifications: timeOptionsToMuteNotifications,
    showStarredMessages: showStarredMessages,
    starredMessagesOrder: starredMessagesOrder,
    staredMessagesIcon: staredMessagesIcon,
    staredMessagesIconColor: staredMessagesIconColor,
    staredMessagesTextColor: staredMessagesTextColor,
    showPinChannel: showPinChannel,
    pinChannelOrder: pinChannelOrder,
    pinChannelIcon: pinChannelIcon,
    pinChannelIconColor: pinChannelIconColor,
    pinChannelTextColor: pinChannelTextColor,
    showMarkAsReadUnread: showMarkAsReadUnread,
    markAsReadUnreadOrder: markAsReadUnreadOrder,
    markAsReadIcon: markAsReadIcon,
    markAsUnreadIcon: markAsUnreadIcon,
    markAsReadIconColor: markAsReadIconColor,
    markAsUnreadIconColor: markAsUnreadIconColor,
    markAsReadUnreadTextColor: markAsReadUnreadTextColor,
    showLeaveChannel: showLeaveChannel,
    leaveChannelOrder: leaveChannelOrder,
    leaveChannelIcon: leaveChannelIcon,
    leaveChannelIconColor: leaveChannelIconColor,
    leaveChannelTextColor: leaveChannelTextColor,
    showReportChannel: showReportChannel,
    reportChannelIcon: reportChannelIcon,
    reportChannelOrder: reportChannelOrder,
    reportChannelIconColor: reportChannelIconColor,
    reportChannelTextColor: reportChannelTextColor,
    showDeleteChannel: showDeleteChannel,
    deleteChannelIcon: deleteChannelIcon,
    deleteChannelIconColor: deleteChannelIconColor,
    deleteChannelTextColor: deleteChannelTextColor,
    deleteChannelOrder: deleteChannelOrder,
    showBlockAndLeaveChannel: showBlockAndLeaveChannel,
    showBlockUser: showBlockUser,
    blockAndLeaveChannelIcon: blockAndLeaveChannelIcon,
    blockAndLeaveChannelIconColor: blockAndLeaveChannelIconColor,
    blockAndLeaveChannelTextColor: blockAndLeaveChannelTextColor,
    unblockUserIcon: unblockUserIcon,
    linkPreviewIcon: linkPreviewIcon,
    linkPreviewHoverIcon: linkPreviewHoverIcon,
    linkPreviewTitleColor: linkPreviewTitleColor,
    linkPreviewColor: linkPreviewColor,
    linkPreviewHoverBackgroundColor: linkPreviewHoverBackgroundColor,
    filePreviewIcon: filePreviewIcon,
    filePreviewHoverIcon: filePreviewHoverIcon,
    filePreviewTitleColor: filePreviewTitleColor,
    filePreviewSizeColor: filePreviewSizeColor,
    filePreviewHoverBackgroundColor: filePreviewHoverBackgroundColor,
    filePreviewDownloadIcon: filePreviewDownloadIcon,
    blockUserWarningText: blockUserWarningText,
    blockAndLeavePublicChannelWarningText: blockAndLeavePublicChannelWarningText,
    blockAndLeavePrivateChannelWarningText: blockAndLeavePrivateChannelWarningText,
    leavePublicChannelWarningText: leavePublicChannelWarningText,
    leavePrivateChannelWarningText: leavePrivateChannelWarningText,
    deletePublicChannelWarningText: deletePublicChannelWarningText,
    deletePrivateChannelWarningText: deletePrivateChannelWarningText,
    deleteDirectChannelWarningText: deleteDirectChannelWarningText,
    clearHistoryPublicChannelWarningText: clearHistoryPublicChannelWarningText,
    clearHistoryPrivateChannelWarningText: clearHistoryPrivateChannelWarningText,
    clearHistoryDirectChannelWarningText: clearHistoryDirectChannelWarningText,
    showClearHistoryForDirectChannel: showClearHistoryForDirectChannel,
    showClearHistoryForPrivateChannel: showClearHistoryForPrivateChannel,
    showClearHistoryForPublicChannel: showClearHistoryForPublicChannel,
    clearHistoryOrder: clearHistoryOrder,
    clearHistoryIcon: clearHistoryIcon,
    clearHistoryTextColor: clearHistoryTextColor,
    showDeleteAllMessagesForDirectChannel: showDeleteAllMessagesForDirectChannel,
    showDeleteAllMessagesForPrivateChannel: showDeleteAllMessagesForPrivateChannel,
    showDeleteAllMessagesForPublicChannel: showDeleteAllMessagesForPublicChannel,
    deleteAllMessagesOrder: deleteAllMessagesOrder,
    deleteAllMessagesIcon: deleteAllMessagesIcon,
    deleteAllMessagesTextColor: deleteAllMessagesTextColor,
    showChangeMemberRole: showChangeMemberRole,
    showKickMember: showKickMember,
    showKickAndBlockMember: showKickAndBlockMember,
    publicChannelDeleteMemberPopupDescription: publicChannelDeleteMemberPopupDescription,
    privateChannelDeleteMemberPopupDescription: privateChannelDeleteMemberPopupDescription,
    publicChannelRevokeAdminPopupDescription: publicChannelRevokeAdminPopupDescription,
    privateChannelRevokeAdminPopupDescription: privateChannelRevokeAdminPopupDescription,
    publicChannelMakeAdminPopupDescription: publicChannelMakeAdminPopupDescription,
    privateChannelMakeAdminPopupDescription: privateChannelMakeAdminPopupDescription
  }));
};

var _path$1j, _path2$a, _path3$5;

function _extends$1n() {
  _extends$1n = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1n.apply(this, arguments);
}

function SvgChatLogo(props) {
  return /*#__PURE__*/createElement("svg", _extends$1n({
    viewBox: "0 0 249 41",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$1j || (_path$1j = /*#__PURE__*/createElement("path", {
    d: "M12.507.012a13.357 13.357 0 00-8.978 4.275 13.325 13.325 0 00.355 18.435 13.358 13.358 0 009.136 3.927h10.826a2.536 2.536 0 002.545-2.541V13.336a13.3 13.3 0 00-4.094-9.623 13.333 13.333 0 00-9.79-3.701z",
    fill: "#e17335"
  })), _path2$a || (_path2$a = /*#__PURE__*/createElement("path", {
    d: "M27.961 40.988a13.357 13.357 0 008.978-4.275 13.325 13.325 0 00-.355-18.435 13.358 13.358 0 00-9.136-3.927H16.622a2.547 2.547 0 00-2.545 2.541v10.772a13.3 13.3 0 004.095 9.623 13.333 13.333 0 009.79 3.701z",
    fill: "#FFCA41"
  })), _path3$5 || (_path3$5 = /*#__PURE__*/createElement("path", {
    d: "M26.391 14.35v9.757a2.54 2.54 0 01-2.545 2.542h-9.769v-9.757a2.54 2.54 0 012.381-2.542l.164-.01h9.77v.01zM63.088 35.561c7.961 0 12.042-5.274 13.122-9.63l-5.16-1.558c-.76 2.637-3.121 5.794-7.962 5.794-4.56 0-8.8-3.316-8.8-9.35 0-6.433 4.48-9.47 8.72-9.47 4.921 0 7.121 2.997 7.801 5.714l5.201-1.638c-1.12-4.595-5.16-9.39-13.002-9.39-7.6 0-14.442 5.754-14.442 14.784 0 9.03 6.601 14.744 14.522 14.744zM84.527 23.414c.12-2.157 1.44-3.836 3.68-3.836 2.561 0 3.641 1.719 3.641 3.916v11.468h5.321V22.575c0-4.315-2.32-7.791-7.32-7.791-1.881 0-4.041.639-5.322 2.157V6.033h-5.32v28.929h5.32V23.414zM100.569 29.608c0 3.076 2.56 5.913 6.761 5.913 2.92 0 4.8-1.358 5.801-2.917 0 .76.08 1.838.2 2.358h4.88c-.12-.68-.24-2.078-.24-3.117v-9.67c0-3.955-2.32-7.471-8.561-7.471-5.281 0-8.121 3.396-8.441 6.473l4.721.999c.16-1.718 1.44-3.197 3.76-3.197 2.24 0 3.321 1.159 3.321 2.557 0 .68-.361 1.24-1.481 1.399l-4.84.72c-3.281.479-5.881 2.436-5.881 5.953zm7.881 1.957c-1.72 0-2.56-1.118-2.56-2.277 0-1.518 1.08-2.277 2.44-2.477l4.441-.68v.88c0 3.476-2.081 4.555-4.321 4.555zM128.978 9.43h-4.801v2.757c0 1.758-.96 3.116-3.04 3.116h-1v4.715h3.56v9.15c0 3.796 2.401 6.074 6.241 6.074 1.56 0 2.52-.28 3-.48v-4.395c-.28.08-1 .16-1.64.16-1.52 0-2.32-.56-2.32-2.278v-8.231h3.96v-4.715h-3.96V9.43zM151.546 29.847v-18.1h4.44c4.641 0 8.481 2.917 8.481 9.07 0 6.154-3.88 9.03-8.521 9.03h-4.4zm4.6 5.115c8.081 0 14.042-5.195 14.042-14.145s-5.921-14.184-14.002-14.184h-10.161v28.329h10.121zM177.772 22.895c.12-1.798 1.64-3.876 4.4-3.876 3.041 0 4.321 1.918 4.401 3.876h-8.801zm9.321 5.114c-.64 1.758-2 2.997-4.481 2.997-2.64 0-4.84-1.878-4.96-4.475h14.081c0-.08.08-.88.08-1.638 0-6.313-3.64-10.19-9.721-10.19-5.041 0-9.681 4.076-9.681 10.35 0 6.632 4.76 10.508 10.161 10.508 4.841 0 7.961-2.837 8.961-6.233l-4.44-1.319zM200.524 34.962V23.454c0-2.157 1.36-3.876 3.68-3.876 2.401 0 3.481 1.599 3.481 3.716v11.668h5.281V23.454c0-2.117 1.36-3.876 3.64-3.876 2.44 0 3.481 1.599 3.481 3.716v11.668h5.16V22.216c0-5.275-3.48-7.472-7.121-7.472-2.6 0-4.68.879-6.241 3.276-1-2.117-3.16-3.276-5.84-3.276-2.161 0-4.681 1.039-5.761 2.957v-2.398h-5.081v19.659h5.321zM238.679 30.726c-2.601 0-5.001-1.918-5.001-5.593 0-3.716 2.4-5.594 5.001-5.594 2.6 0 5 1.877 5 5.593s-2.4 5.594-5 5.594zm0-16.022c-5.881 0-10.322 4.355-10.322 10.428 0 6.034 4.441 10.43 10.322 10.43 5.88 0 10.321-4.396 10.321-10.43 0-6.073-4.441-10.428-10.321-10.428z",
    fill: "#fff"
  })));
}

var _templateObject$I, _templateObject2$E;
var Container$p = styled.div(_templateObject$I || (_templateObject$I = _taggedTemplateLiteralLoose(["\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-between;\n  padding: 0 16px;\n  height: 60px;\n  flex: none;\n  background-color: ", ";\n"])), colors.blue10);
var Logo = styled.div(_templateObject2$E || (_templateObject2$E = _taggedTemplateLiteralLoose(["\n  width: 134px;\n  height: 22px;\n"])));

function SceytChatHeader() {
  return React__default.createElement(Container$p, null, React__default.createElement(Logo, null, React__default.createElement(SvgChatLogo, null)));
}

var _path$1k;

function _extends$1o() {
  _extends$1o = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1o.apply(this, arguments);
}

function SvgChevronDown(props) {
  return /*#__PURE__*/createElement("svg", _extends$1o({
    width: 32,
    height: 32,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$1k || (_path$1k = /*#__PURE__*/createElement("path", {
    d: "M9.298 12.937a1.056 1.056 0 10-1.374 1.603l7.39 6.333c.395.339.978.339 1.373 0l7.389-6.333a1.056 1.056 0 10-1.374-1.603L16 18.68l-6.702-5.744z",
    fill: "CurrentColor"
  })));
}

var _templateObject$J, _templateObject2$F;

var MessagesScrollToBottomButton = function MessagesScrollToBottomButton(_ref) {
  var buttonIcon = _ref.buttonIcon,
      buttonWidth = _ref.buttonWidth,
      buttonHeight = _ref.buttonHeight,
      buttonBorder = _ref.buttonBorder,
      buttonBackgroundColor = _ref.buttonBackgroundColor,
      buttonHoverBackgroundColor = _ref.buttonHoverBackgroundColor,
      buttonBorderRadius = _ref.buttonBorderRadius,
      buttonShadow = _ref.buttonShadow,
      unreadCountWidth = _ref.unreadCountWidth,
      unreadCountHeight = _ref.unreadCountHeight,
      unreadCountFontSize = _ref.unreadCountFontSize,
      unreadCountTextColor = _ref.unreadCountTextColor;
  var dispatch = useDispatch();
  var channel = useSelector(activeChannelSelector);
  var sendMessageInputHeight = useSelector(sendMessageInputHeightSelector);
  var showScrollToNewMessageButton = useSelector(showScrollToNewMessageButtonSelector);

  var handleScrollToBottom = function handleScrollToBottom() {
    console.log('scroll buttun cliced ... ');
    dispatch(scrollToNewMessageAC(true, true));
  };

  return React__default.createElement(React__default.Fragment, null, showScrollToNewMessageButton && React__default.createElement(BottomButton, {
    width: buttonWidth,
    height: buttonHeight,
    border: buttonBorder,
    borderRadius: buttonBorderRadius,
    backgroundColor: buttonBackgroundColor,
    hoverBackgroundColor: buttonHoverBackgroundColor,
    shadow: buttonShadow,
    onClick: handleScrollToBottom,
    bottomPos: sendMessageInputHeight
  }, !!(channel.unreadMessageCount && channel.unreadMessageCount > 0) && React__default.createElement(UnreadCount$1, {
    width: unreadCountWidth,
    height: unreadCountHeight,
    textColor: unreadCountTextColor,
    fontSize: unreadCountFontSize,
    backgroundColor: colors.primary,
    isMuted: channel.muted
  }, channel.unreadMessageCount ? channel.unreadMessageCount > 99 ? '99+' : channel.unreadMessageCount : ''), buttonIcon || React__default.createElement(SvgChevronDown, null)));
};
var BottomButton = styled.div(_templateObject$J || (_templateObject$J = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  bottom: ", ";\n  right: 16px;\n  margin-right: 16px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background-color: ", ";\n  border: 0.5px solid rgba(0, 0, 0, 0.1);\n  border-radius: 50px;\n  width: 48px;\n  height: 48px;\n  cursor: pointer;\n  z-index: 14;\n\n  & > svg {\n    color: rgba(129, 140, 153, 1);\n  }\n\n  & > span {\n    bottom: 32px;\n    right: 0;\n  }\n"])), function (props) {
  return props.bottomPos + 45 + "px";
}, colors.white);
var UnreadCount$1 = styled.span(_templateObject2$F || (_templateObject2$F = _taggedTemplateLiteralLoose(["\n  position: absolute;\n  bottom: 11px;\n  right: 16px;\n  flex: 0 0 auto;\n  margin-left: auto;\n  background-color: ", ";\n  padding: 0 4px;\n  font-size: ", ";\n  line-height: 20px;\n  min-width: ", ";\n  height: ", ";\n  text-align: center;\n  font-weight: 500;\n  color: ", ";\n  border-radius: 10px;\n  box-sizing: border-box;\n\n  /*", "*/\n"])), function (props) {
  return props.backgroundColor || colors.cobalt1;
}, function (props) {
  return props.fontSize || '13px';
}, function (props) {
  return props.width || '20px';
}, function (props) {
  return props.height || '20px';
}, function (props) {
  return props.textColor || '#fff';
}, function (props) {
  return props.isMuted && 'background-color: #BEBFC7;';
});

export { Avatar, ChannelDetailsContainer as ChannelDetails, ChannelList, Chat$1 as Chat, ChatHeader, MessageList, MessagesScrollToBottomButton, SceytChatContainer as SceytChat, SceytChatHeader, SendMessageInput as SendMessage };
//# sourceMappingURL=index.modern.js.map
